This is django-tastypie.info, produced by makeinfo version 4.13 from
django-tastypie.texi.

Generated by Sphinx 1.1.3.
INFO-DIR-SECTION Web development
START-INFO-DIR-ENTRY
* Tastypie: (django-tastypie.info). Documentation of the Tastypie framework
END-INFO-DIR-ENTRY

     Tastypie 0.9.12-alpha, January 02, 2013

     Copyright (C) 2010-2012, Daniel Lindsley, Cody Soyland, Matt
     Croydon, Josh Bohde & Issac Kelly


File: django-tastypie.info,  Node: Top,  Next: Welcome to Tastypie!,  Up: (dir)

Table Of Contents
*****************

     Tastypie 0.9.12-alpha, January 02, 2013

     Copyright (C) 2010-2012, Daniel Lindsley, Cody Soyland, Matt
     Croydon, Josh Bohde & Issac Kelly

* Menu:

* Welcome to Tastypie!::
* Getting Help::
* Quick Start: Quick Start<4>.
* Requirements::
* Why Tastypie?::
* Reference Material::
* Running The Tests::
* Commercial Support::
* Getting Started with Tastypie: Getting Started with Tastypie<2>.
* Interacting With The API: Interacting With The API<2>.
* Tastypie Settings: Tastypie Settings<2>.
* Using Tastypie With Non-ORM Data Sources: Using Tastypie With Non-ORM Data Sources<2>.
* Tools: Tools<2>.
* Testing: Testing<2>.
* Compatibility Notes: Compatibility Notes<2>.
* Resources: Resources<2>.
* Bundles: Bundles<2>.
* Api: Api<2>.
* Resource Fields: Resource Fields<2>.
* Caching: Caching<2>.
* Validation: Validation<3>.
* Authentication / Authorization: Authentication / Authorization<2>.
* Serialization: Serialization<2>.
* Throttling: Throttling<2>.
* Paginator: Paginator<2>.
* GeoDjango: GeoDjango<2>.
* ContentTypes and GenericForeignKeys: ContentTypes and GenericForeignKeys<2>.
* Tastypie Cookbook: Tastypie Cookbook<2>.
* Debugging Tastypie: Debugging Tastypie<2>.
* Sites Using Tastypie: Sites Using Tastypie<2>.
* Contributing: Contributing<2>.
* Indices and tables::
* Python Module Index::
* Index::

 --- The Detailed Node Listing ---

Welcome to Tastypie!

* Getting Started with Tastypie::
* Interacting With The API::
* Tastypie Settings::
* Using Tastypie With Non-ORM Data Sources::
* Tools::
* Testing::
* Compatibility Notes::
* Resources::
* Bundles::
* Api::
* Resource Fields::
* Caching::
* Validation::
* Authentication / Authorization::
* Serialization::
* Throttling::
* Paginator::
* GeoDjango::
* ContentTypes and GenericForeignKeys::
* Tastypie Cookbook::
* Debugging Tastypie::
* Sites Using Tastypie::
* Contributing::

Getting Started with Tastypie

* Installation::
* Configuration::
* Creating Resources::
* Hooking Up The Resource(s): Hooking Up The Resource s.
* Creating More Resources::
* Adding To The Api::
* Limiting Data And Access::
* Beyond The Basics::

Interacting With The API

* Front Matter::
* Fetching Data::
* Sending Data::
* Deleting Data::
* Bulk Operations::
* You Did It!::

Fetching Data

* Api-Wide::
* Inspecting The Resource's Schema::
* Getting A Collection Of Resources::
* Getting A Detail Resource::
* Selecting A Subset Of Resources::

Sending Data

* Creating A New Resource (POST): Creating A New Resource POST.
* Updating An Existing Resource (PUT): Updating An Existing Resource PUT.
* Partially Updating An Existing Resource (PATCH): Partially Updating An Existing Resource PATCH.
* Updating A Whole Collection Of Resources (PUT): Updating A Whole Collection Of Resources PUT.

Deleting Data

* Deleting A Single Resource::
* Deleting A Whole Collection Of Resources::

Tastypie Settings

* API_LIMIT_PER_PAGE::
* TASTYPIE_FULL_DEBUG::
* TASTYPIE_CANNED_ERROR::
* TASTYPIE_ALLOW_MISSING_SLASH::
* TASTYPIE_DATETIME_FORMATTING::

Using Tastypie With Non-ORM Data Sources

* Approach::
* Using Riak for MessageResource::

Tools

* Browser::
* Extensions::
* Python::
* Javascript::

Browser

* JSONView::

Extensions

* Tastypie-msgpack::

Python

* Slumber::
* drest::
* json.tool: json tool.

Javascript

* backbone-tastypie::
* backbone-relational::

Testing

* Example Usage::

Example Usage

* ResourceTestCase API Reference::
* TestApiClient API Reference::

ResourceTestCase API Reference

* get_credentials::
* create_basic::
* create_apikey::
* create_digest::
* create_oauth::
* assertHttpOK::
* assertHttpCreated::
* assertHttpAccepted::
* assertHttpMultipleChoices::
* assertHttpSeeOther::
* assertHttpNotModified::
* assertHttpBadRequest::
* assertHttpUnauthorized::
* assertHttpForbidden::
* assertHttpNotFound::
* assertHttpMethodNotAllowed::
* assertHttpConflict::
* assertHttpGone::
* assertHttpTooManyRequests::
* assertHttpApplicationError::
* assertHttpNotImplemented::
* assertValidJSON::
* assertValidXML::
* assertValidYAML::
* assertValidPlist::
* assertValidJSONResponse::
* assertValidXMLResponse::
* assertValidYAMLResponse::
* assertValidPlistResponse::
* deserialize::
* serialize::
* assertKeys::

TestApiClient API Reference

* __init__::
* get_content_type::
* get::
* post::
* put::
* patch::
* delete::

Compatibility Notes

* ApiKey Database Index::

Resources

* Quick Start::
* Why Class-Based?::
* Why Resource vs. ModelResource?: Why Resource vs ModelResource?.
* Flow Through The Request/Response Cycle::
* Why Resource URIs?::
* Advanced Data Preparation::
* Reverse "Relationships"::
* Resource Options (AKA Meta): Resource Options AKA Meta.
* Basic Filtering::
* Advanced Filtering::
* Using PUT/DELETE/PATCH In Unsupported Places::
* Resource Methods::
* ModelResource Methods::

Advanced Data Preparation

* The Dehydrate Cycle::
* The Hydrate Cycle::

The Dehydrate Cycle

* Per-field dehydrate::
* dehydrate_FOO::
* dehydrate::

The Hydrate Cycle

* hydrate::
* hydrate_FOO::
* Per-field hydrate::

Resource Options (AKA Meta)

* serializer::
* authentication::
* authorization::
* validation::
* paginator_class::
* cache::
* throttle::
* allowed_methods::
* list_allowed_methods::
* detail_allowed_methods::
* limit::
* max_limit::
* api_name::
* resource_name::
* default_format::
* filtering::
* ordering::
* object_class::
* queryset::
* fields::
* excludes::
* include_resource_uri::
* include_absolute_url::
* always_return_data::
* collection_name::
* detail_uri_name::

Resource Methods

* wrap_view::
* base_urls::
* override_urls::
* prepend_urls::
* urls::
* determine_format::
* serialize: serialize<2>.
* deserialize: deserialize<2>.
* alter_list_data_to_serialize::
* alter_detail_data_to_serialize::
* alter_deserialized_list_data::
* alter_deserialized_detail_data::
* dispatch_list::
* dispatch_detail::
* dispatch::
* remove_api_resource_names::
* method_check::
* is_authorized::
* is_authenticated::
* throttle_check::
* log_throttled_access::
* build_bundle::
* build_filters::
* apply_sorting::
* get_bundle_detail_data::
* get_resource_uri::
* resource_uri_kwargs::
* detail_uri_kwargs::
* get_via_uri::
* full_dehydrate::
* dehydrate: dehydrate<2>.
* full_hydrate::
* hydrate: hydrate<2>.
* hydrate_m2m::
* build_schema::
* dehydrate_resource_uri::
* generate_cache_key::
* get_object_list::
* apply_authorization_limits::
* can_create::
* can_update::
* can_delete::
* apply_filters::
* obj_get_list::
* cached_obj_get_list::
* obj_get::
* cached_obj_get::
* obj_create::
* lookup_kwargs_with_identifiers::
* obj_update::
* obj_delete_list::
* obj_delete::
* create_response::
* is_valid::
* rollback::
* get_list::
* get_detail::
* put_list::
* put_detail::
* post_list::
* post_detail::
* delete_list::
* delete_detail::
* patch_list::
* patch_detail::
* get_schema::
* get_multiple::

ModelResource Methods

* should_skip_field::
* api_field_from_django_field::
* get_fields::
* check_filtering::
* build_filters: build_filters<2>.
* apply_sorting: apply_sorting<2>.
* apply_filters: apply_filters<2>.
* get_object_list: get_object_list<2>.
* obj_get_list: obj_get_list<2>.
* obj_get: obj_get<2>.
* obj_create: obj_create<2>.
* obj_update: obj_update<2>.
* obj_delete_list: obj_delete_list<2>.
* obj_delete: obj_delete<2>.
* rollback: rollback<2>.
* save_related::
* save_m2m::
* get_resource_uri: get_resource_uri<2>.

Bundles

* What Are Bundles?::
* Attributes::

Attributes

* obj::
* data::
* request::
* related_obj::
* related_name::

Api

* Quick Start: Quick Start<2>.
* Api Methods::

Api Methods

* register::
* unregister::
* canonical_resource_for::
* urls: urls<2>.
* top_level::

canonical_resource_for

* override_urls: override_urls<2>.
* prepend_urls: prepend_urls<2>.

Resource Fields

* Quick Start: Quick Start<3>.
* Standard Data Fields::
* Relationship Fields::

Standard Data Fields

* Common Field Options::
* Field Types::
* BooleanField::
* CharField::
* DateField::
* DateTimeField::
* DecimalField::
* DictField::
* FileField::
* FloatField::
* IntegerField::
* ListField::
* TimeField::

Common Field Options

* attribute::
* default::
* null::
* blank::
* readonly::
* unique::
* help_text::

Relationship Fields

* Common Field Options: Common Field Options<2>.
* Field Types: Field Types<2>.

Common Field Options

* to::
* full::
* related_name: related_name<2>.

Field Types

* ToOneField::
* OneToOneField::
* ForeignKey::
* ToManyField::
* ManyToManyField::
* OneToManyField::

Caching

* Usage::
* Caching Options::
* Implementing Your Own Cache::
* HTTP Cache-Control::
* HTTP Vary::

Caching Options

* NoCache::
* SimpleCache::

Validation

* Usage: Usage<2>.
* Validation Options::
* Implementing Your Own Validation::

Validation Options

* Validation: Validation<2>.
* FormValidation::
* CleanedDataFormValidation::

Authentication / Authorization

* Usage: Usage<3>.
* Authentication Options::
* Authorization Options::
* Implementing Your Own Authentication/Authorization::

Authentication Options

* Authentication::
* BasicAuthentication::
* ApiKeyAuthentication::
* SessionAuthentication::
* DigestAuthentication::
* OAuthAuthentication::
* MultiAuthentication::

Authorization Options

* Authorization::
* ReadOnlyAuthorization::
* DjangoAuthorization::

Serialization

* Usage: Usage<4>.
* Implementing Your Own Serializer::
* Serializer Methods::

Serializer Methods

* get_mime_for_format::
* format_datetime::
* format_date::
* format_time::
* serialize: serialize<3>.
* deserialize: deserialize<3>.
* to_simple::
* to_etree::
* from_etree::
* to_json::
* from_json::
* to_jsonp::
* to_xml::
* from_xml::
* to_yaml::
* from_yaml::
* to_plist::
* from_plist::
* to_html::
* from_html::

Throttling

* Usage: Usage<5>.
* Throttle Options::
* Implementing Your Own Throttle::

Throttle Options

* BaseThrottle::
* CacheThrottle::
* CacheDBThrottle::

Paginator

* Usage: Usage<6>.
* Implementing Your Own Paginator::

GeoDjango

* Usage: Usage<7>.

Usage

* Filtering::

ContentTypes and GenericForeignKeys

* Usage: Usage<8>.

Tastypie Cookbook

* Adding Custom Values::
* Per-Request Alterations To The Queryset::
* Using Your Resource In Regular Views::
* Using Non-PK Data For Your URLs::
* Nested Resources::
* Adding Search Functionality::
* Creating per-user resources::
* camelCase JSON Serialization::
* Pretty-printed JSON Serialization::
* Determining format via URL::
* Adding to the Django Admin::
* Using SessionAuthentication::

Debugging Tastypie

* "I'm getting XML output in my browser but I want JSON output!"::
* "What's the format for a POST or PUT?"::
* "Why is my syncdb with superuser failing with a DatabaseError?"::

Sites Using Tastypie

* LJWorld Marketplace::
* Forkinit::
* Read The Docs::
* Luzme::
* Politifact::
* Crate::
* LocalWiki::
* I-Am-CC.org: I-Am-CC org.

Contributing

* Philosophy::
* Guidelines For Reporting An Issue/Feature::
* Guidelines For Contributing Code::
* Guidelines For Core Contributors::

Requirements

* Required::
* Optional::

Getting Started with Tastypie

* Installation: Installation<2>.
* Configuration: Configuration<2>.
* Creating Resources: Creating Resources<2>.
* Hooking Up The Resource(s): Hooking Up The Resource s<2>.
* Creating More Resources: Creating More Resources<2>.
* Adding To The Api: Adding To The Api<2>.
* Limiting Data And Access: Limiting Data And Access<2>.
* Beyond The Basics: Beyond The Basics<2>.

Interacting With The API

* Front Matter: Front Matter<2>.
* Fetching Data: Fetching Data<2>.
* Sending Data: Sending Data<2>.
* Deleting Data: Deleting Data<2>.
* Bulk Operations: Bulk Operations<2>.
* You Did It!: You Did It!<2>.

Fetching Data

* Api-Wide: Api-Wide<2>.
* Inspecting The Resource's Schema: Inspecting The Resource's Schema<2>.
* Getting A Collection Of Resources: Getting A Collection Of Resources<2>.
* Getting A Detail Resource: Getting A Detail Resource<2>.
* Selecting A Subset Of Resources: Selecting A Subset Of Resources<2>.

Sending Data

* Creating A New Resource (POST): Creating A New Resource POST<2>.
* Updating An Existing Resource (PUT): Updating An Existing Resource PUT<2>.
* Partially Updating An Existing Resource (PATCH): Partially Updating An Existing Resource PATCH<2>.
* Updating A Whole Collection Of Resources (PUT): Updating A Whole Collection Of Resources PUT<2>.

Deleting Data

* Deleting A Single Resource: Deleting A Single Resource<2>.
* Deleting A Whole Collection Of Resources: Deleting A Whole Collection Of Resources<2>.

Tastypie Settings

* API_LIMIT_PER_PAGE: API_LIMIT_PER_PAGE<2>.
* TASTYPIE_FULL_DEBUG: TASTYPIE_FULL_DEBUG<2>.
* TASTYPIE_CANNED_ERROR: TASTYPIE_CANNED_ERROR<2>.
* TASTYPIE_ALLOW_MISSING_SLASH: TASTYPIE_ALLOW_MISSING_SLASH<2>.
* TASTYPIE_DATETIME_FORMATTING: TASTYPIE_DATETIME_FORMATTING<2>.

Using Tastypie With Non-ORM Data Sources

* Approach: Approach<2>.
* Using Riak for MessageResource: Using Riak for MessageResource<2>.

Tools

* Browser: Browser<2>.
* Extensions: Extensions<2>.
* Python: Python<2>.
* Javascript: Javascript<2>.

Browser

* JSONView: JSONView<2>.

Extensions

* Tastypie-msgpack: Tastypie-msgpack<2>.

Python

* Slumber: Slumber<2>.
* drest: drest<2>.
* json.tool: json tool<2>.

Javascript

* backbone-tastypie: backbone-tastypie<2>.
* backbone-relational: backbone-relational<2>.

Testing

* Example Usage: Example Usage<2>.

Example Usage

* ResourceTestCase API Reference: ResourceTestCase API Reference<2>.
* TestApiClient API Reference: TestApiClient API Reference<2>.

ResourceTestCase API Reference

* get_credentials: get_credentials<2>.
* create_basic: create_basic<2>.
* create_apikey: create_apikey<2>.
* create_digest: create_digest<2>.
* create_oauth: create_oauth<2>.
* assertHttpOK: assertHttpOK<2>.
* assertHttpCreated: assertHttpCreated<2>.
* assertHttpAccepted: assertHttpAccepted<2>.
* assertHttpMultipleChoices: assertHttpMultipleChoices<2>.
* assertHttpSeeOther: assertHttpSeeOther<2>.
* assertHttpNotModified: assertHttpNotModified<2>.
* assertHttpBadRequest: assertHttpBadRequest<2>.
* assertHttpUnauthorized: assertHttpUnauthorized<2>.
* assertHttpForbidden: assertHttpForbidden<2>.
* assertHttpNotFound: assertHttpNotFound<2>.
* assertHttpMethodNotAllowed: assertHttpMethodNotAllowed<2>.
* assertHttpConflict: assertHttpConflict<2>.
* assertHttpGone: assertHttpGone<2>.
* assertHttpTooManyRequests: assertHttpTooManyRequests<2>.
* assertHttpApplicationError: assertHttpApplicationError<2>.
* assertHttpNotImplemented: assertHttpNotImplemented<2>.
* assertValidJSON: assertValidJSON<2>.
* assertValidXML: assertValidXML<2>.
* assertValidYAML: assertValidYAML<2>.
* assertValidPlist: assertValidPlist<2>.
* assertValidJSONResponse: assertValidJSONResponse<2>.
* assertValidXMLResponse: assertValidXMLResponse<2>.
* assertValidYAMLResponse: assertValidYAMLResponse<2>.
* assertValidPlistResponse: assertValidPlistResponse<2>.
* deserialize: deserialize<4>.
* serialize: serialize<4>.
* assertKeys: assertKeys<2>.

TestApiClient API Reference

* __init__: __init__<2>.
* get_content_type: get_content_type<2>.
* get: get<2>.
* post: post<2>.
* put: put<2>.
* patch: patch<2>.
* delete: delete<2>.

Compatibility Notes

* ApiKey Database Index: ApiKey Database Index<2>.

Resources

* Quick Start: Quick Start<5>.
* Why Class-Based?: Why Class-Based?<2>.
* Why Resource vs. ModelResource?: Why Resource vs ModelResource?<2>.
* Flow Through The Request/Response Cycle: Flow Through The Request/Response Cycle<2>.
* Why Resource URIs?: Why Resource URIs?<2>.
* Advanced Data Preparation: Advanced Data Preparation<2>.
* Reverse "Relationships": Reverse "Relationships"<2>.
* Resource Options (AKA Meta): Resource Options AKA Meta<2>.
* Basic Filtering: Basic Filtering<2>.
* Advanced Filtering: Advanced Filtering<2>.
* Using PUT/DELETE/PATCH In Unsupported Places: Using PUT/DELETE/PATCH In Unsupported Places<2>.
* Resource Methods: Resource Methods<2>.
* ModelResource Methods: ModelResource Methods<2>.

Advanced Data Preparation

* The Dehydrate Cycle: The Dehydrate Cycle<2>.
* The Hydrate Cycle: The Hydrate Cycle<2>.

The Dehydrate Cycle

* Per-field dehydrate: Per-field dehydrate<2>.
* dehydrate_FOO: dehydrate_FOO<2>.
* dehydrate: dehydrate<3>.

The Hydrate Cycle

* hydrate: hydrate<3>.
* hydrate_FOO: hydrate_FOO<2>.
* Per-field hydrate: Per-field hydrate<2>.

Resource Options (AKA Meta)

* serializer: serializer<2>.
* authentication: authentication<2>.
* authorization: authorization<2>.
* validation: validation<2>.
* paginator_class: paginator_class<2>.
* cache: cache<2>.
* throttle: throttle<2>.
* allowed_methods: allowed_methods<2>.
* list_allowed_methods: list_allowed_methods<2>.
* detail_allowed_methods: detail_allowed_methods<2>.
* limit: limit<2>.
* max_limit: max_limit<2>.
* api_name: api_name<2>.
* resource_name: resource_name<2>.
* default_format: default_format<2>.
* filtering: filtering<2>.
* ordering: ordering<2>.
* object_class: object_class<2>.
* queryset: queryset<2>.
* fields: fields<2>.
* excludes: excludes<2>.
* include_resource_uri: include_resource_uri<2>.
* include_absolute_url: include_absolute_url<2>.
* always_return_data: always_return_data<2>.
* collection_name: collection_name<2>.
* detail_uri_name: detail_uri_name<2>.

Resource Methods

* wrap_view: wrap_view<2>.
* base_urls: base_urls<2>.
* override_urls: override_urls<3>.
* prepend_urls: prepend_urls<3>.
* urls: urls<3>.
* determine_format: determine_format<2>.
* serialize: serialize<5>.
* deserialize: deserialize<5>.
* alter_list_data_to_serialize: alter_list_data_to_serialize<2>.
* alter_detail_data_to_serialize: alter_detail_data_to_serialize<2>.
* alter_deserialized_list_data: alter_deserialized_list_data<2>.
* alter_deserialized_detail_data: alter_deserialized_detail_data<2>.
* dispatch_list: dispatch_list<2>.
* dispatch_detail: dispatch_detail<2>.
* dispatch: dispatch<2>.
* remove_api_resource_names: remove_api_resource_names<2>.
* method_check: method_check<2>.
* is_authorized: is_authorized<2>.
* is_authenticated: is_authenticated<2>.
* throttle_check: throttle_check<2>.
* log_throttled_access: log_throttled_access<2>.
* build_bundle: build_bundle<2>.
* build_filters: build_filters<3>.
* apply_sorting: apply_sorting<3>.
* get_bundle_detail_data: get_bundle_detail_data<2>.
* get_resource_uri: get_resource_uri<3>.
* resource_uri_kwargs: resource_uri_kwargs<2>.
* detail_uri_kwargs: detail_uri_kwargs<2>.
* get_via_uri: get_via_uri<2>.
* full_dehydrate: full_dehydrate<2>.
* dehydrate: dehydrate<4>.
* full_hydrate: full_hydrate<2>.
* hydrate: hydrate<4>.
* hydrate_m2m: hydrate_m2m<2>.
* build_schema: build_schema<2>.
* dehydrate_resource_uri: dehydrate_resource_uri<2>.
* generate_cache_key: generate_cache_key<2>.
* get_object_list: get_object_list<3>.
* apply_authorization_limits: apply_authorization_limits<2>.
* can_create: can_create<2>.
* can_update: can_update<2>.
* can_delete: can_delete<2>.
* apply_filters: apply_filters<3>.
* obj_get_list: obj_get_list<3>.
* cached_obj_get_list: cached_obj_get_list<2>.
* obj_get: obj_get<3>.
* cached_obj_get: cached_obj_get<2>.
* obj_create: obj_create<3>.
* lookup_kwargs_with_identifiers: lookup_kwargs_with_identifiers<2>.
* obj_update: obj_update<3>.
* obj_delete_list: obj_delete_list<3>.
* obj_delete: obj_delete<3>.
* create_response: create_response<2>.
* is_valid: is_valid<2>.
* rollback: rollback<3>.
* get_list: get_list<2>.
* get_detail: get_detail<2>.
* put_list: put_list<2>.
* put_detail: put_detail<2>.
* post_list: post_list<2>.
* post_detail: post_detail<2>.
* delete_list: delete_list<2>.
* delete_detail: delete_detail<2>.
* patch_list: patch_list<2>.
* patch_detail: patch_detail<2>.
* get_schema: get_schema<2>.
* get_multiple: get_multiple<2>.

ModelResource Methods

* should_skip_field: should_skip_field<2>.
* api_field_from_django_field: api_field_from_django_field<2>.
* get_fields: get_fields<2>.
* check_filtering: check_filtering<2>.
* build_filters: build_filters<4>.
* apply_sorting: apply_sorting<4>.
* apply_filters: apply_filters<4>.
* get_object_list: get_object_list<4>.
* obj_get_list: obj_get_list<4>.
* obj_get: obj_get<4>.
* obj_create: obj_create<4>.
* obj_update: obj_update<4>.
* obj_delete_list: obj_delete_list<4>.
* obj_delete: obj_delete<4>.
* rollback: rollback<4>.
* save_related: save_related<2>.
* save_m2m: save_m2m<2>.
* get_resource_uri: get_resource_uri<4>.

Bundles

* What Are Bundles?: What Are Bundles?<2>.
* Attributes: Attributes<2>.

Attributes

* obj: obj<2>.
* data: data<2>.
* request: request<2>.
* related_obj: related_obj<2>.
* related_name: related_name<3>.

Api

* Quick Start: Quick Start<6>.
* Api Methods: Api Methods<2>.

Api Methods

* register: register<2>.
* unregister: unregister<2>.
* canonical_resource_for: canonical_resource_for<2>.
* urls: urls<4>.
* top_level: top_level<2>.

canonical_resource_for

* override_urls: override_urls<4>.
* prepend_urls: prepend_urls<4>.

Resource Fields

* Quick Start: Quick Start<7>.
* Standard Data Fields: Standard Data Fields<2>.
* Relationship Fields: Relationship Fields<2>.

Standard Data Fields

* Common Field Options: Common Field Options<3>.
* Field Types: Field Types<3>.
* BooleanField: BooleanField<2>.
* CharField: CharField<2>.
* DateField: DateField<2>.
* DateTimeField: DateTimeField<2>.
* DecimalField: DecimalField<2>.
* DictField: DictField<2>.
* FileField: FileField<2>.
* FloatField: FloatField<2>.
* IntegerField: IntegerField<2>.
* ListField: ListField<2>.
* TimeField: TimeField<2>.

Common Field Options

* attribute: attribute<2>.
* default: default<2>.
* null: null<2>.
* blank: blank<2>.
* readonly: readonly<2>.
* unique: unique<2>.
* help_text: help_text<2>.

Relationship Fields

* Common Field Options: Common Field Options<4>.
* Field Types: Field Types<4>.

Common Field Options

* to: to<2>.
* full: full<2>.
* related_name: related_name<4>.

Field Types

* ToOneField: ToOneField<2>.
* OneToOneField: OneToOneField<2>.
* ForeignKey: ForeignKey<2>.
* ToManyField: ToManyField<2>.
* ManyToManyField: ManyToManyField<2>.
* OneToManyField: OneToManyField<2>.

Caching

* Usage: Usage<9>.
* Caching Options: Caching Options<2>.
* Implementing Your Own Cache: Implementing Your Own Cache<2>.
* HTTP Cache-Control: HTTP Cache-Control<2>.
* HTTP Vary: HTTP Vary<2>.

Caching Options

* NoCache: NoCache<2>.
* SimpleCache: SimpleCache<2>.

Validation

* Usage: Usage<10>.
* Validation Options: Validation Options<2>.
* Implementing Your Own Validation: Implementing Your Own Validation<2>.

Validation Options

* Validation: Validation<4>.
* FormValidation: FormValidation<2>.
* CleanedDataFormValidation: CleanedDataFormValidation<2>.

Authentication / Authorization

* Usage: Usage<11>.
* Authentication Options: Authentication Options<2>.
* Authorization Options: Authorization Options<2>.
* Implementing Your Own Authentication/Authorization: Implementing Your Own Authentication/Authorization<2>.

Authentication Options

* Authentication: Authentication<2>.
* BasicAuthentication: BasicAuthentication<2>.
* ApiKeyAuthentication: ApiKeyAuthentication<2>.
* SessionAuthentication: SessionAuthentication<2>.
* DigestAuthentication: DigestAuthentication<2>.
* OAuthAuthentication: OAuthAuthentication<2>.
* MultiAuthentication: MultiAuthentication<2>.

Authorization Options

* Authorization: Authorization<2>.
* ReadOnlyAuthorization: ReadOnlyAuthorization<2>.
* DjangoAuthorization: DjangoAuthorization<2>.

Serialization

* Usage: Usage<12>.
* Implementing Your Own Serializer: Implementing Your Own Serializer<2>.
* Serializer Methods: Serializer Methods<2>.

Serializer Methods

* get_mime_for_format: get_mime_for_format<2>.
* format_datetime: format_datetime<2>.
* format_date: format_date<2>.
* format_time: format_time<2>.
* serialize: serialize<6>.
* deserialize: deserialize<6>.
* to_simple: to_simple<2>.
* to_etree: to_etree<2>.
* from_etree: from_etree<2>.
* to_json: to_json<2>.
* from_json: from_json<2>.
* to_jsonp: to_jsonp<2>.
* to_xml: to_xml<2>.
* from_xml: from_xml<2>.
* to_yaml: to_yaml<2>.
* from_yaml: from_yaml<2>.
* to_plist: to_plist<2>.
* from_plist: from_plist<2>.
* to_html: to_html<2>.
* from_html: from_html<2>.

Throttling

* Usage: Usage<13>.
* Throttle Options: Throttle Options<2>.
* Implementing Your Own Throttle: Implementing Your Own Throttle<2>.

Throttle Options

* BaseThrottle: BaseThrottle<2>.
* CacheThrottle: CacheThrottle<2>.
* CacheDBThrottle: CacheDBThrottle<2>.

Paginator

* Usage: Usage<14>.
* Implementing Your Own Paginator: Implementing Your Own Paginator<2>.

GeoDjango

* Usage: Usage<15>.

Usage

* Filtering: Filtering<2>.

ContentTypes and GenericForeignKeys

* Usage: Usage<16>.

Tastypie Cookbook

* Adding Custom Values: Adding Custom Values<2>.
* Per-Request Alterations To The Queryset: Per-Request Alterations To The Queryset<2>.
* Using Your Resource In Regular Views: Using Your Resource In Regular Views<2>.
* Using Non-PK Data For Your URLs: Using Non-PK Data For Your URLs<2>.
* Nested Resources: Nested Resources<2>.
* Adding Search Functionality: Adding Search Functionality<2>.
* Creating per-user resources: Creating per-user resources<2>.
* camelCase JSON Serialization: camelCase JSON Serialization<2>.
* Pretty-printed JSON Serialization: Pretty-printed JSON Serialization<2>.
* Determining format via URL: Determining format via URL<2>.
* Adding to the Django Admin: Adding to the Django Admin<2>.
* Using SessionAuthentication: Using SessionAuthentication<2>.

Debugging Tastypie

* "I'm getting XML output in my browser but I want JSON output!": "I'm getting XML output in my browser but I want JSON output!"<2>.
* "What's the format for a POST or PUT?": "What's the format for a POST or PUT?"<2>.
* "Why is my syncdb with superuser failing with a DatabaseError?": "Why is my syncdb with superuser failing with a DatabaseError?"<2>.

Sites Using Tastypie

* LJWorld Marketplace: LJWorld Marketplace<2>.
* Forkinit: Forkinit<2>.
* Read The Docs: Read The Docs<2>.
* Luzme: Luzme<2>.
* Politifact: Politifact<2>.
* Crate: Crate<2>.
* LocalWiki: LocalWiki<2>.
* I-Am-CC.org: I-Am-CC org<2>.

Contributing

* Philosophy: Philosophy<2>.
* Guidelines For Reporting An Issue/Feature: Guidelines For Reporting An Issue/Feature<2>.
* Guidelines For Contributing Code: Guidelines For Contributing Code<2>.
* Guidelines For Core Contributors: Guidelines For Core Contributors<2>.


File: django-tastypie.info,  Node: Welcome to Tastypie!,  Next: Getting Help,  Prev: Top,  Up: Top

1 Welcome to Tastypie!
**********************

Tastypie is an webservice API framework for Django. It provides a
convenient, yet powerful and highly customizable, abstraction for
creating REST-style interfaces.

* Menu:

* Getting Started with Tastypie::
* Interacting With The API::
* Tastypie Settings::
* Using Tastypie With Non-ORM Data Sources::
* Tools::
* Testing::
* Compatibility Notes::
* Resources::
* Bundles::
* Api::
* Resource Fields::
* Caching::
* Validation::
* Authentication / Authorization::
* Serialization::
* Throttling::
* Paginator::
* GeoDjango::
* ContentTypes and GenericForeignKeys::
* Tastypie Cookbook::
* Debugging Tastypie::
* Sites Using Tastypie::
* Contributing::

Getting Started with Tastypie

* Installation::
* Configuration::
* Creating Resources::
* Hooking Up The Resource(s): Hooking Up The Resource s.
* Creating More Resources::
* Adding To The Api::
* Limiting Data And Access::
* Beyond The Basics::

Interacting With The API

* Front Matter::
* Fetching Data::
* Sending Data::
* Deleting Data::
* Bulk Operations::
* You Did It!::

Fetching Data

* Api-Wide::
* Inspecting The Resource's Schema::
* Getting A Collection Of Resources::
* Getting A Detail Resource::
* Selecting A Subset Of Resources::

Sending Data

* Creating A New Resource (POST): Creating A New Resource POST.
* Updating An Existing Resource (PUT): Updating An Existing Resource PUT.
* Partially Updating An Existing Resource (PATCH): Partially Updating An Existing Resource PATCH.
* Updating A Whole Collection Of Resources (PUT): Updating A Whole Collection Of Resources PUT.

Deleting Data

* Deleting A Single Resource::
* Deleting A Whole Collection Of Resources::

Tastypie Settings

* API_LIMIT_PER_PAGE::
* TASTYPIE_FULL_DEBUG::
* TASTYPIE_CANNED_ERROR::
* TASTYPIE_ALLOW_MISSING_SLASH::
* TASTYPIE_DATETIME_FORMATTING::

Using Tastypie With Non-ORM Data Sources

* Approach::
* Using Riak for MessageResource::

Tools

* Browser::
* Extensions::
* Python::
* Javascript::

Browser

* JSONView::

Extensions

* Tastypie-msgpack::

Python

* Slumber::
* drest::
* json.tool: json tool.

Javascript

* backbone-tastypie::
* backbone-relational::

Testing

* Example Usage::

Example Usage

* ResourceTestCase API Reference::
* TestApiClient API Reference::

ResourceTestCase API Reference

* get_credentials::
* create_basic::
* create_apikey::
* create_digest::
* create_oauth::
* assertHttpOK::
* assertHttpCreated::
* assertHttpAccepted::
* assertHttpMultipleChoices::
* assertHttpSeeOther::
* assertHttpNotModified::
* assertHttpBadRequest::
* assertHttpUnauthorized::
* assertHttpForbidden::
* assertHttpNotFound::
* assertHttpMethodNotAllowed::
* assertHttpConflict::
* assertHttpGone::
* assertHttpTooManyRequests::
* assertHttpApplicationError::
* assertHttpNotImplemented::
* assertValidJSON::
* assertValidXML::
* assertValidYAML::
* assertValidPlist::
* assertValidJSONResponse::
* assertValidXMLResponse::
* assertValidYAMLResponse::
* assertValidPlistResponse::
* deserialize::
* serialize::
* assertKeys::

TestApiClient API Reference

* __init__::
* get_content_type::
* get::
* post::
* put::
* patch::
* delete::

Compatibility Notes

* ApiKey Database Index::

Resources

* Quick Start::
* Why Class-Based?::
* Why Resource vs. ModelResource?: Why Resource vs ModelResource?.
* Flow Through The Request/Response Cycle::
* Why Resource URIs?::
* Advanced Data Preparation::
* Reverse "Relationships"::
* Resource Options (AKA Meta): Resource Options AKA Meta.
* Basic Filtering::
* Advanced Filtering::
* Using PUT/DELETE/PATCH In Unsupported Places::
* Resource Methods::
* ModelResource Methods::

Advanced Data Preparation

* The Dehydrate Cycle::
* The Hydrate Cycle::

The Dehydrate Cycle

* Per-field dehydrate::
* dehydrate_FOO::
* dehydrate::

The Hydrate Cycle

* hydrate::
* hydrate_FOO::
* Per-field hydrate::

Resource Options (AKA Meta)

* serializer::
* authentication::
* authorization::
* validation::
* paginator_class::
* cache::
* throttle::
* allowed_methods::
* list_allowed_methods::
* detail_allowed_methods::
* limit::
* max_limit::
* api_name::
* resource_name::
* default_format::
* filtering::
* ordering::
* object_class::
* queryset::
* fields::
* excludes::
* include_resource_uri::
* include_absolute_url::
* always_return_data::
* collection_name::
* detail_uri_name::

Resource Methods

* wrap_view::
* base_urls::
* override_urls::
* prepend_urls::
* urls::
* determine_format::
* serialize: serialize<2>.
* deserialize: deserialize<2>.
* alter_list_data_to_serialize::
* alter_detail_data_to_serialize::
* alter_deserialized_list_data::
* alter_deserialized_detail_data::
* dispatch_list::
* dispatch_detail::
* dispatch::
* remove_api_resource_names::
* method_check::
* is_authorized::
* is_authenticated::
* throttle_check::
* log_throttled_access::
* build_bundle::
* build_filters::
* apply_sorting::
* get_bundle_detail_data::
* get_resource_uri::
* resource_uri_kwargs::
* detail_uri_kwargs::
* get_via_uri::
* full_dehydrate::
* dehydrate: dehydrate<2>.
* full_hydrate::
* hydrate: hydrate<2>.
* hydrate_m2m::
* build_schema::
* dehydrate_resource_uri::
* generate_cache_key::
* get_object_list::
* apply_authorization_limits::
* can_create::
* can_update::
* can_delete::
* apply_filters::
* obj_get_list::
* cached_obj_get_list::
* obj_get::
* cached_obj_get::
* obj_create::
* lookup_kwargs_with_identifiers::
* obj_update::
* obj_delete_list::
* obj_delete::
* create_response::
* is_valid::
* rollback::
* get_list::
* get_detail::
* put_list::
* put_detail::
* post_list::
* post_detail::
* delete_list::
* delete_detail::
* patch_list::
* patch_detail::
* get_schema::
* get_multiple::

ModelResource Methods

* should_skip_field::
* api_field_from_django_field::
* get_fields::
* check_filtering::
* build_filters: build_filters<2>.
* apply_sorting: apply_sorting<2>.
* apply_filters: apply_filters<2>.
* get_object_list: get_object_list<2>.
* obj_get_list: obj_get_list<2>.
* obj_get: obj_get<2>.
* obj_create: obj_create<2>.
* obj_update: obj_update<2>.
* obj_delete_list: obj_delete_list<2>.
* obj_delete: obj_delete<2>.
* rollback: rollback<2>.
* save_related::
* save_m2m::
* get_resource_uri: get_resource_uri<2>.

Bundles

* What Are Bundles?::
* Attributes::

Attributes

* obj::
* data::
* request::
* related_obj::
* related_name::

Api

* Quick Start: Quick Start<2>.
* Api Methods::

Api Methods

* register::
* unregister::
* canonical_resource_for::
* urls: urls<2>.
* top_level::

canonical_resource_for

* override_urls: override_urls<2>.
* prepend_urls: prepend_urls<2>.

Resource Fields

* Quick Start: Quick Start<3>.
* Standard Data Fields::
* Relationship Fields::

Standard Data Fields

* Common Field Options::
* Field Types::
* BooleanField::
* CharField::
* DateField::
* DateTimeField::
* DecimalField::
* DictField::
* FileField::
* FloatField::
* IntegerField::
* ListField::
* TimeField::

Common Field Options

* attribute::
* default::
* null::
* blank::
* readonly::
* unique::
* help_text::

Relationship Fields

* Common Field Options: Common Field Options<2>.
* Field Types: Field Types<2>.

Common Field Options

* to::
* full::
* related_name: related_name<2>.

Field Types

* ToOneField::
* OneToOneField::
* ForeignKey::
* ToManyField::
* ManyToManyField::
* OneToManyField::

Caching

* Usage::
* Caching Options::
* Implementing Your Own Cache::
* HTTP Cache-Control::
* HTTP Vary::

Caching Options

* NoCache::
* SimpleCache::

Validation

* Usage: Usage<2>.
* Validation Options::
* Implementing Your Own Validation::

Validation Options

* Validation: Validation<2>.
* FormValidation::
* CleanedDataFormValidation::

Authentication / Authorization

* Usage: Usage<3>.
* Authentication Options::
* Authorization Options::
* Implementing Your Own Authentication/Authorization::

Authentication Options

* Authentication::
* BasicAuthentication::
* ApiKeyAuthentication::
* SessionAuthentication::
* DigestAuthentication::
* OAuthAuthentication::
* MultiAuthentication::

Authorization Options

* Authorization::
* ReadOnlyAuthorization::
* DjangoAuthorization::

Serialization

* Usage: Usage<4>.
* Implementing Your Own Serializer::
* Serializer Methods::

Serializer Methods

* get_mime_for_format::
* format_datetime::
* format_date::
* format_time::
* serialize: serialize<3>.
* deserialize: deserialize<3>.
* to_simple::
* to_etree::
* from_etree::
* to_json::
* from_json::
* to_jsonp::
* to_xml::
* from_xml::
* to_yaml::
* from_yaml::
* to_plist::
* from_plist::
* to_html::
* from_html::

Throttling

* Usage: Usage<5>.
* Throttle Options::
* Implementing Your Own Throttle::

Throttle Options

* BaseThrottle::
* CacheThrottle::
* CacheDBThrottle::

Paginator

* Usage: Usage<6>.
* Implementing Your Own Paginator::

GeoDjango

* Usage: Usage<7>.

Usage

* Filtering::

ContentTypes and GenericForeignKeys

* Usage: Usage<8>.

Tastypie Cookbook

* Adding Custom Values::
* Per-Request Alterations To The Queryset::
* Using Your Resource In Regular Views::
* Using Non-PK Data For Your URLs::
* Nested Resources::
* Adding Search Functionality::
* Creating per-user resources::
* camelCase JSON Serialization::
* Pretty-printed JSON Serialization::
* Determining format via URL::
* Adding to the Django Admin::
* Using SessionAuthentication::

Debugging Tastypie

* "I'm getting XML output in my browser but I want JSON output!"::
* "What's the format for a POST or PUT?"::
* "Why is my syncdb with superuser failing with a DatabaseError?"::

Sites Using Tastypie

* LJWorld Marketplace::
* Forkinit::
* Read The Docs::
* Luzme::
* Politifact::
* Crate::
* LocalWiki::
* I-Am-CC.org: I-Am-CC org.

Contributing

* Philosophy::
* Guidelines For Reporting An Issue/Feature::
* Guidelines For Contributing Code::
* Guidelines For Core Contributors::


File: django-tastypie.info,  Node: Getting Started with Tastypie,  Next: Interacting With The API,  Up: Welcome to Tastypie!

1.1 Getting Started with Tastypie
=================================

Tastypie is a reusable app (that is, it relies only on it's own code and
focuses on providing just a REST-style API) and is suitable for
providing an API to any application without having to modify the
sources of that app.

  Not everyone's needs are the same, so Tastypie goes out of its way to
provide plenty of hooks for overriding or extending how it works.

     Note: If you hit a stumbling block, you can join #tastypie on
     irc.freenode.net(1) to get help.

  This tutorial assumes that you have a basic understanding of Django
as well as how proper REST-style APIs ought to work. We will only
explain the portions of the code that are Tastypie-specific in any kind
of depth.

  For example purposes, we'll be adding an API to a simple blog
application.  Here is `myapp/models.py':

    from tastypie.utils.timezone import now
    from django.contrib.auth.models import User
    from django.db import models
    from django.template.defaultfilters import slugify


    class Entry(models.Model):
        user = models.ForeignKey(User)
        pub_date = models.DateTimeField(default=now)
        title = models.CharField(max_length=200)
        slug = models.SlugField()
        body = models.TextField()

        def __unicode__(self):
            return self.title

        def save(self, *args, **kwargs):
            # For automatic slug generation.
            if not self.slug:
                self.slug = slugify(self.title)[:50]

            return super(Entry, self).save(*args, **kwargs)

With that, we'll move on to installing and configuring Tastypie.

* Menu:

* Installation::
* Configuration::
* Creating Resources::
* Hooking Up The Resource(s): Hooking Up The Resource s.
* Creating More Resources::
* Adding To The Api::
* Limiting Data And Access::
* Beyond The Basics::

  ---------- Footnotes ----------

  (1) irc://irc.freenode.net/tastypie


File: django-tastypie.info,  Node: Installation,  Next: Configuration,  Up: Getting Started with Tastypie

1.1.1 Installation
------------------

Installing Tastypie is as simple as checking out the source and adding
it to your project or `PYTHONPATH'.

       1. Download the dependencies:

             * Python 2.4+

             * Django 1.0+ (tested on Django 1.1+)

             * `mimeparse' 0.1.3+
               (<http://code.google.com/p/mimeparse/>)

                  * Older versions will work, but their behavior on
                    JSON/JSONP is a touch wonky.

             * `dateutil' (<http://labix.org/python-dateutil>)

             * *OPTIONAL* - `lxml' (<http://lxml.de/>) if using the XML
               serializer

             * *OPTIONAL* - `pyyaml' (<http://pyyaml.org/>) if using
               the YAML serializer

             * *OPTIONAL* - `uuid' (present in 2.5+, downloadable from
               <http://pypi.python.org/pypi/uuid/>) if using the
               `ApiKey' authentication

       2. Either check out tastypie from GitHub(1) or to pull a release
          off PyPI(2).  Doing `sudo pip install django-tastypie' or
          `sudo easy_install django-tastypie' is all that should be
          required.

       3. Either symlink the `tastypie' directory into your project or
          copy the directory in. What ever works best for you.

     Note: Once tastypie reaches version 1.0, it will become officially
     available on PyPI(3). Once that is the case, a `sudo pip install
     tastypie' or `sudo easy_install tastypie' should be available.

  ---------- Footnotes ----------

  (1) http://github.com/toastdriven/django-tastypie

  (2) http://pypi.python.org/

  (3) http://pypi.python.org/


File: django-tastypie.info,  Node: Configuration,  Next: Creating Resources,  Prev: Installation,  Up: Getting Started with Tastypie

1.1.2 Configuration
-------------------

The only mandatory configuration is adding `'tastypie'' to your
`INSTALLED_APPS'. This isn't strictly necessary, as Tastypie has only
two non-required models, but may ease usage.

  You have the option to set up a number of settings (see *note
Tastypie Settings: b.) but they all have sane defaults and are not
required unless you need to tweak their values.


File: django-tastypie.info,  Node: Creating Resources,  Next: Hooking Up The Resource s,  Prev: Configuration,  Up: Getting Started with Tastypie

1.1.3 Creating Resources
------------------------

REST-style architecture talks about resources, so unsurprisingly
integrating with Tastypie involves creating `Resource' classes.  For
our simple application, we'll create a file for these in `myapp/api.py',
though they can live anywhere in your application:

    # myapp/api.py
    from tastypie.resources import ModelResource
    from myapp.models import Entry


    class EntryResource(ModelResource):
        class Meta:
            queryset = Entry.objects.all()
            resource_name = 'entry'

This class, by virtue of being a `ModelResource' subclass, will
introspect all non-relational fields on the `Entry' model and create
it's own *note ApiFields: 0. that map to those fields, much like the
way Django's `ModelForm' class introspects.

     Note: The `resource_name' within the `Meta' class is optional. If
     not provided, it is automatically generated off the classname,
     removing any instances of `Resource' and lowercasing the string.
     So `EntryResource' would become just `entry'.

     We've included the `resource_name' attribute in this example for
     clarity, especially when looking at the URLs, but you should feel
     free to omit it if you're comfortable with the automatic behavior.


File: django-tastypie.info,  Node: Hooking Up The Resource s,  Next: Creating More Resources,  Prev: Creating Resources,  Up: Getting Started with Tastypie

1.1.4 Hooking Up The Resource(s)
--------------------------------

Now that we have our `EntryResource', we can hook it up in our URLconf.
To do this, we simply instantiate the resource in our URLconf and hook
up its `urls':

    # urls.py
    from django.conf.urls.defaults import *
    from myapp.api import EntryResource

    entry_resource = EntryResource()

    urlpatterns = patterns('',
        # The normal jazz here...
        (r'^blog/', include('myapp.urls')),
        (r'^api/', include(entry_resource.urls)),
    )

Now it's just a matter of firing up server (`./manage.py runserver') and
going to <http://127.0.0.1:8000/api/entry/?format=json>. You should get
back a list of `Entry'-like objects.

     Note: The `?format=json' is an override required to make things
     look decent in the browser (accept headers vary between browsers).
     Tastypie properly handles the `Accept' header. So the following
     will work properly:

         curl -H "Accept: application/json" http://127.0.0.1:8000/api/entry/

     But if you're sure you want something else (or want to test in a
     browser), Tastypie lets you specify `?format=...' when you really
     want to force a certain type.

  At this point, a bunch of other URLs are also available. Try out
any/all of the following (assuming you have at least three records in
the database):

        * <http://127.0.0.1:8000/api/entry/?format=json>

        * <http://127.0.0.1:8000/api/entry/1/?format=json>

        * <http://127.0.0.1:8000/api/entry/schema/?format=json>

        * <http://127.0.0.1:8000/api/entry/set/1;3/?format=json>

  However, if you try sending a POST/PUT/DELETE to the resource, you
find yourself getting "401 Unauthorized" errors. For safety, Tastypie
ships with the `authorization' class ("what are you allowed to do") set
to `ReadOnlyAuthorization'. This makes it safe to expose on the web,
but prevents us from doing POST/PUT/DELETE. Let's enable those:

    # myapp/api.py
    from tastypie.authorization import Authorization
    from tastypie.resources import ModelResource
    from myapp.models import Entry


    class EntryResource(ModelResource):
        class Meta:
            queryset = Entry.objects.all()
            resource_name = 'entry'
            authorization= Authorization()


     Warning: This is now great for testing in development but *VERY
     INSECURE*. You should never put a `Resource' like this out on the
     internet. Please spend some time looking at the
     authentication/authorization classes available in Tastypie.

  With just nine lines of code, we have a full working REST interface
to our `Entry' model. In addition, full GET/POST/PUT/DELETE support is
already there, so it's possible to really work with all of the data.
Well, _almost_.

  You see, you'll note that not quite all of our data is there.
Markedly absent is the `user' field, which is a `ForeignKey' to
Django's `User' model.  Tastypie does *NOT* introspect related data
because it has no way to know how you want to represent that data.

  And since that relation isn't there, any attempt to POST/PUT new data
will fail, because no `user' is present, which is a required field on
the model.

  This is easy to fix, but we'll need to flesh out our API a little
more.


File: django-tastypie.info,  Node: Creating More Resources,  Next: Adding To The Api,  Prev: Hooking Up The Resource s,  Up: Getting Started with Tastypie

1.1.5 Creating More Resources
-----------------------------

In order to handle our `user' relation, we'll need to create a
`UserResource' and tell the `EntryResource' to use it. So we'll modify
`myapp/api.py' to match the following code:

    # myapp/api.py
    from django.contrib.auth.models import User
    from tastypie import fields
    from tastypie.resources import ModelResource
    from myapp.models import Entry


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'user'


    class EntryResource(ModelResource):
        user = fields.ForeignKey(UserResource, 'user')

        class Meta:
            queryset = Entry.objects.all()
            resource_name = 'entry'

We simply created a new `ModelResource' subclass called `UserResource'.
Then we added a field to `EntryResource' that specified that the `user'
field points to a `UserResource' for that data.

  Now we should be able to get all of the fields back in our response.
But since we have another full, working resource on our hands, we
should hook that up to our API as well. And there's a better way to do
it.


File: django-tastypie.info,  Node: Adding To The Api,  Next: Limiting Data And Access,  Prev: Creating More Resources,  Up: Getting Started with Tastypie

1.1.6 Adding To The Api
-----------------------

Tastypie ships with an `Api' class, which lets you bind multiple
`Resources' together to form a coherent API. Adding it to the mix is
simple.

  We'll go back to our URLconf (`urls.py') and change it to match the
following:

    # urls.py
    from django.conf.urls.defaults import *
    from tastypie.api import Api
    from myapp.api import EntryResource, UserResource

    v1_api = Api(api_name='v1')
    v1_api.register(UserResource())
    v1_api.register(EntryResource())

    urlpatterns = patterns('',
        # The normal jazz here...
        (r'^blog/', include('myapp.urls')),
        (r'^api/', include(v1_api.urls)),
    )

Note that we're now creating an `Api' instance, registering our
`EntryResource' and `UserResource' instances with it and that we've
modified the urls to now point to `v1_api.urls'.

  This makes even more data accessible, so if we start up the
`runserver' again, the following URLs should work:

        * <http://127.0.0.1:8000/api/v1/?format=json>

        * <http://127.0.0.1:8000/api/v1/user/?format=json>

        * <http://127.0.0.1:8000/api/v1/user/1/?format=json>

        * <http://127.0.0.1:8000/api/v1/user/schema/?format=json>

        * <http://127.0.0.1:8000/api/v1/user/set/1;3/?format=json>

        * <http://127.0.0.1:8000/api/v1/entry/?format=json>

        * <http://127.0.0.1:8000/api/v1/entry/1/?format=json>

        * <http://127.0.0.1:8000/api/v1/entry/schema/?format=json>

        * <http://127.0.0.1:8000/api/v1/entry/set/1;3/?format=json>

  Additionally, the representations out of `EntryResource' will now
include the `user' field and point to an endpoint like
`/api/v1/users/1/' to access that user's data. And full POST/PUT delete
support should now work.

  But there's several new problems. One is that our new `UserResource'
leaks too much data, including fields like `email', `password',
`is_active' and `is_staff'. Another is that we may not want to allow
end users to alter `User' data. Both of these problems are easily fixed
as well.


File: django-tastypie.info,  Node: Limiting Data And Access,  Next: Beyond The Basics,  Prev: Adding To The Api,  Up: Getting Started with Tastypie

1.1.7 Limiting Data And Access
------------------------------

Cutting out the `email', `password', `is_active' and `is_staff' fields
is easy to do. We simply modify our `UserResource' code to match the
following:

    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'user'
            excludes = ['email', 'password', 'is_active', 'is_staff', 'is_superuser']

The `excludes' directive tells `UserResource' which fields not to
include in the output. If you'd rather whitelist fields, you could do:

    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'user'
            fields = ['username', 'first_name', 'last_name', 'last_login']

Now that the undesirable fields are no longer included, we can look at
limiting access. This is also easy and involves making our
`UserResource' look like:

    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'user'
            excludes = ['email', 'password', 'is_active', 'is_staff', 'is_superuser']
            allowed_methods = ['get']

Now only HTTP GET requests will be allowed on `/api/v1/user/'
endpoints. If you require more granular control, both
`list_allowed_methods' and `detail_allowed_methods' options are
supported.


File: django-tastypie.info,  Node: Beyond The Basics,  Prev: Limiting Data And Access,  Up: Getting Started with Tastypie

1.1.8 Beyond The Basics
-----------------------

We now have a full working API for our application. But Tastypie
supports many more features, like:

        * *note Authentication / Authorization: 12.

        * *note Caching: 13.

        * *note Throttling: 14.

        * *note Resources: 15. (filtering & sorting)

        * *note Serialization: 16.

  Tastypie is also very easy to override and extend. For some common
patterns and approaches, you should refer to the *note Tastypie
Cookbook: 17. documentation.


File: django-tastypie.info,  Node: Interacting With The API,  Next: Tastypie Settings,  Prev: Getting Started with Tastypie,  Up: Welcome to Tastypie!

1.2 Interacting With The API
============================

Now that you've got a shiny new REST-style API in place, let's
demonstrate how to interact with it. We'll assume that you have cURL(1)
installed on your system (generally available on most modern Mac &
Linux machines), but any tool that allows you to control headers &
bodies on requests will do.

  We'll assume that we're interacting with the following Tastypie code:

    # myapp/api/resources.py
    from django.contrib.auth.models import User
    from tastypie.authorization import Authorization
    from tastypie import fields
    from tastypie.resources import ModelResource, ALL, ALL_WITH_RELATIONS
    from myapp.models import Entry


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'user'
            excludes = ['email', 'password', 'is_active', 'is_staff', 'is_superuser']
            filtering = {
                'username': ALL,
            }


    class EntryResource(ModelResource):
        user = fields.ForeignKey(UserResource, 'user')

        class Meta:
            queryset = Entry.objects.all()
            resource_name = 'entry'
            authorization = Authorization()
            filtering = {
                'user': ALL_WITH_RELATIONS,
                'pub_date': ['exact', 'lt', 'lte', 'gte', 'gt'],
            }


    # urls.py
    from django.conf.urls.defaults import *
    from tastypie.api import Api
    from myapp.api.resources import EntryResource, UserResource

    v1_api = Api(api_name='v1')
    v1_api.register(UserResource())
    v1_api.register(EntryResource())

    urlpatterns = patterns('',
        # The normal jazz here...
        (r'^blog/', include('myapp.urls')),
        (r'^api/', include(v1_api.urls)),
    )

Let's fire up a shell & start exploring the API!

* Menu:

* Front Matter::
* Fetching Data::
* Sending Data::
* Deleting Data::
* Bulk Operations::
* You Did It!::

  ---------- Footnotes ----------

  (1) http://curl.haxx.se/


File: django-tastypie.info,  Node: Front Matter,  Next: Fetching Data,  Up: Interacting With The API

1.2.1 Front Matter
------------------

Tastypie tries to treat all clients & all serialization types as
equally as possible. It also tries to be a good 'Net citizen & respects
the HTTP method used as well as the `Accepts' headers sent. Between
these two, you control all interactions with Tastypie through
relatively few endpoints.

     Warning: Should you try these URLs in your browser, be warned you
     *WILL* need to append `?format=json' (or `xml' or `yaml') to the
     URL. Your browser requests `application/xml' before
     `application/json', so you'll always get back XML if you don't
     specify it.

     That's also why it's recommended that you explore via curl,
     because you avoid your browser's opinionated requests & get
     something closer to what any programmatic clients will get.


File: django-tastypie.info,  Node: Fetching Data,  Next: Sending Data,  Prev: Front Matter,  Up: Interacting With The API

1.2.2 Fetching Data
-------------------

Since reading data out of an API is a very common activity (and the
easiest type of request to make), we'll start there. Tastypie tries to
expose various parts of the API & interlink things within the API
(HATEOAS).

* Menu:

* Api-Wide::
* Inspecting The Resource's Schema::
* Getting A Collection Of Resources::
* Getting A Detail Resource::
* Selecting A Subset Of Resources::


File: django-tastypie.info,  Node: Api-Wide,  Next: Inspecting The Resource's Schema,  Up: Fetching Data

1.2.2.1 Api-Wide
................

We'll start at the highest level:

    curl http://localhost:8000/api/v1/

You'll get back something like:

    {
        "entry": {
            "list_endpoint": "/api/v1/entry/",
            "schema": "/api/v1/entry/schema/"
        },
        "user": {
            "list_endpoint": "/api/v1/user/",
            "schema": "/api/v1/user/schema/"
        }
    }

This lists out all the different `Resource' classes you registered in
your URLconf with the API. Each one is listed by the `resource_name'
you gave it and provides the `list_endpoint' & the `schema' for the
resource.

  Note that these links try to direct you to other parts of the API, to
make exploration/discovery easier. We'll use these URLs in the next
several sections.

  To demonstrate another format, you could run the following to get the
XML variant of the same information:

    curl -H "Accept: application/xml" http://localhost:8000/api/v1/

To which you'd receive:

    <?xml version="1.0" encoding="utf-8"?>
    <response>
      <entry type="hash">
        <list_endpoint>/api/v1/entry/</list_endpoint>
        <schema>/api/v1/entry/schema/</schema>
      </entry>
      <user type="hash">
        <list_endpoint>/api/v1/user/</list_endpoint>
        <schema>/api/v1/user/schema/</schema>
      </user>
    </response>

We'll stick to JSON for the rest of this document, but using XML should
be OK to do at any time.


File: django-tastypie.info,  Node: Inspecting The Resource's Schema,  Next: Getting A Collection Of Resources,  Prev: Api-Wide,  Up: Fetching Data

1.2.2.2 Inspecting The Resource's Schema
........................................

Since the api-wide view gave us a `schema' URL, let's inspect that next.
We'll use the `entry' resource. Again, a simple GET request by curl:

    curl http://localhost:8000/api/v1/entry/schema/

This time, we get back a lot more data:

    {
        "default_format": "application/json",
        "fields": {
            "body": {
                "help_text": "Unicode string data. Ex: \"Hello World\"",
                "nullable": false,
                "readonly": false,
                "type": "string"
            },
            "id": {
                "help_text": "Unicode string data. Ex: \"Hello World\"",
                "nullable": false,
                "readonly": false,
                "type": "string"
            },
            "pub_date": {
                "help_text": "A date & time as a string. Ex: \"2010-11-10T03:07:43\"",
                "nullable": false,
                "readonly": false,
                "type": "datetime"
            },
            "resource_uri": {
                "help_text": "Unicode string data. Ex: \"Hello World\"",
                "nullable": false,
                "readonly": true,
                "type": "string"
            },
            "slug": {
                "help_text": "Unicode string data. Ex: \"Hello World\"",
                "nullable": false,
                "readonly": false,
                "type": "string"
            },
            "title": {
                "help_text": "Unicode string data. Ex: \"Hello World\"",
                "nullable": false,
                "readonly": false,
                "type": "string"
            },
            "user": {
                "help_text": "A single related resource. Can be either a URI or set of nested resource data.",
                "nullable": false,
                "readonly": false,
                "type": "related"
            }
        },
        "filtering": {
            "pub_date": ["exact", "lt", "lte", "gte", "gt"],
            "user": 2
        }
    }

This lists out the `default_format' this resource responds with, the
`fields' on the resource & the `filtering' options available. This
information can be used to prepare the other aspects of the code for the
data it can obtain & ways to filter the resources.


File: django-tastypie.info,  Node: Getting A Collection Of Resources,  Next: Getting A Detail Resource,  Prev: Inspecting The Resource's Schema,  Up: Fetching Data

1.2.2.3 Getting A Collection Of Resources
.........................................

Let's get down to fetching live data. From the api-wide view, we'll hit
the `list_endpoint' for `entry':

    curl http://localhost:8000/api/v1/entry/

We get back data that looks like:

    {
        "meta": {
            "limit": 20,
            "next": null,
            "offset": 0,
            "previous": null,
            "total_count": 3
        },
        "objects": [{
            "body": "Welcome to my blog!",
            "id": "1",
            "pub_date": "2011-05-20T00:46:38",
            "resource_uri": "/api/v1/entry/1/",
            "slug": "first-post",
            "title": "First Post",
            "user": "/api/v1/user/1/"
        },
        {
            "body": "Well, it's been awhile and I still haven't updated. ",
            "id": "2",
            "pub_date": "2011-05-21T00:46:58",
            "resource_uri": "/api/v1/entry/2/",
            "slug": "second-post",
            "title": "Second Post",
            "user": "/api/v1/user/1/"
        },
        {
            "body": "I'm really excited to get started with this new blog. It's gonna be great!",
            "id": "3",
            "pub_date": "2011-05-20T00:47:30",
            "resource_uri": "/api/v1/entry/3/",
            "slug": "my-blog",
            "title": "My Blog",
            "user": "/api/v1/user/2/"
        }]
    }

Some things to note:

        * By default, you get a paginated set of objects (20 per page
          is the default).

        * In the `meta', you get a `previous' & `next'. If available,
          these are URIs to the previous & next pages.

        * You get a list of resources/objects under the `objects' key.

        * Each resources/object has a `resource_uri' field that points
          to the detail view for that object.

        * The foreign key to `User' is represented as a URI by default.
          If you're looking for the full `UserResource' to be embedded
          in this view, you'll need to add `full=True' to the
          `fields.ToOneField'.

  If you want to skip paginating, simply run:

    curl http://localhost:8000/api/v1/entry/?limit=0

Be warned this will return all objects, so it may be a CPU/IO-heavy
operation on large datasets.

  Let's try filtering on the resource. Since we know we can filter on
the `user', we'll fetch all posts by the `daniel' user with:

    curl http://localhost:8000/api/v1/entry/?user__username=daniel

We get back what we asked for:

    {
        "meta": {
            "limit": 20,
            "next": null,
            "offset": 0,
            "previous": null,
            "total_count": 2
        },
        "objects": [{
            "body": "Welcome to my blog!",
            "id": "1",
            "pub_date": "2011-05-20T00:46:38",
            "resource_uri": "/api/v1/entry/1/",
            "slug": "first-post",
            "title": "First Post",
            "user": "/api/v1/user/1/"
        },
        {
            "body": "Well, it's been awhile and I still haven't updated. ",
            "id": "2",
            "pub_date": "2011-05-21T00:46:58",
            "resource_uri": "/api/v1/entry/2/",
            "slug": "second-post",
            "title": "Second Post",
            "user": "/api/v1/user/1/"
        }]
    }

Where there were three posts before, now there are only two.


File: django-tastypie.info,  Node: Getting A Detail Resource,  Next: Selecting A Subset Of Resources,  Prev: Getting A Collection Of Resources,  Up: Fetching Data

1.2.2.4 Getting A Detail Resource
.................................

Since each resource/object in the list view had a `resource_uri', let's
explore what's there:

    curl http://localhost:8000/api/v1/entry/1/

We get back a similar set of data that we received from the list view:

    {
        "body": "Welcome to my blog!",
        "id": "1",
        "pub_date": "2011-05-20T00:46:38",
        "resource_uri": "/api/v1/entry/1/",
        "slug": "first-post",
        "title": "First Post",
        "user": "/api/v1/user/1/"
    }

Where this proves useful (for example) is present in the data we got
back. We know the URI of the `User' associated with this blog entry.
Let's run:

    curl http://localhost:8000/api/v1/user/1/

Without ever seeing any aspect of the `UserResource' & just following
the URI given, we get back:

    {
        "date_joined": "2011-05-20T00:42:14.990617",
        "first_name": "",
        "id": "1",
        "last_login": "2011-05-20T00:44:57.510066",
        "last_name": "",
        "resource_uri": "/api/v1/user/1/",
        "username": "daniel"
    }

You can do a similar fetch using the following Javascript/jQuery
(though be wary of same-domain policy):

    $.ajax({
      url: 'http://localhost:8000/api/v1/user/1/',
      type: 'GET',
      accepts: 'application/json',
      dataType: 'json'
    })



File: django-tastypie.info,  Node: Selecting A Subset Of Resources,  Prev: Getting A Detail Resource,  Up: Fetching Data

1.2.2.5 Selecting A Subset Of Resources
.......................................

Sometimes you may want back more than one record, but not an entire
list view nor do you want to do multiple requests. Tastypie includes a
"set" view, which lets you cherry-pick the objects you want. For
example, if we just want the first & third `Entry' resources, we'd run:

    curl "http://localhost:8000/api/v1/entry/set/1;3/"


     Note: Quotes are needed in this case because of the semicolon
     delimiter between primary keys. Without the quotes, bash tries to
     split it into two statements.  No extraordinary quoting will be
     necessary in your application (unless your API client is written
     in bash :D).

  And we get back just those two objects:

    {
        "objects": [{
            "body": "Welcome to my blog!",
            "id": "1",
            "pub_date": "2011-05-20T00:46:38",
            "resource_uri": "/api/v1/entry/1/",
            "slug": "first-post",
            "title": "First Post",
            "user": "/api/v1/user/1/"
        },
        {
            "body": "I'm really excited to get started with this new blog. It's gonna be great!",
            "id": "3",
            "pub_date": "2011-05-20T00:47:30",
            "resource_uri": "/api/v1/entry/3/",
            "slug": "my-blog",
            "title": "My Blog",
            "user": "/api/v1/user/2/"
        }]
    }

Note that, like the list view, you get back a list of `objects'. Unlike
the list view, there is *NO* pagination applied to these objects. You
asked for them, you're going to get them all.


File: django-tastypie.info,  Node: Sending Data,  Next: Deleting Data,  Prev: Fetching Data,  Up: Interacting With The API

1.2.3 Sending Data
------------------

Tastypie also gives you full write capabilities in the API. Since the
`EntryResource' has the no-limits `Authentication' & `Authorization' on
it, we can freely write data.

     Warning: Note that this is a huge security hole as well. Don't put
     unauthorized write-enabled resources on the Internet, because
     someone will trash your data.

     This is why `ReadOnlyAuthorization' is the default in Tastypie &
     why you must override to provide more access.

  The good news is that there are no new URLs to learn. The "list" &
"detail" URLs we've been using to fetch data _ALSO_ support the
`POST'/`PUT'/`DELETE' HTTP methods.

* Menu:

* Creating A New Resource (POST): Creating A New Resource POST.
* Updating An Existing Resource (PUT): Updating An Existing Resource PUT.
* Partially Updating An Existing Resource (PATCH): Partially Updating An Existing Resource PATCH.
* Updating A Whole Collection Of Resources (PUT): Updating A Whole Collection Of Resources PUT.


File: django-tastypie.info,  Node: Creating A New Resource POST,  Next: Updating An Existing Resource PUT,  Up: Sending Data

1.2.3.1 Creating A New Resource (POST)
......................................

Let's add a new entry. To create new data, we'll switch from `GET'
requests to the familiar `POST' request.

     Note: Tastypie encourages "round-trippable" data, which means the
     data you can GET should be able to be POST/PUT'd back to recreate
     the same object.

     If you're ever in question about what you should send, do a GET on
     another object & see what Tastypie thinks it should look like.

  To create new resources/objects, you will `POST' to the list endpoint
of a resource. Trying to `POST' to a detail endpoint has a different
meaning in the REST mindset (meaning to add a resource as a child of a
resource of the same type).

  As with all Tastypie requests, the headers we request are important.
Since we've been using primarily JSON throughout, let's send a new
entry in JSON format:

    curl --dump-header - -H "Content-Type: application/json" -X POST --data '{"body": "This will prbbly be my lst post.", "pub_date": "2011-05-22T00:46:38", "slug": "another-post", "title": "Another Post", "user": "/api/v1/user/1/"}' http://localhost:8000/api/v1/entry/

The `Content-Type' header here informs Tastypie that we're sending it
JSON.  We send the data as a JSON-serialized body (*NOT* as form-data
in the form of URL parameters). What we get back is the following
response:

    HTTP/1.0 201 CREATED
    Date: Fri, 20 May 2011 06:48:36 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Type: text/html; charset=utf-8
    Location: http://localhost:8000/api/v1/entry/4/

You'll also note that we get a correct HTTP status code back (201) & a
`Location' header, which gives us the URI to our newly created resource.

  Passing `--dump-header -' is important, because it gives you all the
headers as well as the status code. When things go wrong, this will be
useful information to help with debugging. For instance, if we send a
request without a `user':

    curl --dump-header - -H "Content-Type: application/json" -X POST --data '{"body": "This will prbbly be my lst post.", "pub_date": "2011-05-22T00:46:38", "slug": "another-post", "title": "Another Post"}' http://localhost:8000/api/v1/entry/

We get back:

    HTTP/1.0 400 BAD REQUEST
    Date: Fri, 20 May 2011 06:53:02 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Type: text/html; charset=utf-8

    The 'user' field has no data and doesn't allow a default or null value.

You can do a similar POST using the following Javascript/jQuery (though
be wary of same-domain policy):

    # This may require the ``json2.js`` library for older browsers.
    var data = JSON.stringify({
        "body": "This will prbbly be my lst post.",
        "pub_date": "2011-05-22T00:46:38",
        "slug": "another-post",
        "title": "Another Post"
    });

    $.ajax({
      url: 'http://localhost:8000/api/v1/entry/',
      type: 'POST',
      contentType: 'application/json',
      data: data,
      dataType: 'json',
      processData: false
    })



File: django-tastypie.info,  Node: Updating An Existing Resource PUT,  Next: Partially Updating An Existing Resource PATCH,  Prev: Creating A New Resource POST,  Up: Sending Data

1.2.3.2 Updating An Existing Resource (PUT)
...........................................

You might have noticed that we made some typos when we submitted the
POST request. We can fix this using a `PUT' request to the detail
endpoint (modify this instance of a resource).:

    curl --dump-header - -H "Content-Type: application/json" -X PUT --data '{"body": "This will probably be my last post.", "pub_date": "2011-05-22T00:46:38", "slug": "another-post", "title": "Another Post", "user": "/api/v1/user/1/"}' http://localhost:8000/api/v1/entry/4/

After fixing up the `body', we get back:

    HTTP/1.0 204 NO CONTENT
    Date: Fri, 20 May 2011 07:13:21 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Length: 0
    Content-Type: text/html; charset=utf-8

We get a 204 status code, meaning our update was successful. We don't
get a `Location' header back because we did the `PUT' on a detail URL,
which presumably did not change.

     Note: A `PUT' request requires that the entire resource
     representation be enclosed. Missing fields may cause errors, or be
     filled in by default values.


File: django-tastypie.info,  Node: Partially Updating An Existing Resource PATCH,  Next: Updating A Whole Collection Of Resources PUT,  Prev: Updating An Existing Resource PUT,  Up: Sending Data

1.2.3.3 Partially Updating An Existing Resource (PATCH)
.......................................................

In some cases, you may not want to send the entire resource when
updating. To update just a subset of the fields, we can send a `PATCH'
request to the detail endpoint.:

    curl --dump-header - -H "Content-Type: application/json" -X PATCH --data '{"body": "This actually is my last post."}' http://localhost:8000/api/v1/entry/4/

To which we should get back:

    HTTP/1.0 202 ACCEPTED
    Date: Fri, 20 May 2011 07:13:21 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Length: 0
    Content-Type: text/html; charset=utf-8



File: django-tastypie.info,  Node: Updating A Whole Collection Of Resources PUT,  Prev: Partially Updating An Existing Resource PATCH,  Up: Sending Data

1.2.3.4 Updating A Whole Collection Of Resources (PUT)
......................................................

You can also, in rare circumstances, update an entire collection of
objects.  By sending a `PUT' request to the list view of a resource,
you can replace the entire collection.

     Warning: This deletes all of the objects first, then creates the
     objects afresh. This is done because determining which objects are
     the same is actually difficult to get correct in the general case
     for all people.

  Send a request like:

    curl --dump-header - -H "Content-Type: application/json" -X PUT --data '{"objects": [{"body": "Welcome to my blog!","id": "1","pub_date": "2011-05-20T00:46:38","resource_uri": "/api/v1/entry/1/","slug": "first-post","title": "First Post","user": "/api/v1/user/1/"},{"body": "I'm really excited to get started with this new blog. It's gonna be great!","id": "3","pub_date": "2011-05-20T00:47:30","resource_uri": "/api/v1/entry/3/","slug": "my-blog","title": "My Blog","user": "/api/v1/user/2/"}]}' http://localhost:8000/api/v1/entry/

And you'll get back a response like:

    HTTP/1.0 204 NO CONTENT
    Date: Fri, 20 May 2011 07:13:21 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Length: 0
    Content-Type: text/html; charset=utf-8



File: django-tastypie.info,  Node: Deleting Data,  Next: Bulk Operations,  Prev: Sending Data,  Up: Interacting With The API

1.2.4 Deleting Data
-------------------

No CRUD setup would be complete without the ability to delete
resources/objects.  Deleting also requires significantly less
complicated requests than `POST'/`PUT'.

* Menu:

* Deleting A Single Resource::
* Deleting A Whole Collection Of Resources::


File: django-tastypie.info,  Node: Deleting A Single Resource,  Next: Deleting A Whole Collection Of Resources,  Up: Deleting Data

1.2.4.1 Deleting A Single Resource
..................................

We've decided that we don't like the entry we added & edited earlier.
Let's delete it (but leave the other objects alone):

    curl --dump-header - -H "Content-Type: application/json" -X DELETE  http://localhost:8000/api/v1/entry/4/

Once again, we get back the "Accepted" response of a 204:

    HTTP/1.0 204 NO CONTENT
    Date: Fri, 20 May 2011 07:28:01 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Length: 0
    Content-Type: text/html; charset=utf-8

If we request that resource, we get a 410 to show it's no longer there:

    curl --dump-header - http://localhost:8000/api/v1/entry/4/

    HTTP/1.0 410 GONE
    Date: Fri, 20 May 2011 07:29:02 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Type: text/html; charset=utf-8

Additionally, if we try to run the `DELETE' again (using the same
original command), we get the "Gone" response again:

    HTTP/1.0 410 GONE
    Date: Fri, 20 May 2011 07:30:00 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Type: text/html; charset=utf-8



File: django-tastypie.info,  Node: Deleting A Whole Collection Of Resources,  Prev: Deleting A Single Resource,  Up: Deleting Data

1.2.4.2 Deleting A Whole Collection Of Resources
................................................

Finally, it's possible to remove an entire collection of resources.
This is as destructive as it sounds. Once again, we use the `DELETE'
method, this time on the entire list endpoint:

    curl --dump-header - -H "Content-Type: application/json" -X DELETE  http://localhost:8000/api/v1/entry/

As a response, we get:

    HTTP/1.0 204 NO CONTENT
    Date: Fri, 20 May 2011 07:32:51 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Length: 0
    Content-Type: text/html; charset=utf-8

Hitting the list view:

    curl --dump-header - http://localhost:8000/api/v1/entry/

Gives us a 200 but no objects:

    {
        "meta": {
            "limit": 20,
            "next": null,
            "offset": 0,
            "previous": null,
            "total_count": 0
        },
        "objects": []
    }



File: django-tastypie.info,  Node: Bulk Operations,  Next: You Did It!,  Prev: Deleting Data,  Up: Interacting With The API

1.2.5 Bulk Operations
---------------------

As an optimization, it is possible to do many creations, updates, and
deletions to a collection in a single request by sending a `PATCH' to
the list endpoint.:

    curl --dump-header - -H "Content-Type: application/json" -X PATCH --data '{"objects": [{"body": "Surprise! Another post!.", "pub_date": "2012-02-16T00:46:38", "slug": "yet-another-post", "title": "Yet Another Post"}], "deleted_objects": ["http://localhost:8000/api/v1/entry/4/"]}'  http://localhost:8000/api/v1/entry/

We should get back:

    HTTP/1.0 202 ACCEPTED
    Date: Fri, 16 Feb 2012 00:46:38 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Length: 0
    Content-Type: text/html; charset=utf-8

The Accepted response means the server has accepted the request, but
gives no details on the result. In order to see any created resources,
we would need to do a get `GET' on the list endpoint.

  For detailed information on the format of a bulk request, see *note
patch_list: 2c.


File: django-tastypie.info,  Node: You Did It!,  Prev: Bulk Operations,  Up: Interacting With The API

1.2.6 You Did It!
-----------------

That's a whirlwind tour of interacting with a Tastypie API. There's
additional functionality present, such as:

   * `POST'/`PUT' the other supported content-types

   * More filtering/`order_by'/`limit'/`offset' tricks

   * Using overridden URLconfs to support complex or non-PK lookups

   * Authentication

  But this grounds you in the basics & hopefully clarifies
usage/debugging better.


File: django-tastypie.info,  Node: Tastypie Settings,  Next: Using Tastypie With Non-ORM Data Sources,  Prev: Interacting With The API,  Up: Welcome to Tastypie!

1.3 Tastypie Settings
=====================

This is a comprehensive list of the settings Tastypie recognizes.

* Menu:

* API_LIMIT_PER_PAGE::
* TASTYPIE_FULL_DEBUG::
* TASTYPIE_CANNED_ERROR::
* TASTYPIE_ALLOW_MISSING_SLASH::
* TASTYPIE_DATETIME_FORMATTING::


File: django-tastypie.info,  Node: API_LIMIT_PER_PAGE,  Next: TASTYPIE_FULL_DEBUG,  Up: Tastypie Settings

1.3.1 `API_LIMIT_PER_PAGE'
--------------------------

*Optional*

  This setting controls the default number of records Tastypie will show
in a list view.

  This is only used when a user does not specify a `limit' GET
parameter and the `Resource' subclass has not overridden the number to
be shown.

  An example:

    API_LIMIT_PER_PAGE = 50

If you don't want to limit the number of records by default, you can
set this setting to 0:

    API_LIMIT_PER_PAGE = 0

Defaults to 20.


File: django-tastypie.info,  Node: TASTYPIE_FULL_DEBUG,  Next: TASTYPIE_CANNED_ERROR,  Prev: API_LIMIT_PER_PAGE,  Up: Tastypie Settings

1.3.2 `TASTYPIE_FULL_DEBUG'
---------------------------

*Optional*

  This setting controls what the behavior is when an unhandled
exception occurs.

  If set to `True' and `settings.DEBUG = True', the standard Django
technical 500 is displayed.

  If not set or set to `False', Tastypie will return a serialized
response.  If `settings.DEBUG' is `True', you'll get the actual
exception message plus a traceback. If `settings.DEBUG' is `False',
Tastypie will call `mail_admins()' and provide a canned error message
(which you can override with `TASTYPIE_CANNED_ERROR') in the response.

  An example:

    TASTYPIE_FULL_DEBUG = True

Defaults to `False'.


File: django-tastypie.info,  Node: TASTYPIE_CANNED_ERROR,  Next: TASTYPIE_ALLOW_MISSING_SLASH,  Prev: TASTYPIE_FULL_DEBUG,  Up: Tastypie Settings

1.3.3 `TASTYPIE_CANNED_ERROR'
-----------------------------

*Optional*

  This setting allows you to override the canned error response when an
unhandled exception is raised and `settings.DEBUG' is `False'.

  An example:

    TASTYPIE_CANNED_ERROR = "Oops, we broke it!"

Defaults to `"Sorry, this request could not be processed. Please try
again later."'.


File: django-tastypie.info,  Node: TASTYPIE_ALLOW_MISSING_SLASH,  Next: TASTYPIE_DATETIME_FORMATTING,  Prev: TASTYPIE_CANNED_ERROR,  Up: Tastypie Settings

1.3.4 `TASTYPIE_ALLOW_MISSING_SLASH'
------------------------------------

*Optional*

  This setting allows your URLs to be missing the final slash. Useful
for integrating with other systems.

  You must also have `settings.APPEND_SLASH = False' so that Django
does not emit HTTP 302 redirects.

  An example:

    TASTYPIE_ALLOW_MISSING_SLASH = True

Defaults to `False'.


File: django-tastypie.info,  Node: TASTYPIE_DATETIME_FORMATTING,  Prev: TASTYPIE_ALLOW_MISSING_SLASH,  Up: Tastypie Settings

1.3.5 `TASTYPIE_DATETIME_FORMATTING'
------------------------------------

*Optional*

  This setting allows you to globally choose what format your
datetime/date/time data will be formatted in. Valid options are
`iso-8601' & `rfc-2822'.

  An example:

    TASTYPIE_DATETIME_FORMATTING = 'rfc-2822'

Defaults to `iso-8601'.


File: django-tastypie.info,  Node: Using Tastypie With Non-ORM Data Sources,  Next: Tools,  Prev: Tastypie Settings,  Up: Welcome to Tastypie!

1.4 Using Tastypie With Non-ORM Data Sources
============================================

Much of this documentation demonstrates the use of Tastypie with
Django's ORM.  You might think that Tastypie depended on the ORM, when
in fact, it was purpose-built to handle non-ORM data. This
documentation should help you get started providing APIs using other
data sources.

  Virtually all of the code that makes Tastypie actually process
requests & return data is within the `Resource' class. `ModelResource'
is actually a light wrapper around `Resource' that provides
ORM-specific access. The methods that `ModelResource' overrides are the
same ones you'll need to override when hooking up your data source.

* Menu:

* Approach::
* Using Riak for MessageResource::


File: django-tastypie.info,  Node: Approach,  Next: Using Riak for MessageResource,  Up: Using Tastypie With Non-ORM Data Sources

1.4.1 Approach
--------------

When working with `Resource', many things are handled for you. All the
authentication/authorization/caching/serialization/throttling bits
should work as normal and Tastypie can support all the REST-style
methods. Schemas & discovery views all work the same as well.

  What you don't get out of the box are the fields you're choosing to
expose & the lowest level data access methods. If you want a full
read-write API, there are nine methods you need to implement. They are:

   * `detail_uri_kwargs'

   * `get_object_list'

   * `obj_get_list'

   * `obj_get'

   * `obj_create'

   * `obj_update'

   * `obj_delete_list'

   * `obj_delete'

   * `rollback'

  If read-only is all you're exposing, you can cut that down to four
methods to override.


File: django-tastypie.info,  Node: Using Riak for MessageResource,  Prev: Approach,  Up: Using Tastypie With Non-ORM Data Sources

1.4.2 Using Riak for MessageResource
------------------------------------

As an example, we'll take integrating with Riak(1) (a Dynamo-like NoSQL
store) since it has both a simple API and demonstrate what hooking up
to a non-relational datastore looks like:

    # We need a generic object to shove data in/get data from.
    # Riak generally just tosses around dictionaries, so we'll lightly
    # wrap that.
    class RiakObject(object):
        def __init__(self, initial=None):
            self.__dict__['_data'] = {}

            if hasattr(initial, 'items'):
                self.__dict__['_data'] = initial

        def __getattr__(self, name):
            return self._data.get(name, None)

        def __setattr__(self, name, value):
            self.__dict__['_data'][name] = value

        def to_dict(self):
            return self._data


    class MessageResource(Resource):
        # Just like a Django ``Form`` or ``Model``, we're defining all the
        # fields we're going to handle with the API here.
        uuid = fields.CharField(attribute='uuid')
        user_uuid = fields.CharField(attribute='user_uuid')
        message = fields.CharField(attribute='message')
        created = fields.IntegerField(attribute='created')

        class Meta:
            resource_name = 'riak'
            object_class = RiakObject
            authorization = Authorization()

        # Specific to this resource, just to get the needed Riak bits.
        def _client(self):
            return riak.RiakClient()

        def _bucket(self):
            client = self._client()
            # Note that we're hard-coding the bucket to use. Fine for
            # example purposes, but you'll want to abstract this.
            return client.bucket('messages')

        # The following methods will need overriding regardless of your
        # data source.
        def detail_uri_kwargs(self, bundle_or_obj):
            kwargs = {}

            if isinstance(bundle_or_obj, Bundle):
                kwargs['pk'] = bundle_or_obj.obj.uuid
            else:
                kwargs['pk'] = bundle_or_obj.uuid

            return kwargs

        def get_object_list(self, request):
            query = self._client().add('messages')
            query.map("function(v) { var data = JSON.parse(v.values[0].data); return [[v.key, data]]; }")
            results = []

            for result in query.run():
                new_obj = RiakObject(initial=result[1])
                new_obj.uuid = result[0]
                results.append(new_obj)

            return results

        def obj_get_list(self, request=None, **kwargs):
            # Filtering disabled for brevity...
            return self.get_object_list(request)

        def obj_get(self, request=None, **kwargs):
            bucket = self._bucket()
            message = bucket.get(kwargs['pk'])
            return RiakObject(initial=message.get_data())

        def obj_create(self, bundle, request=None, **kwargs):
            bundle.obj = RiakObject(initial=kwargs)
            bundle = self.full_hydrate(bundle)
            bucket = self._bucket()
            new_message = bucket.new(bundle.obj.uuid, data=bundle.obj.to_dict())
            new_message.store()
            return bundle

        def obj_update(self, bundle, request=None, **kwargs):
            return self.obj_create(bundle, request, **kwargs)

        def obj_delete_list(self, request=None, **kwargs):
            bucket = self._bucket()

            for key in bucket.get_keys():
                obj = bucket.get(key)
                obj.delete()

        def obj_delete(self, request=None, **kwargs):
            bucket = self._bucket()
            obj = bucket.get(kwargs['pk'])
            obj.delete()

        def rollback(self, bundles):
            pass

This represents a full, working, Riak-powered API endpoint. All
REST-style actions (GET/POST/PUT/DELETE) all work correctly. The only
shortcut taken in this example was skipping filter-abilty, as adding in
the MapReduce bits would have decreased readability.

  All said and done, just nine methods needed overriding, eight of
which were highly specific to how data access is done.

  ---------- Footnotes ----------

  (1) http://www.basho.com/products_riak_overview.php


File: django-tastypie.info,  Node: Tools,  Next: Testing,  Prev: Using Tastypie With Non-ORM Data Sources,  Up: Welcome to Tastypie!

1.5 Tools
=========

Here are some tools that might help in interacting with the API that
Tastypie provides:

* Menu:

* Browser::
* Extensions::
* Python::
* Javascript::

Browser

* JSONView::

Extensions

* Tastypie-msgpack::

Python

* Slumber::
* drest::
* json.tool: json tool.

Javascript

* backbone-tastypie::
* backbone-relational::


File: django-tastypie.info,  Node: Browser,  Next: Extensions,  Up: Tools

1.5.1 Browser
-------------

* Menu:

* JSONView::


File: django-tastypie.info,  Node: JSONView,  Up: Browser

1.5.1.1 JSONView
................

   * Firefox -
     <https://addons.mozilla.org/en-US/firefox/addon/jsonview/>

   * Chrome -
     <https://chrome.google.com/webstore/detail/chklaanhfefbnpoihckbnefhakgolnmc>

  A plugin (actually two different ones that closely mirror each other)
that nicely reformats JSON data in the browser.


File: django-tastypie.info,  Node: Extensions,  Next: Python,  Prev: Browser,  Up: Tools

1.5.2 Extensions
----------------

* Menu:

* Tastypie-msgpack::


File: django-tastypie.info,  Node: Tastypie-msgpack,  Up: Extensions

1.5.2.1 Tastypie-msgpack
........................

<https://github.com/stephenmcd/tastypie-msgpack>

  Adds MsgPack(1) support to Tastypie's serializer.

  ---------- Footnotes ----------

  (1) http://msgpack.org/


File: django-tastypie.info,  Node: Python,  Next: Javascript,  Prev: Extensions,  Up: Tools

1.5.3 Python
------------

* Menu:

* Slumber::
* drest::
* json.tool: json tool.


File: django-tastypie.info,  Node: Slumber,  Next: drest,  Up: Python

1.5.3.1 Slumber
...............

<http://slumber.in/>

  Slumber is a small Python library that makes it easy to access & work
with APIs. It works for many others, but works especially well with
Tastypie.


File: django-tastypie.info,  Node: drest,  Next: json tool,  Prev: Slumber,  Up: Python

1.5.3.2 drest
.............

<http://drest.rtfd.org/>

  drest is another small Python library. It focuses on extensibility &
can also work with many different API, with an emphasis on Tastypie.


File: django-tastypie.info,  Node: json tool,  Prev: drest,  Up: Python

1.5.3.3 json.tool
.................

Included with Python, this tool makes reformatting JSON easy. For
example:

    $ curl http://localhost:8000/api/v1/note/ | python -m json.tool

Will return nicely reformatted data like:

    {
        "meta": {
            "total_count": 1
        },
        "objects": [
            {
                "content": "Hello world!",
                "user": "/api/v1/user/1/"
            }
        ]
    }



File: django-tastypie.info,  Node: Javascript,  Prev: Python,  Up: Tools

1.5.4 Javascript
----------------

* Menu:

* backbone-tastypie::
* backbone-relational::


File: django-tastypie.info,  Node: backbone-tastypie,  Next: backbone-relational,  Up: Javascript

1.5.4.1 backbone-tastypie
.........................

<https://github.com/PaulUithol/backbone-tastypie>

  A small layer that makes Backbone & Tastypie plan nicely together.


File: django-tastypie.info,  Node: backbone-relational,  Prev: backbone-tastypie,  Up: Javascript

1.5.4.2 backbone-relational
...........................

<https://github.com/PaulUithol/Backbone-relational/>

  Allows Backbone to work with relational data, like the kind of data
Tastypie provides.


File: django-tastypie.info,  Node: Testing,  Next: Compatibility Notes,  Prev: Tools,  Up: Welcome to Tastypie!

1.6 Testing
===========

Having integrated unit tests that cover your API's behavior is
important, as it helps provide verification that your API code is still
valid & working correctly with the rest of your application.

  Tastypie provides some basic facilities that build on top of Django's
testing(1) support, in the form of a specialized `TestApiClient' &
`ResourceTestCase'.

  The `ResourceTestCase' builds on top of Django's `TestCase'. It
provides quite a few extra assertion methods that are specific to APIs.
Under the hood, it uses the `TestApiClient' to perform requests
properly.

  The `TestApiClient' builds on & exposes an interface similar to that
of Django's `Client'. However, under the hood, it hands all the setup
needed to construct a proper request.

* Menu:

* Example Usage::

Example Usage

* ResourceTestCase API Reference::
* TestApiClient API Reference::

ResourceTestCase API Reference

* get_credentials::
* create_basic::
* create_apikey::
* create_digest::
* create_oauth::
* assertHttpOK::
* assertHttpCreated::
* assertHttpAccepted::
* assertHttpMultipleChoices::
* assertHttpSeeOther::
* assertHttpNotModified::
* assertHttpBadRequest::
* assertHttpUnauthorized::
* assertHttpForbidden::
* assertHttpNotFound::
* assertHttpMethodNotAllowed::
* assertHttpConflict::
* assertHttpGone::
* assertHttpTooManyRequests::
* assertHttpApplicationError::
* assertHttpNotImplemented::
* assertValidJSON::
* assertValidXML::
* assertValidYAML::
* assertValidPlist::
* assertValidJSONResponse::
* assertValidXMLResponse::
* assertValidYAMLResponse::
* assertValidPlistResponse::
* deserialize::
* serialize::
* assertKeys::

TestApiClient API Reference

* __init__::
* get_content_type::
* get::
* post::
* put::
* patch::
* delete::

  ---------- Footnotes ----------

  (1) https://docs.djangoproject.com/en/dev/topics/testing/


File: django-tastypie.info,  Node: Example Usage,  Up: Testing

1.6.1 Example Usage
-------------------

The typical use case will primarily consist of subclassing the
`ResourceTestCase' class & using the built-in assertions to ensure your
API is behaving correctly. For the purposes of this example, we'll
assume the resource in question looks like:

    from tastypie.authentication import BasicAuthentication
    from tastypie.resources import ModelResource
    from entries.models import Entry


    class EntryResource(ModelResource):
        class Meta:
            queryset = Entry.objects.all()
            authentication = BasicAuthentication()

An example usage might look like:

    import datetime
    from django.contrib.auth.models import User
    from tastypie.test import ResourceTestCase
    from entries.models import Entry


    class EntryResourceTest(ResourceTestCase):
        # Use ``fixtures`` & ``urls`` as normal. See Django's ``TestCase``
        # documentation for the gory details.
        fixtures = ['test_entries.json']

        def setUp(self):
            super(EntryResourceTest, self).setUp()

            # Create a user.
            self.username = 'daniel'
            self.password = 'pass'
            self.user = User.objects.create_user(self.username, 'daniel@example.com', self.password)

            # Fetch the ``Entry`` object we'll use in testing.
            # Note that we aren't using PKs because they can change depending
            # on what other tests are running.
            self.entry_1 = Entry.objects.get(slug='first-post')

            # We also build a detail URI, since we will be using it all over.
            # DRY, baby. DRY.
            self.detail_url = '/api/v1/entry/{0}/'.format(self.entry_1.pk)

            # The data we'll send on POST requests. Again, because we'll use it
            # frequently (enough).
            self.post_data = {
                'user': '/api/v1/user/{0}/'.format(self.user.pk),
                'title': 'Second Post!',
                'slug': 'second-post',
                'created': '2012-05-01T22:05:12'
            }

        def get_credentials(self):
            return self.create_basic(username=self.username, password=self.password)

        def test_get_list_unauthorzied(self):
            self.assertHttpUnauthorized(self.api_client.get('/api/v1/entries/', format='json'))

        def test_get_list_json(self):
            resp = self.api_client.get('/api/v1/entries/', format='json', authentication=self.get_credentials())
            self.assertValidJSONResponse(resp)

            # Scope out the data for correctness.
            self.assertEqual(len(self.deserialize(resp)['objects']), 12)
            # Here, we're checking an entire structure for the expected data.
            self.assertEqual(self.deserialize(resp)['objects'][0], {
                'pk': str(self.entry_1.pk),
                'user': '/api/v1/user/{0}/'.format(self.user.pk),
                'title': 'First post',
                'slug': 'first-post',
                'created': '2012-05-01T19:13:42',
                'resource_uri': '/api/v1/entry/{0}/'.format(self.entry_1.pk)
            })

        def test_get_list_xml(self):
            self.assertValidXMLResponse(self.api_client.get('/api/v1/entries/', format='xml', authentication=self.get_credentials()))

        def test_get_detail_unauthenticated(self):
            self.assertHttpUnauthorized(self.api_client.get(self.detail_url, format='json'))

        def test_get_detail_json(self):
            resp = self.api_client.get(self.detail_url, format='json', authentication=self.get_credentials())
            self.assertValidJSONResponse(resp)

            # We use ``assertKeys`` here to just verify the keys, not all the data.
            self.assertKeys(self.deserialize(resp), ['created', 'slug', 'title', 'user'])
            self.assertEqual(self.deserialize(resp)['name'], 'First post')

        def test_get_detail_xml(self):
            self.assertValidXMLResponse(self.api_client.get(self.detail_url, format='xml', authentication=self.get_credentials()))

        def test_post_list_unauthenticated(self):
            self.assertHttpUnauthorized(self.api_client.post('/api/v1/entries/', format='json', data=self.post_data))

        def test_post_list(self):
            # Check how many are there first.
            self.assertEqual(Entry.objects.count(), 5)
            self.assertHttpCreated(self.api_client.post('/api/v1/entries/', format='json', data=self.post_data, authentication=self.get_credentials()))
            # Verify a new one has been added.
            self.assertEqual(Entry.objects.count(), 6)

        def test_put_detail_unauthenticated(self):
            self.assertHttpUnauthorized(self.api_client.put(self.detail_url, format='json', data={}))

        def test_put_detail(self):
            # Grab the current data & modify it slightly.
            original_data = self.deserialize(self.api_client.get(self.detail_url, format='json', authentication=self.get_credentials()))
            new_data = original_data.copy()
            new_data['title'] = 'Updated: First Post'
            new_data['created'] = '2012-05-01T20:06:12'

            self.assertEqual(Entry.objects.count(), 5)
            self.assertHttpAccepted(self.api_client.put(self.detail_url, format='json', data=new_data, authentication=self.get_credentials()))
            # Make sure the count hasn't changed & we did an update.
            self.assertEqual(Entry.objects.count(), 5)
            # Check for updated data.
            self.assertEqual(Entry.objects.get(pk=25).title, 'Updated: First Post')
            self.assertEqual(Entry.objects.get(pk=25).slug, 'first-post')
            self.assertEqual(Entry.objects.get(pk=25).created, datetime.datetime(2012, 3, 1, 13, 6, 12))

        def test_delete_detail_unauthenticated(self):
            self.assertHttpUnauthorized(self.api_client.delete(self.detail_url, format='json'))

        def test_delete_detail(self):
            self.assertEqual(Entry.objects.count(), 5)
            self.assertHttpAccepted(self.api_client.delete(self.detail_url, format='json', authentication=self.get_credentials()))
            self.assertEqual(Entry.objects.count(), 4)

Note that this example doesn't cover other cases, such as filtering,
`PUT' to a list endpoint, `DELETE' to a list endpoint, `PATCH' support,
etc.

* Menu:

* ResourceTestCase API Reference::
* TestApiClient API Reference::

ResourceTestCase API Reference

* get_credentials::
* create_basic::
* create_apikey::
* create_digest::
* create_oauth::
* assertHttpOK::
* assertHttpCreated::
* assertHttpAccepted::
* assertHttpMultipleChoices::
* assertHttpSeeOther::
* assertHttpNotModified::
* assertHttpBadRequest::
* assertHttpUnauthorized::
* assertHttpForbidden::
* assertHttpNotFound::
* assertHttpMethodNotAllowed::
* assertHttpConflict::
* assertHttpGone::
* assertHttpTooManyRequests::
* assertHttpApplicationError::
* assertHttpNotImplemented::
* assertValidJSON::
* assertValidXML::
* assertValidYAML::
* assertValidPlist::
* assertValidJSONResponse::
* assertValidXMLResponse::
* assertValidYAMLResponse::
* assertValidPlistResponse::
* deserialize::
* serialize::
* assertKeys::

TestApiClient API Reference

* __init__::
* get_content_type::
* get::
* post::
* put::
* patch::
* delete::


File: django-tastypie.info,  Node: ResourceTestCase API Reference,  Next: TestApiClient API Reference,  Up: Example Usage

1.6.1.1 `ResourceTestCase' API Reference
........................................

The `ResourceTestCase' exposes the following methods for use. Most are
enhanced assertions or provide API-specific behaviors.

* Menu:

* get_credentials::
* create_basic::
* create_apikey::
* create_digest::
* create_oauth::
* assertHttpOK::
* assertHttpCreated::
* assertHttpAccepted::
* assertHttpMultipleChoices::
* assertHttpSeeOther::
* assertHttpNotModified::
* assertHttpBadRequest::
* assertHttpUnauthorized::
* assertHttpForbidden::
* assertHttpNotFound::
* assertHttpMethodNotAllowed::
* assertHttpConflict::
* assertHttpGone::
* assertHttpTooManyRequests::
* assertHttpApplicationError::
* assertHttpNotImplemented::
* assertValidJSON::
* assertValidXML::
* assertValidYAML::
* assertValidPlist::
* assertValidJSONResponse::
* assertValidXMLResponse::
* assertValidYAMLResponse::
* assertValidPlistResponse::
* deserialize::
* serialize::
* assertKeys::


File: django-tastypie.info,  Node: get_credentials,  Next: create_basic,  Up: ResourceTestCase API Reference

1.6.1.2 `get_credentials'
.........................

 -- Method: ResourceTestCase.get_credentials (self)

  A convenience method for the user as a way to shorten up the often
repetitious calls to create the same authentication.

  Raises `NotImplementedError' by default.

  Usage:

    class MyResourceTestCase(ResourceTestCase):
        def get_credentials(self):
            return self.create_basic('daniel', 'pass')

        # Then the usual tests...



File: django-tastypie.info,  Node: create_basic,  Next: create_apikey,  Prev: get_credentials,  Up: ResourceTestCase API Reference

1.6.1.3 `create_basic'
......................

 -- Method: ResourceTestCase.create_basic (self, username, password)

  Creates & returns the HTTP `Authorization' header for use with BASIC
Auth.


File: django-tastypie.info,  Node: create_apikey,  Next: create_digest,  Prev: create_basic,  Up: ResourceTestCase API Reference

1.6.1.4 `create_apikey'
.......................

 -- Method: ResourceTestCase.create_apikey (self, username, api_key)

  Creates & returns the HTTP `Authorization' header for use with
`ApiKeyAuthentication'.


File: django-tastypie.info,  Node: create_digest,  Next: create_oauth,  Prev: create_apikey,  Up: ResourceTestCase API Reference

1.6.1.5 `create_digest'
.......................

 -- Method: ResourceTestCase.create_digest (self, username, api_key,
          method, uri)

  Creates & returns the HTTP `Authorization' header for use with Digest
Auth.


File: django-tastypie.info,  Node: create_oauth,  Next: assertHttpOK,  Prev: create_digest,  Up: ResourceTestCase API Reference

1.6.1.6 `create_oauth'
......................

 -- Method: ResourceTestCase.create_oauth (self, user)

  Creates & returns the HTTP `Authorization' header for use with Oauth.


File: django-tastypie.info,  Node: assertHttpOK,  Next: assertHttpCreated,  Prev: create_oauth,  Up: ResourceTestCase API Reference

1.6.1.7 `assertHttpOK'
......................

 -- Method: ResourceTestCase.assertHttpOK (self, resp)

  Ensures the response is returning a HTTP 200.


File: django-tastypie.info,  Node: assertHttpCreated,  Next: assertHttpAccepted,  Prev: assertHttpOK,  Up: ResourceTestCase API Reference

1.6.1.8 `assertHttpCreated'
...........................

 -- Method: ResourceTestCase.assertHttpCreated (self, resp)

  Ensures the response is returning a HTTP 201.


File: django-tastypie.info,  Node: assertHttpAccepted,  Next: assertHttpMultipleChoices,  Prev: assertHttpCreated,  Up: ResourceTestCase API Reference

1.6.1.9 `assertHttpAccepted'
............................

 -- Method: ResourceTestCase.assertHttpAccepted (self, resp)

  Ensures the response is returning either a HTTP 202 or a HTTP 204.


File: django-tastypie.info,  Node: assertHttpMultipleChoices,  Next: assertHttpSeeOther,  Prev: assertHttpAccepted,  Up: ResourceTestCase API Reference

1.6.1.10 `assertHttpMultipleChoices'
....................................

 -- Method: ResourceTestCase.assertHttpMultipleChoices (self, resp)

  Ensures the response is returning a HTTP 300.


File: django-tastypie.info,  Node: assertHttpSeeOther,  Next: assertHttpNotModified,  Prev: assertHttpMultipleChoices,  Up: ResourceTestCase API Reference

1.6.1.11 `assertHttpSeeOther'
.............................

 -- Method: ResourceTestCase.assertHttpSeeOther (self, resp)

  Ensures the response is returning a HTTP 303.


File: django-tastypie.info,  Node: assertHttpNotModified,  Next: assertHttpBadRequest,  Prev: assertHttpSeeOther,  Up: ResourceTestCase API Reference

1.6.1.12 `assertHttpNotModified'
................................

 -- Method: ResourceTestCase.assertHttpNotModified (self, resp)

  Ensures the response is returning a HTTP 304.


File: django-tastypie.info,  Node: assertHttpBadRequest,  Next: assertHttpUnauthorized,  Prev: assertHttpNotModified,  Up: ResourceTestCase API Reference

1.6.1.13 `assertHttpBadRequest'
...............................

 -- Method: ResourceTestCase.assertHttpBadRequest (self, resp)

  Ensures the response is returning a HTTP 400.


File: django-tastypie.info,  Node: assertHttpUnauthorized,  Next: assertHttpForbidden,  Prev: assertHttpBadRequest,  Up: ResourceTestCase API Reference

1.6.1.14 `assertHttpUnauthorized'
.................................

 -- Method: ResourceTestCase.assertHttpUnauthorized (self, resp)

  Ensures the response is returning a HTTP 401.


File: django-tastypie.info,  Node: assertHttpForbidden,  Next: assertHttpNotFound,  Prev: assertHttpUnauthorized,  Up: ResourceTestCase API Reference

1.6.1.15 `assertHttpForbidden'
..............................

 -- Method: ResourceTestCase.assertHttpForbidden (self, resp)

  Ensures the response is returning a HTTP 403.


File: django-tastypie.info,  Node: assertHttpNotFound,  Next: assertHttpMethodNotAllowed,  Prev: assertHttpForbidden,  Up: ResourceTestCase API Reference

1.6.1.16 `assertHttpNotFound'
.............................

 -- Method: ResourceTestCase.assertHttpNotFound (self, resp)

  Ensures the response is returning a HTTP 404.


File: django-tastypie.info,  Node: assertHttpMethodNotAllowed,  Next: assertHttpConflict,  Prev: assertHttpNotFound,  Up: ResourceTestCase API Reference

1.6.1.17 `assertHttpMethodNotAllowed'
.....................................

 -- Method: ResourceTestCase.assertHttpMethodNotAllowed (self, resp)

  Ensures the response is returning a HTTP 405.


File: django-tastypie.info,  Node: assertHttpConflict,  Next: assertHttpGone,  Prev: assertHttpMethodNotAllowed,  Up: ResourceTestCase API Reference

1.6.1.18 `assertHttpConflict'
.............................

 -- Method: ResourceTestCase.assertHttpConflict (self, resp)

  Ensures the response is returning a HTTP 409.


File: django-tastypie.info,  Node: assertHttpGone,  Next: assertHttpTooManyRequests,  Prev: assertHttpConflict,  Up: ResourceTestCase API Reference

1.6.1.19 `assertHttpGone'
.........................

 -- Method: ResourceTestCase.assertHttpGone (self, resp)

  Ensures the response is returning a HTTP 410.


File: django-tastypie.info,  Node: assertHttpTooManyRequests,  Next: assertHttpApplicationError,  Prev: assertHttpGone,  Up: ResourceTestCase API Reference

1.6.1.20 `assertHttpTooManyRequests'
....................................

 -- Method: ResourceTestCase.assertHttpTooManyRequests (self, resp)

  Ensures the response is returning a HTTP 429.


File: django-tastypie.info,  Node: assertHttpApplicationError,  Next: assertHttpNotImplemented,  Prev: assertHttpTooManyRequests,  Up: ResourceTestCase API Reference

1.6.1.21 `assertHttpApplicationError'
.....................................

 -- Method: ResourceTestCase.assertHttpApplicationError (self, resp)

  Ensures the response is returning a HTTP 500.


File: django-tastypie.info,  Node: assertHttpNotImplemented,  Next: assertValidJSON,  Prev: assertHttpApplicationError,  Up: ResourceTestCase API Reference

1.6.1.22 `assertHttpNotImplemented'
...................................

 -- Method: ResourceTestCase.assertHttpNotImplemented (self, resp)

  Ensures the response is returning a HTTP 501.


File: django-tastypie.info,  Node: assertValidJSON,  Next: assertValidXML,  Prev: assertHttpNotImplemented,  Up: ResourceTestCase API Reference

1.6.1.23 `assertValidJSON'
..........................

 -- Method: ResourceTestCase.assertValidJSON (self, data)

  Given the provided `data' as a string, ensures that it is valid JSON &
can be loaded properly.


File: django-tastypie.info,  Node: assertValidXML,  Next: assertValidYAML,  Prev: assertValidJSON,  Up: ResourceTestCase API Reference

1.6.1.24 `assertValidXML'
.........................

 -- Method: ResourceTestCase.assertValidXML (self, data)

  Given the provided `data' as a string, ensures that it is valid XML &
can be loaded properly.


File: django-tastypie.info,  Node: assertValidYAML,  Next: assertValidPlist,  Prev: assertValidXML,  Up: ResourceTestCase API Reference

1.6.1.25 `assertValidYAML'
..........................

 -- Method: ResourceTestCase.assertValidYAML (self, data)

  Given the provided `data' as a string, ensures that it is valid YAML &
can be loaded properly.


File: django-tastypie.info,  Node: assertValidPlist,  Next: assertValidJSONResponse,  Prev: assertValidYAML,  Up: ResourceTestCase API Reference

1.6.1.26 `assertValidPlist'
...........................

 -- Method: ResourceTestCase.assertValidPlist (self, data)

  Given the provided `data' as a string, ensures that it is valid
binary plist & can be loaded properly.


File: django-tastypie.info,  Node: assertValidJSONResponse,  Next: assertValidXMLResponse,  Prev: assertValidPlist,  Up: ResourceTestCase API Reference

1.6.1.27 `assertValidJSONResponse'
..................................

 -- Method: ResourceTestCase.assertValidJSONResponse (self, resp)

  Given a `HttpResponse' coming back from using the `client', assert
that you get back:

   * An HTTP 200

   * The correct content-type (`application/json')

   * The content is valid JSON


File: django-tastypie.info,  Node: assertValidXMLResponse,  Next: assertValidYAMLResponse,  Prev: assertValidJSONResponse,  Up: ResourceTestCase API Reference

1.6.1.28 `assertValidXMLResponse'
.................................

 -- Method: ResourceTestCase.assertValidXMLResponse (self, resp)

  Given a `HttpResponse' coming back from using the `client', assert
that you get back:

   * An HTTP 200

   * The correct content-type (`application/xml')

   * The content is valid XML


File: django-tastypie.info,  Node: assertValidYAMLResponse,  Next: assertValidPlistResponse,  Prev: assertValidXMLResponse,  Up: ResourceTestCase API Reference

1.6.1.29 `assertValidYAMLResponse'
..................................

 -- Method: ResourceTestCase.assertValidYAMLResponse (self, resp)

  Given a `HttpResponse' coming back from using the `client', assert
that you get back:

   * An HTTP 200

   * The correct content-type (`text/yaml')

   * The content is valid YAML


File: django-tastypie.info,  Node: assertValidPlistResponse,  Next: deserialize,  Prev: assertValidYAMLResponse,  Up: ResourceTestCase API Reference

1.6.1.30 `assertValidPlistResponse'
...................................

 -- Method: ResourceTestCase.assertValidPlistResponse (self, resp)

  Given a `HttpResponse' coming back from using the `client', assert
that you get back:

   * An HTTP 200

   * The correct content-type (`application/x-plist')

   * The content is valid binary plist data


File: django-tastypie.info,  Node: deserialize,  Next: serialize,  Prev: assertValidPlistResponse,  Up: ResourceTestCase API Reference

1.6.1.31 `deserialize'
......................

 -- Method: ResourceTestCase.deserialize (self, resp)

  Given a `HttpResponse' coming back from using the `client', this
method checks the `Content-Type' header & attempts to deserialize the
data based on that.

  It returns a Python datastructure (typically a `dict') of the
serialized data.


File: django-tastypie.info,  Node: serialize,  Next: assertKeys,  Prev: deserialize,  Up: ResourceTestCase API Reference

1.6.1.32 `serialize'
....................

 -- Method: ResourceTestCase.serialize (self, data,
          format='application/json')

  Given a Python datastructure (typically a `dict') & a desired
content-type, this method will return a serialized string of that data.


File: django-tastypie.info,  Node: assertKeys,  Prev: serialize,  Up: ResourceTestCase API Reference

1.6.1.33 `assertKeys'
.....................

 -- Method: ResourceTestCase.assertKeys (self, data, expected)

  This method ensures that the keys of the `data' match up to the keys
of `expected'.

  It covers the (extremely) common case where you want to make sure the
keys of a response match up to what is expected. This is typically less
fragile than testing the full structure, which can be prone to data
changes.


File: django-tastypie.info,  Node: TestApiClient API Reference,  Prev: ResourceTestCase API Reference,  Up: Example Usage

1.6.1.34 `TestApiClient' API Reference
......................................

The `TestApiClient' simulates a HTTP client making calls to the API.
It's important to note that it uses Django's testing infrastructure, so
it's not making actual calls against a webserver.

* Menu:

* __init__::
* get_content_type::
* get::
* post::
* put::
* patch::
* delete::


File: django-tastypie.info,  Node: __init__,  Next: get_content_type,  Up: TestApiClient API Reference

1.6.1.35 `__init__'
...................

 -- Method: TestApiClient.__init__ (self, serializer=None)

  Sets up a fresh `TestApiClient' instance.

  If you are employing a custom serializer, you can pass the class to
the `serializer=' kwarg.


File: django-tastypie.info,  Node: get_content_type,  Next: get,  Prev: __init__,  Up: TestApiClient API Reference

1.6.1.36 `get_content_type'
...........................

 -- Method: TestApiClient.get_content_type (self, short_format)

  Given a short name (such as `json' or `xml'), returns the full
content-type for it (`application/json' or `application/xml' in this
case).


File: django-tastypie.info,  Node: get,  Next: post,  Prev: get_content_type,  Up: TestApiClient API Reference

1.6.1.37 `get'
..............

 -- Method: TestApiClient.get (self, uri, format='json', data=None,
          authentication=None, **kwargs)

  Performs a simulated `GET' request to the provided URI.

  Optionally accepts a `data' kwarg, which in the case of `GET', lets
you send along `GET' parameters. This is useful when testing filtering
or other things that read off the `GET' params. Example:

    from tastypie.test import TestApiClient
    client = TestApiClient()

    response = client.get('/api/v1/entry/1/', data={'format': 'json', 'title__startswith': 'a', 'limit': 20, 'offset': 60})

Optionally accepts an `authentication' kwarg, which should be an HTTP
header with the correct authentication data already setup.

  All other `**kwargs' passed in get passed through to the Django
`TestClient'. See
<https://docs.djangoproject.com/en/dev/topics/testing/#module-django.test.client>
for details.


File: django-tastypie.info,  Node: post,  Next: put,  Prev: get,  Up: TestApiClient API Reference

1.6.1.38 `post'
...............

 -- Method: TestApiClient.post (self, uri, format='json', data=None,
          authentication=None, **kwargs)

  Performs a simulated `POST' request to the provided URI.

  Optionally accepts a `data' kwarg. *Unlike* `GET', in `POST' the
`data' gets serialized & sent as the body instead of becoming part of
the URI.  Example:

    from tastypie.test import TestApiClient
    client = TestApiClient()

    response = client.post('/api/v1/entry/', data={
        'created': '2012-05-01T20:02:36',
        'slug': 'another-post',
        'title': 'Another Post',
        'user': '/api/v1/user/1/',
    })

Optionally accepts an `authentication' kwarg, which should be an HTTP
header with the correct authentication data already setup.

  All other `**kwargs' passed in get passed through to the Django
`TestClient'. See
<https://docs.djangoproject.com/en/dev/topics/testing/#module-django.test.client>
for details.


File: django-tastypie.info,  Node: put,  Next: patch,  Prev: post,  Up: TestApiClient API Reference

1.6.1.39 `put'
..............

 -- Method: TestApiClient.put (self, uri, format='json', data=None,
          authentication=None, **kwargs)

  Performs a simulated `PUT' request to the provided URI.

  Optionally accepts a `data' kwarg. *Unlike* `GET', in `PUT' the
`data' gets serialized & sent as the body instead of becoming part of
the URI.  Example:

    from tastypie.test import TestApiClient
    client = TestApiClient()

    response = client.put('/api/v1/entry/1/', data={
        'created': '2012-05-01T20:02:36',
        'slug': 'another-post',
        'title': 'Another Post',
        'user': '/api/v1/user/1/',
    })

Optionally accepts an `authentication' kwarg, which should be an HTTP
header with the correct authentication data already setup.

  All other `**kwargs' passed in get passed through to the Django
`TestClient'. See
<https://docs.djangoproject.com/en/dev/topics/testing/#module-django.test.client>
for details.


File: django-tastypie.info,  Node: patch,  Next: delete,  Prev: put,  Up: TestApiClient API Reference

1.6.1.40 `patch'
................

 -- Method: TestApiClient.patch (self, uri, format='json', data=None,
          authentication=None, **kwargs)

  Performs a simulated `PATCH' request to the provided URI.

  Optionally accepts a `data' kwarg. *Unlike* `GET', in `PATCH' the
`data' gets serialized & sent as the body instead of becoming part of
the URI.  Example:

    from tastypie.test import TestApiClient
    client = TestApiClient()

    response = client.patch('/api/v1/entry/1/', data={
        'created': '2012-05-01T20:02:36',
        'slug': 'another-post',
        'title': 'Another Post',
        'user': '/api/v1/user/1/',
    })

Optionally accepts an `authentication' kwarg, which should be an HTTP
header with the correct authentication data already setup.

  All other `**kwargs' passed in get passed through to the Django
`TestClient'. See
<https://docs.djangoproject.com/en/dev/topics/testing/#module-django.test.client>
for details.


File: django-tastypie.info,  Node: delete,  Prev: patch,  Up: TestApiClient API Reference

1.6.1.41 `delete'
.................

 -- Method: TestApiClient.delete (self, uri, format='json', data=None,
          authentication=None, **kwargs)

  Performs a simulated `DELETE' request to the provided URI.

  Optionally accepts a `data' kwarg, which in the case of `DELETE',
lets you send along `DELETE' parameters. This is useful when testing
filtering or other things that read off the `DELETE' params. Example:

    from tastypie.test import TestApiClient
    client = TestApiClient()

    response = client.delete('/api/v1/entry/1/', data={'format': 'json'})

Optionally accepts an `authentication' kwarg, which should be an HTTP
header with the correct authentication data already setup.

  All other `**kwargs' passed in get passed through to the Django
`TestClient'. See
<https://docs.djangoproject.com/en/dev/topics/testing/#module-django.test.client>
for details.


File: django-tastypie.info,  Node: Compatibility Notes,  Next: Resources,  Prev: Testing,  Up: Welcome to Tastypie!

1.7 Compatibility Notes
=======================

Tastypie does its best to be a good third-party app, trying to
interoperate with the widest range of Django environments it can.
However, there are times where certain things aren't possible. We'll do
our best to document them here.

* Menu:

* ApiKey Database Index::


File: django-tastypie.info,  Node: ApiKey Database Index,  Up: Compatibility Notes

1.7.1 `ApiKey' Database Index
-----------------------------

When the `ApiKey' model was added to Tastypie, an index was lacking on
the `key' field. This was the case until the v0.9.12 release. The model
was updated & a migration was added (`0002_add_apikey_index.py').
However, due to the way MySQL works & the way Django generates index
names, this migration would fail miserably on many MySQL installs.

  If you are using MySQL, South & the `ApiKey' authentication class,
you should manually add an index for the the `ApiKey.key' field.
Something to the effect of:

    BEGIN; -- LOLMySQL
    CREATE INDEX tastypie_apikey_key_index ON tastypie_apikey (`key`);
    COMMIT;



File: django-tastypie.info,  Node: Resources,  Next: Bundles,  Prev: Compatibility Notes,  Up: Welcome to Tastypie!

1.8 Resources
=============

In terms of a REST-style architecture, a "resource" is a collection of
similar data. This data could be a table of a database, a collection of
other resources or a similar form of data storage. In Tastypie, these
resources are generally intermediaries between the end user & objects,
usually Django models. As such, `Resource' (and its model-specific twin
`ModelResource') form the heart of Tastypie's functionality.

* Menu:

* Quick Start::
* Why Class-Based?::
* Why Resource vs. ModelResource?: Why Resource vs ModelResource?.
* Flow Through The Request/Response Cycle::
* Why Resource URIs?::
* Advanced Data Preparation::
* Reverse "Relationships"::
* Resource Options (AKA Meta): Resource Options AKA Meta.
* Basic Filtering::
* Advanced Filtering::
* Using PUT/DELETE/PATCH In Unsupported Places::
* Resource Methods::
* ModelResource Methods::


File: django-tastypie.info,  Node: Quick Start,  Next: Why Class-Based?,  Up: Resources

1.8.1 Quick Start
-----------------

A sample resource definition might look something like:

    from django.contrib.auth.models import User
    from tastypie import fields
    from tastypie.authorization import DjangoAuthorization
    from tastypie.resources import ModelResource, ALL, ALL_WITH_RELATIONS
    from myapp.models import Entry


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']


    class EntryResource(ModelResource):
        user = fields.ForeignKey(UserResource, 'user')

        class Meta:
            queryset = Entry.objects.all()
            list_allowed_methods = ['get', 'post']
            detail_allowed_methods = ['get', 'post', 'put', 'delete']
            resource_name = 'myapp/entry'
            authorization = DjangoAuthorization()
            filtering = {
                'slug': ALL,
                'user': ALL_WITH_RELATIONS,
                'created': ['exact', 'range', 'gt', 'gte', 'lt', 'lte'],
            }



File: django-tastypie.info,  Node: Why Class-Based?,  Next: Why Resource vs ModelResource?,  Prev: Quick Start,  Up: Resources

1.8.2 Why Class-Based?
----------------------

Using class-based resources make it easier to extend/modify the code to
meet your needs. APIs are rarely a one-size-fits-all problem space, so
Tastypie tries to get the fundamentals right and provide you with
enough hooks to customize things to work your way.

  As is standard, this raises potential problems for thread-safety.
Tastypie has been designed to minimize the possibility of data
"leaking" between threads.  This does however sometimes introduce some
small complexities & you should be careful not to store state on the
instances if you're going to be using the code in a threaded
environment.


File: django-tastypie.info,  Node: Why Resource vs ModelResource?,  Next: Flow Through The Request/Response Cycle,  Prev: Why Class-Based?,  Up: Resources

1.8.3 Why `Resource' vs. `ModelResource'?
-----------------------------------------

Make no mistake that Django models are far and away the most popular
source of data. However, in practice, there are many times where the
ORM isn't the data source. Hooking up things like a NoSQL store (see
*note Using Tastypie With Non-ORM Data Sources: 37.), a search solution
like Haystack or even managed filesystem data are all good use cases
for `Resource' knowing nothing about the ORM.


File: django-tastypie.info,  Node: Flow Through The Request/Response Cycle,  Next: Why Resource URIs?,  Prev: Why Resource vs ModelResource?,  Up: Resources

1.8.4 Flow Through The Request/Response Cycle
---------------------------------------------

Tastypie can be thought of as a set of class-based views that provide
the API functionality. As such, many part of the request/response cycle
are standard Django behaviors. For instance, all
routing/middleware/response-handling aspects are the same as a typical
Django app. Where it differs is in the view itself.

  As an example, we'll walk through what a GET request to a list
endpoint (say `/api/v1/user/?format=json') looks like:

   * The `Resource.urls' are checked by Django's url resolvers.

   * On a match for the list view,
     `Resource.wrap_view('dispatch_list')' is called. `wrap_view'
     provides basic error handling & allows for returning serialized
     errors.

   * Because `dispatch_list' was passed to `wrap_view',
     `Resource.dispatch_list' is called next. This is a thin wrapper
     around `Resource.dispatch'.

   * `dispatch' does a bunch of heavy lifting. It ensures:

        * the requested HTTP method is in `allowed_methods'
          (`method_check'),

        * the class has a method that can handle the request
          (`get_list'),

        * the user is authenticated (`is_authenticated'),

        * the user is authorized (`is_authorized'),

        * & the user has not exceeded their throttle (`throttle_check').

     At this point, `dispatch' actually calls the requested method
     (`get_list').

   * `get_list' does the actual work of the API. It does:

        * A fetch of the available objects via `Resource.obj_get_list'.
          In the case of `ModelResource', this builds the ORM filters
          to apply (`ModelResource.build_filters'). It then gets the
          `QuerySet' via `ModelResource.get_object_list' (which performs
          `Resource.apply_authorization_limits' to possibly limit the
          set the user can work with) and applies the built filters to
          it.

        * It then sorts the objects based on user input
          (`ModelResource.apply_sorting').

        * Then it paginates the results using the supplied `Paginator'
          & pulls out the data to be serialized.

        * The objects in the page have `full_dehydrate' applied to each
          of them, causing Tastypie to translate the raw object data
          into the fields the endpoint supports.

        * Finally, it calls `Resource.create_response'.

   * `create_response' is a shortcut method that:

        * Determines the desired response format
          (`Resource.determine_format'),

        * Serializes the data given to it in the proper format,

        * And returns a Django `HttpResponse' (200 OK) with the
          serialized data.

   * We bubble back up the call stack to `dispatch'. The last thing
     `dispatch' does is potentially store that a request occurred for
     future throttling (`Resource.log_throttled_access') then either
     returns the `HttpResponse' or wraps whatever data came back in a
     response (so Django doesn't freak out).

  Processing on other endpoints or using the other HTTP methods results
in a similar cycle, usually differing only in what "actual work" method
gets called (which follows the format of
"`<http_method>_<list_or_detail>'"). In the case of POST/PUT, the
`hydrate' cycle additionally takes place and is used to take the user
data & convert it to raw data for storage.


File: django-tastypie.info,  Node: Why Resource URIs?,  Next: Advanced Data Preparation,  Prev: Flow Through The Request/Response Cycle,  Up: Resources

1.8.5 Why Resource URIs?
------------------------

Resource URIs play a heavy role in how Tastypie delivers data. This can
seem very different from other solutions which simply inline related
data. Though Tastypie can inline data like that (using `full=True' on
the field with the relation), the default is to provide URIs.

  URIs are useful because it results in smaller payloads, letting you
fetch only the data that is important to you. You can imagine an
instance where an object has thousands of related items that you may
not be interested in.

  URIs are also very cache-able, because the data at each endpoint is
less likely to frequently change.

  And URIs encourage proper use of each endpoint to display the data
that endpoint covers.

  Ideology aside, you should use whatever suits you. If you prefer
fewer requests & fewer endpoints, use of `full=True' is available, but
be aware of the consequences of each approach.


File: django-tastypie.info,  Node: Advanced Data Preparation,  Next: Reverse "Relationships",  Prev: Why Resource URIs?,  Up: Resources

1.8.6 Advanced Data Preparation
-------------------------------

Not all data can be easily pull off an object/model attribute. And
sometimes, you (or the client) may need to send data that doesn't
neatly fit back into the data model on the server side. For this,
Tastypie has the "dehydrate/hydrate" cycle.

* Menu:

* The Dehydrate Cycle::
* The Hydrate Cycle::

The Dehydrate Cycle

* Per-field dehydrate::
* dehydrate_FOO::
* dehydrate::

The Hydrate Cycle

* hydrate::
* hydrate_FOO::
* Per-field hydrate::


File: django-tastypie.info,  Node: The Dehydrate Cycle,  Next: The Hydrate Cycle,  Up: Advanced Data Preparation

1.8.6.1 The Dehydrate Cycle
...........................

Tastypie uses a "dehydrate" cycle to prepare data for serialization,
which is to say that it takes the raw, potentially complicated data
model & turns it into a (generally simpler) processed data structure
for client consumption.  This usually means taking a complex data
object & turning it into a dictionary of simple data types.

  Broadly speaking, this takes the `bundle.obj' instance & builds
`bundle.data', which is what is actually serialized.

  The cycle looks like:

   * Put the data model into a `Bundle' instance, which is then passed
     through the various methods.

   * Run through all fields on the `Resource', letting each field
     perform its own `dehydrate' method on the `bundle'.

   * While processing each field, look for a `dehydrate_<fieldname>'
     method on the `Resource'. If it's present, call it with the
     `bundle'.

   * Finally, after all fields are processed, if the `dehydrate' method
     is present on the `Resource', it is called & given the entire
     `bundle'.

  The goal of this cycle is to populate the `bundle.data' dictionary
with data suitable for serialization. With the exception of the
`alter_*' methods (as hooks to manipulate the overall structure), this
cycle controls what is actually handed off to be serialized & sent to
the client.

* Menu:

* Per-field dehydrate::
* dehydrate_FOO::
* dehydrate::


File: django-tastypie.info,  Node: Per-field dehydrate,  Next: dehydrate_FOO,  Up: The Dehydrate Cycle

1.8.6.2 Per-field `dehydrate'
.............................

Each field (even custom `ApiField' subclasses) has its own `dehydrate'
method. If it knows how to access data (say, given the `attribute'
kwarg), it will attempt to populate values itself.

  The return value is put in the `bundle.data' dictionary (by the
`Resource') with the fieldname as the key.


File: django-tastypie.info,  Node: dehydrate_FOO,  Next: dehydrate,  Prev: Per-field dehydrate,  Up: The Dehydrate Cycle

1.8.6.3 `dehydrate_FOO'
.......................

Since not all data may be ready for consumption based on just attribute
access (or may require an advanced lookup/calculation), this hook
enables you to fill in data or massage whatever the field generated.

     Note: The `FOO' here is not literal. Instead, it is a placeholder
     that should be replaced with the fieldname in question.

  Defining these methods is especially common when denormalizing
related data, providing statistics or filling in unrelated data.

  A simple example:

    class MyResource(ModelResource):
        # The ``title`` field is already added to the class by ``ModelResource``
        # and populated off ``Note.title``. But we want allcaps titles...

        class Meta:
            queryset = Note.objects.all()

        def dehydrate_title(self, bundle):
            return bundle.data['title'].upper()

A complex example:

    class MyResource(ModelResource):
        # As is, this is just an empty field. Without the ``dehydrate_rating``
        # method, no data would be populated for it.
        rating = fields.FloatField(readonly=True)

        class Meta:
            queryset = Note.objects.all()

        def dehydrate_rating(self, bundle):
            total_score = 0.0

            # Make sure we don't have to worry about "divide by zero" errors.
            if not bundle.obj.rating_set.count():
                return rating

            # We'll run over all the ``Rating`` objects & calculate an average.
            for rating in bundle.obj.rating_set.all():
                total_score += rating.rating

            return total_score /  bundle.obj.rating_set.count()

The return value is updated in the `bundle.data'. You should avoid
altering `bundle.data' here if you can help it.


File: django-tastypie.info,  Node: dehydrate,  Prev: dehydrate_FOO,  Up: The Dehydrate Cycle

1.8.6.4 `dehydrate'
...................

The `dehydrate' method takes a now fully-populated `bundle.data' & make
any last alterations to it. This is useful for when a piece of data
might depend on more than one field, if you want to shove in extra data
that isn't worth having its own field or if you want to dynamically
remove things from the data to be returned.

  A simple example:

    class MyResource(ModelResource):
        class Meta:
            queryset = Note.objects.all()

        def dehydrate(self, bundle):
            # Include the request IP in the bundle.
            bundle.data['request_ip'] = bundle.request.META.get('REMOTE_ADDR')
            return bundle

A complex example:

    class MyResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            excludes = ['email', 'password', 'is_staff', 'is_superuser']

        def dehydrate(self, bundle):
            # If they're requesting their own record, add in their email address.
            if bundle.request.user.pk == bundle.obj.pk:
                # Note that there isn't an ``email`` field on the ``Resource``.
                # By this time, it doesn't matter, as the built data will no
                # longer be checked against the fields on the ``Resource``.
                bundle.data['email'] = bundle.obj.email

            return bundle

This method should return a `bundle', whether it modifies the existing
one or creates a whole new one. You can even remove any/all data from
the `bundle.data' if you wish.


File: django-tastypie.info,  Node: The Hydrate Cycle,  Prev: The Dehydrate Cycle,  Up: Advanced Data Preparation

1.8.6.5 The Hydrate Cycle
.........................

Tastypie uses a "hydrate" cycle to take serializated data from the
client and turn it into something the data model can use. This is the
reverse process from the `dehydrate' cycle. In fact, by default,
Tastypie's serialized data should be "round-trip-able", meaning the
data that comes out should be able to be fed back in & result in the
same original data model. This usually means taking a dictionary of
simple data types & turning it into a complex data object.

  Broadly speaking, this takes the recently-deserialized `bundle.data'
dictionary & builds `bundle.obj' (but does *NOT* save it).

  The cycle looks like:

   * Put the data from the client into a `Bundle' instance, which is
     then passed through the various methods.

   * If the `hydrate' method is present on the `Resource', it is called
     & given the entire `bundle'.

   * Then run through all fields on the `Resource', look for a
     `hydrate_<fieldname>' method on the `Resource'. If it's present,
     call it with the `bundle'.

   * Finally after all other processing is done, while processing each
     field, let each field perform its own `hydrate' method on the
     `bundle'.

  The goal of this cycle is to populate the `bundle.obj' data model
with data suitable for saving/persistence. Again, with the exception of
the `alter_*' methods (as hooks to manipulate the overall structure),
this cycle controls how the data from the client is interpreted &
placed on the data model.

* Menu:

* hydrate::
* hydrate_FOO::
* Per-field hydrate::


File: django-tastypie.info,  Node: hydrate,  Next: hydrate_FOO,  Up: The Hydrate Cycle

1.8.6.6 `hydrate'
.................

The `hydrate' method allows you to make initial changes to the
`bundle.obj'.  This includes things like prepopulating fields you don't
expose over the API, recalculating related data or mangling data.

  Example:

    class MyResource(ModelResource):
        # The ``title`` field is already added to the class by ``ModelResource``
        # and populated off ``Note.title``. We'll use that title to build a
        # ``Note.slug`` as well.

        class Meta:
            queryset = Note.objects.all()

        def hydrate(self, bundle):
            # Don't change existing slugs.
            # In reality, this would be better implemented at the ``Note.save``
            # level, but is for demonstration.
            if not bundle.obj.pk:
                bundle.obj.slug = slugify(bundle.data['title'])

            return bundle

This method should return a `bundle', whether it modifies the existing
one or creates a whole new one. You can even remove any/all data from
the `bundle.obj' if you wish.


File: django-tastypie.info,  Node: hydrate_FOO,  Next: Per-field hydrate,  Prev: hydrate,  Up: The Hydrate Cycle

1.8.6.7 `hydrate_FOO'
.....................

Data from the client may not map directly onto the data model or might
need augmentation. This hook lets you take that data & convert it.

     Note: The `FOO' here is not literal. Instead, it is a placeholder
     that should be replaced with the fieldname in question.

  A simple example:

    class MyResource(ModelResource):
        # The ``title`` field is already added to the class by ``ModelResource``
        # and populated off ``Note.title``. But we want lowercase titles...

        class Meta:
            queryset = Note.objects.all()

        def hydrate_title(self, bundle):
            bundle.data['title'] = bundle.data['title'].lower()
            return bundle

The return value is the `bundle'.


File: django-tastypie.info,  Node: Per-field hydrate,  Prev: hydrate_FOO,  Up: The Hydrate Cycle

1.8.6.8 Per-field `hydrate'
...........................

Each field (even custom `ApiField' subclasses) has its own `hydrate'
method. If it knows how to access data (say, given the `attribute'
kwarg), it will attempt to take data from the `bundle.data' & assign it
on the data model.

  The return value is put in the `bundle.obj' attribute for that
fieldname.


File: django-tastypie.info,  Node: Reverse "Relationships",  Next: Resource Options AKA Meta,  Prev: Advanced Data Preparation,  Up: Resources

1.8.7 Reverse "Relationships"
-----------------------------

Unlike Django's ORM, Tastypie does not automatically create reverse
relations.  This is because there is substantial technical complexity
involved, as well as perhaps unintentionally exposing related data in
an incorrect way to the end user of the API.

  However, it is still possible to create reverse relations. Instead of
handing the `ToOneField' or `ToManyField' a class, pass them a string
that represents the full path to the desired class. Implementing a
reverse relationship looks like so:

    # myapp/api/resources.py
    from tastypie import fields
    from tastypie.resources import ModelResource
    from myapp.models import Note, Comment


    class NoteResource(ModelResource):
        comments = fields.ToManyField('myapp.api.resources.CommentResource', 'comments')

        class Meta:
            queryset = Note.objects.all()


    class CommentResource(ModelResource):
        note = fields.ToOneField(NoteResource, 'notes')

        class Meta:
            queryset = Comment.objects.all()


     Warning: Unlike Django, you can't use just the class name (i.e.
     `'CommentResource''), even if it's in the same module. Tastypie
     (intentionally) lacks a construct like the `AppCache' which makes
     that sort of thing work in Django. Sorry.

  Tastypie also supports self-referential relations. If you assume we
added the appropriate self-referential `ForeignKey' to the `Note'
model, implementing a similar relation in Tastypie would look like:

    # myapp/api/resources.py
    from tastypie import fields
    from tastypie.resources import ModelResource
    from myapp.models import Note


    class NoteResource(ModelResource):
        sub_notes = fields.ToManyField('self', 'notes')

        class Meta:
            queryset = Note.objects.all()



File: django-tastypie.info,  Node: Resource Options AKA Meta,  Next: Basic Filtering,  Prev: Reverse "Relationships",  Up: Resources

1.8.8 Resource Options (AKA `Meta')
-----------------------------------

The inner `Meta' class allows for class-level configuration of how the
`Resource' should behave. The following options are available:

* Menu:

* serializer::
* authentication::
* authorization::
* validation::
* paginator_class::
* cache::
* throttle::
* allowed_methods::
* list_allowed_methods::
* detail_allowed_methods::
* limit::
* max_limit::
* api_name::
* resource_name::
* default_format::
* filtering::
* ordering::
* object_class::
* queryset::
* fields::
* excludes::
* include_resource_uri::
* include_absolute_url::
* always_return_data::
* collection_name::
* detail_uri_name::


File: django-tastypie.info,  Node: serializer,  Next: authentication,  Up: Resource Options AKA Meta

1.8.8.1 `serializer'
....................

     Controls which serializer class the `Resource' should use. Default
     is `tastypie.serializers.Serializer()'.


File: django-tastypie.info,  Node: authentication,  Next: authorization,  Prev: serializer,  Up: Resource Options AKA Meta

1.8.8.2 `authentication'
........................

     Controls which authentication class the `Resource' should use.
     Default is `tastypie.authentication.Authentication()'.


File: django-tastypie.info,  Node: authorization,  Next: validation,  Prev: authentication,  Up: Resource Options AKA Meta

1.8.8.3 `authorization'
.......................

     Controls which authorization class the `Resource' should use.
     Default is `tastypie.authorization.ReadOnlyAuthorization()'.


File: django-tastypie.info,  Node: validation,  Next: paginator_class,  Prev: authorization,  Up: Resource Options AKA Meta

1.8.8.4 `validation'
....................

     Controls which validation class the `Resource' should use. Default
     is `tastypie.validation.Validation()'.


File: django-tastypie.info,  Node: paginator_class,  Next: cache,  Prev: validation,  Up: Resource Options AKA Meta

1.8.8.5 `paginator_class'
.........................

     Controls which paginator class the `Resource' should use. Default
     is `tastypie.paginator.Paginator'.

     Note: This is different than the other options in that you supply
     a class rather than an instance. This is done because the
     Paginator has some per-request initialization options.


File: django-tastypie.info,  Node: cache,  Next: throttle,  Prev: paginator_class,  Up: Resource Options AKA Meta

1.8.8.6 `cache'
...............

     Controls which cache class the `Resource' should use. Default is
     `tastypie.cache.NoCache()'.


File: django-tastypie.info,  Node: throttle,  Next: allowed_methods,  Prev: cache,  Up: Resource Options AKA Meta

1.8.8.7 `throttle'
..................

     Controls which throttle class the `Resource' should use. Default is
     `tastypie.throttle.BaseThrottle()'.


File: django-tastypie.info,  Node: allowed_methods,  Next: list_allowed_methods,  Prev: throttle,  Up: Resource Options AKA Meta

1.8.8.8 `allowed_methods'
.........................

     Controls what list & detail REST methods the `Resource' should
     respond to.  Default is `None', which means delegate to the more
     specific `list_allowed_methods' & `detail_allowed_methods' options.

     You may specify a list like `['get', 'post', 'put', 'delete',
     'patch']' as a shortcut to prevent having to specify the other
     options.


File: django-tastypie.info,  Node: list_allowed_methods,  Next: detail_allowed_methods,  Prev: allowed_methods,  Up: Resource Options AKA Meta

1.8.8.9 `list_allowed_methods'
..............................

     Controls what list REST methods the `Resource' should respond to.
     Default is `['get', 'post', 'put', 'delete', 'patch']'.


File: django-tastypie.info,  Node: detail_allowed_methods,  Next: limit,  Prev: list_allowed_methods,  Up: Resource Options AKA Meta

1.8.8.10 `detail_allowed_methods'
.................................

     Controls what detail REST methods the `Resource' should respond
     to. Default is `['get', 'post', 'put', 'delete', 'patch']'.


File: django-tastypie.info,  Node: limit,  Next: max_limit,  Prev: detail_allowed_methods,  Up: Resource Options AKA Meta

1.8.8.11 `limit'
................

     Controls how many results the `Resource' will show at a time.
     Default is either the `API_LIMIT_PER_PAGE' setting (if provided)
     or `20' if not specified.


File: django-tastypie.info,  Node: max_limit,  Next: api_name,  Prev: limit,  Up: Resource Options AKA Meta

1.8.8.12 `max_limit'
....................

     Controls the maximum number of results the `Resource' will show at
     a time.  If the user-specified `limit' is higher than this, it
     will be capped to this limit. Set to `0' or `None' to allow
     unlimited results.


File: django-tastypie.info,  Node: api_name,  Next: resource_name,  Prev: max_limit,  Up: Resource Options AKA Meta

1.8.8.13 `api_name'
...................

     An override for the `Resource' to use when generating resource
     URLs.  Default is `None'.


File: django-tastypie.info,  Node: resource_name,  Next: default_format,  Prev: api_name,  Up: Resource Options AKA Meta

1.8.8.14 `resource_name'
........................

     An override for the `Resource' to use when generating resource
     URLs.  Default is `None'.

     If not provided, the `Resource' or `ModelResource' will attempt to
     name itself. This means a lowercase version of the classname
     preceding the word `Resource' if present (i.e.
     `SampleContentResource' would become `samplecontent').


File: django-tastypie.info,  Node: default_format,  Next: filtering,  Prev: resource_name,  Up: Resource Options AKA Meta

1.8.8.15 `default_format'
.........................

     Specifies the default serialization format the `Resource' should
     use if one is not requested (usually by the `Accept' header or
     `format' GET parameter). Default is `application/json'.


File: django-tastypie.info,  Node: filtering,  Next: ordering,  Prev: default_format,  Up: Resource Options AKA Meta

1.8.8.16 `filtering'
....................

     Provides a list of fields that the `Resource' will accept client
     filtering on. Default is `{}'.

     Keys should be the fieldnames as strings while values should be a
     list of accepted filter types.


File: django-tastypie.info,  Node: ordering,  Next: object_class,  Prev: filtering,  Up: Resource Options AKA Meta

1.8.8.17 `ordering'
...................

     Specifies the what fields the `Resource' should should allow
     ordering on.  Default is `[]'.

     Values should be the fieldnames as strings. When provided to the
     `Resource' by the `order_by' GET parameter, you can specify either
     the `fieldname' (ascending order) or `-fieldname' (descending
     order).


File: django-tastypie.info,  Node: object_class,  Next: queryset,  Prev: ordering,  Up: Resource Options AKA Meta

1.8.8.18 `object_class'
.......................

     Provides the `Resource' with the object that serves as the data
     source.  Default is `None'.

     In the case of `ModelResource', this is automatically populated by
     the `queryset' option and is the model class.


File: django-tastypie.info,  Node: queryset,  Next: fields,  Prev: object_class,  Up: Resource Options AKA Meta

1.8.8.19 `queryset'
...................

     Provides the `Resource' with the set of Django models to respond
     with.  Default is `None'.

     Unused by `Resource' but present for consistency.

     Warning: If you place any callables in this, they'll only be
     evaluated once (when the `Meta' class is instantiated). This
     especially affects things that are date/time related. Please see
     the :ref:cookbook for a way around this.


File: django-tastypie.info,  Node: fields,  Next: excludes,  Prev: queryset,  Up: Resource Options AKA Meta

1.8.8.20 `fields'
.................

     Controls what introspected fields the `Resource' should include.
     A whitelist of fields. Default is `[]'.


File: django-tastypie.info,  Node: excludes,  Next: include_resource_uri,  Prev: fields,  Up: Resource Options AKA Meta

1.8.8.21 `excludes'
...................

     Controls what introspected fields the `Resource' should _NOT_
     include.  A blacklist of fields. Default is `[]'.


File: django-tastypie.info,  Node: include_resource_uri,  Next: include_absolute_url,  Prev: excludes,  Up: Resource Options AKA Meta

1.8.8.22 `include_resource_uri'
...............................

     Specifies if the `Resource' should include an extra field that
     displays the detail URL (within the api) for that resource.
     Default is `True'.


File: django-tastypie.info,  Node: include_absolute_url,  Next: always_return_data,  Prev: include_resource_uri,  Up: Resource Options AKA Meta

1.8.8.23 `include_absolute_url'
...............................

     Specifies if the `Resource' should include an extra field that
     displays the `get_absolute_url' for that object (on the site
     proper). Default is `False'.


File: django-tastypie.info,  Node: always_return_data,  Next: collection_name,  Prev: include_absolute_url,  Up: Resource Options AKA Meta

1.8.8.24 `always_return_data'
.............................

     Specifies all HTTP methods (except `DELETE') should return a
     serialized form of the data. Default is `False'.

     If `False', `HttpNoContent' (204) is returned on `POST/PUT' with
     an empty body & a `Location' header of where to request the full
     resource.

     If `True', `HttpAccepted' (202) is returned on `POST/PUT' with a
     body containing all the data in a serialized form.


File: django-tastypie.info,  Node: collection_name,  Next: detail_uri_name,  Prev: always_return_data,  Up: Resource Options AKA Meta

1.8.8.25 `collection_name'
..........................

     Specifies the collection of objects returned in the `GET' list
     will be named. Default is `objects'.


File: django-tastypie.info,  Node: detail_uri_name,  Prev: collection_name,  Up: Resource Options AKA Meta

1.8.8.26 `detail_uri_name'
..........................

     Specifies the name for the regex group that matches on detail
     views. Defaults to `pk'.


File: django-tastypie.info,  Node: Basic Filtering,  Next: Advanced Filtering,  Prev: Resource Options AKA Meta,  Up: Resources

1.8.9 Basic Filtering
---------------------

`ModelResource' provides a basic Django ORM filter interface. Simply
list the resource fields which you'd like to filter on and the allowed
expression in a `filtering' property of your resource's Meta class:

    from tastypie.constants import ALL, ALL_WITH_RELATIONS

    class MyResource(ModelResource):
        class Meta:
            filtering = {
                "slug": ('exact', 'startswith',),
                "title": ALL,
            }

Valid filtering values are: Django ORM filters (e.g. `startswith',
`exact', `lte', etc. or the `ALL' or `ALL_WITH_RELATIONS' constants
defined in `tastypie.constants'.

  These filters will be extracted from URL query strings using the same
double-underscore syntax as the Django ORM:

    /api/v1/myresource/?slug=myslug
    /api/v1/myresource/?slug__startswith=test



File: django-tastypie.info,  Node: Advanced Filtering,  Next: Using PUT/DELETE/PATCH In Unsupported Places,  Prev: Basic Filtering,  Up: Resources

1.8.10 Advanced Filtering
-------------------------

If you need to filter things other than ORM resources or wish to apply
additional constraints (e.g. text filtering using `django-haystack
<http://haystacksearch.org>' rather than simple database queries) your
`Resource' may define a custom `build_filters()' method which allows
you to filter the queryset before processing a request:

    from haystack.query import SearchQuerySet

    class MyResource(Resource):
        def build_filters(self, filters=None):
            if filters is None:
                filters = {}

            orm_filters = super(MyResource, self).build_filters(filters)

            if "q" in filters:
                sqs = SearchQuerySet().auto_query(filters['q'])

                orm_filters["pk__in"] = [i.pk for i in sqs]

            return orm_filters



File: django-tastypie.info,  Node: Using PUT/DELETE/PATCH In Unsupported Places,  Next: Resource Methods,  Prev: Advanced Filtering,  Up: Resources

1.8.11 Using PUT/DELETE/PATCH In Unsupported Places
---------------------------------------------------

Some places, like in certain browsers or hosts, don't allow the
`PUT/DELETE/PATCH' methods. In these environments, you can simulate
those kinds of requests by providing an `X-HTTP-Method-Override'
header. For example, to send a `PATCH' request over `POST', you'd send
a request like:

    curl --dump-header - -H "Content-Type: application/json" -H "X-HTTP-Method-Override: PATCH" -X POST --data '{"title": "I Visited Grandma Today"}' http://localhost:8000/api/v1/entry/1/



File: django-tastypie.info,  Node: Resource Methods,  Next: ModelResource Methods,  Prev: Using PUT/DELETE/PATCH In Unsupported Places,  Up: Resources

1.8.12 `Resource' Methods
-------------------------

Handles the data, request dispatch and responding to requests.

  Serialization/deserialization is handled "at the edges" (i.e. at the
beginning/end of the request/response cycle) so that everything
internally is Python data structures.

  This class tries to be non-model specific, so it can be hooked up to
other data sources, such as search results, files, other data, etc.

* Menu:

* wrap_view::
* base_urls::
* override_urls::
* prepend_urls::
* urls::
* determine_format::
* serialize: serialize<2>.
* deserialize: deserialize<2>.
* alter_list_data_to_serialize::
* alter_detail_data_to_serialize::
* alter_deserialized_list_data::
* alter_deserialized_detail_data::
* dispatch_list::
* dispatch_detail::
* dispatch::
* remove_api_resource_names::
* method_check::
* is_authorized::
* is_authenticated::
* throttle_check::
* log_throttled_access::
* build_bundle::
* build_filters::
* apply_sorting::
* get_bundle_detail_data::
* get_resource_uri::
* resource_uri_kwargs::
* detail_uri_kwargs::
* get_via_uri::
* full_dehydrate::
* dehydrate: dehydrate<2>.
* full_hydrate::
* hydrate: hydrate<2>.
* hydrate_m2m::
* build_schema::
* dehydrate_resource_uri::
* generate_cache_key::
* get_object_list::
* apply_authorization_limits::
* can_create::
* can_update::
* can_delete::
* apply_filters::
* obj_get_list::
* cached_obj_get_list::
* obj_get::
* cached_obj_get::
* obj_create::
* lookup_kwargs_with_identifiers::
* obj_update::
* obj_delete_list::
* obj_delete::
* create_response::
* is_valid::
* rollback::
* get_list::
* get_detail::
* put_list::
* put_detail::
* post_list::
* post_detail::
* delete_list::
* delete_detail::
* patch_list::
* patch_detail::
* get_schema::
* get_multiple::


File: django-tastypie.info,  Node: wrap_view,  Next: base_urls,  Up: Resource Methods

1.8.12.1 `wrap_view'
....................

 -- Method: Resource.wrap_view (self, view)

  Wraps methods so they can be called in a more functional way as well
as handling exceptions better.

  Note that if `BadRequest' or an exception with a `response' attr are
seen, there is special handling to either present a message back to the
user or return the response traveling with the exception.


File: django-tastypie.info,  Node: base_urls,  Next: override_urls,  Prev: wrap_view,  Up: Resource Methods

1.8.12.2 `base_urls'
....................

 -- Method: Resource.base_urls (self)

  The standard URLs this `Resource' should respond to. These include the
list, detail, schema & multiple endpoints by default.

  Should return a list of individual URLconf lines (*NOT* wrapped in
`patterns').


File: django-tastypie.info,  Node: override_urls,  Next: prepend_urls,  Prev: base_urls,  Up: Resource Methods

1.8.12.3 `override_urls'
........................

 -- Method: Resource.override_urls (self)

  Deprecated. Will be removed by v1.0.0. Please use
`Resource.prepend_urls' instead.


File: django-tastypie.info,  Node: prepend_urls,  Next: urls,  Prev: override_urls,  Up: Resource Methods

1.8.12.4 `prepend_urls'
.......................

 -- Method: Resource.prepend_urls (self)

  A hook for adding your own URLs or matching before the default URLs.
Useful for adding custom endpoints or overriding the built-in ones
(from `base_urls').

  Should return a list of individual URLconf lines (*NOT* wrapped in
`patterns').


File: django-tastypie.info,  Node: urls,  Next: determine_format,  Prev: prepend_urls,  Up: Resource Methods

1.8.12.5 `urls'
...............

 -- Method: Resource.urls (self)

  _Property_

  The endpoints this `Resource' responds to. A combination of
`base_urls' & `override_urls'.

  Mostly a standard URLconf, this is suitable for either automatic use
when registered with an `Api' class or for including directly in a
URLconf should you choose to.


File: django-tastypie.info,  Node: determine_format,  Next: serialize<2>,  Prev: urls,  Up: Resource Methods

1.8.12.6 `determine_format'
...........................

 -- Method: Resource.determine_format (self, request)

  Used to determine the desired format.

  Largely relies on `tastypie.utils.mime.determine_format' but here as
a point of extension.


File: django-tastypie.info,  Node: serialize<2>,  Next: deserialize<2>,  Prev: determine_format,  Up: Resource Methods

1.8.12.7 `serialize'
....................

 -- Method: Resource.serialize (self, request, data, format,
          options=None)

  Given a request, data and a desired format, produces a serialized
version suitable for transfer over the wire.

  Mostly a hook, this uses the `Serializer' from `Resource._meta'.


File: django-tastypie.info,  Node: deserialize<2>,  Next: alter_list_data_to_serialize,  Prev: serialize<2>,  Up: Resource Methods

1.8.12.8 `deserialize'
......................

 -- Method: Resource.deserialize (self, request, data,
          format='application/json')

  Given a request, data and a format, deserializes the given data.

  It relies on the request properly sending a `CONTENT_TYPE' header,
falling back to `application/json' if not provided.

  Mostly a hook, this uses the `Serializer' from `Resource._meta'.


File: django-tastypie.info,  Node: alter_list_data_to_serialize,  Next: alter_detail_data_to_serialize,  Prev: deserialize<2>,  Up: Resource Methods

1.8.12.9 `alter_list_data_to_serialize'
.......................................

 -- Method: Resource.alter_list_data_to_serialize (self, request, data)

  A hook to alter list data just before it gets serialized & sent to
the user.

  Useful for restructuring/renaming aspects of the what's going to be
sent.

  Should accommodate for a list of objects, generally also including
meta data.


File: django-tastypie.info,  Node: alter_detail_data_to_serialize,  Next: alter_deserialized_list_data,  Prev: alter_list_data_to_serialize,  Up: Resource Methods

1.8.12.10 `alter_detail_data_to_serialize'
..........................................

 -- Method: Resource.alter_detail_data_to_serialize (self, request,
          data)

  A hook to alter detail data just before it gets serialized & sent to
the user.

  Useful for restructuring/renaming aspects of the what's going to be
sent.

  Should accommodate for receiving a single bundle of data.


File: django-tastypie.info,  Node: alter_deserialized_list_data,  Next: alter_deserialized_detail_data,  Prev: alter_detail_data_to_serialize,  Up: Resource Methods

1.8.12.11 `alter_deserialized_list_data'
........................................

 -- Method: Resource.alter_deserialized_list_data (self, request, data)

  A hook to alter list data just after it has been received from the
user & gets deserialized.

  Useful for altering the user data before any hydration is applied.


File: django-tastypie.info,  Node: alter_deserialized_detail_data,  Next: dispatch_list,  Prev: alter_deserialized_list_data,  Up: Resource Methods

1.8.12.12 `alter_deserialized_detail_data'
..........................................

 -- Method: Resource.alter_deserialized_detail_data (self, request,
          data)

  A hook to alter detail data just after it has been received from the
user & gets deserialized.

  Useful for altering the user data before any hydration is applied.


File: django-tastypie.info,  Node: dispatch_list,  Next: dispatch_detail,  Prev: alter_deserialized_detail_data,  Up: Resource Methods

1.8.12.13 `dispatch_list'
.........................

 -- Method: Resource.dispatch_list (self, request, **kwargs)

  A view for handling the various HTTP methods (GET/POST/PUT/DELETE)
over the entire list of resources.

  Relies on `Resource.dispatch' for the heavy-lifting.


File: django-tastypie.info,  Node: dispatch_detail,  Next: dispatch,  Prev: dispatch_list,  Up: Resource Methods

1.8.12.14 `dispatch_detail'
...........................

 -- Method: Resource.dispatch_detail (self, request, **kwargs)

  A view for handling the various HTTP methods (GET/POST/PUT/DELETE) on
a single resource.

  Relies on `Resource.dispatch' for the heavy-lifting.


File: django-tastypie.info,  Node: dispatch,  Next: remove_api_resource_names,  Prev: dispatch_detail,  Up: Resource Methods

1.8.12.15 `dispatch'
....................

 -- Method: Resource.dispatch (self, request_type, request, **kwargs)

  Handles the common operations (allowed HTTP method, authentication,
throttling, method lookup) surrounding most CRUD interactions.


File: django-tastypie.info,  Node: remove_api_resource_names,  Next: method_check,  Prev: dispatch,  Up: Resource Methods

1.8.12.16 `remove_api_resource_names'
.....................................

 -- Method: Resource.remove_api_resource_names (self, url_dict)

  Given a dictionary of regex matches from a URLconf, removes
`api_name' and/or `resource_name' if found.

  This is useful for converting URLconf matches into something suitable
for data lookup. For example:

    Model.objects.filter(**self.remove_api_resource_names(matches))



File: django-tastypie.info,  Node: method_check,  Next: is_authorized,  Prev: remove_api_resource_names,  Up: Resource Methods

1.8.12.17 `method_check'
........................

 -- Method: Resource.method_check (self, request, allowed=None)

  Ensures that the HTTP method used on the request is allowed to be
handled by the resource.

  Takes an `allowed' parameter, which should be a list of lowercase
HTTP methods to check against. Usually, this looks like:

    # The most generic lookup.
    self.method_check(request, self._meta.allowed_methods)

    # A lookup against what's allowed for list-type methods.
    self.method_check(request, self._meta.list_allowed_methods)

    # A useful check when creating a new endpoint that only handles
    # GET.
    self.method_check(request, ['get'])



File: django-tastypie.info,  Node: is_authorized,  Next: is_authenticated,  Prev: method_check,  Up: Resource Methods

1.8.12.18 `is_authorized'
.........................

 -- Method: Resource.is_authorized (self, request, object=None)

  Handles checking of permissions to see if the user has authorization
to GET, POST, PUT, or DELETE this resource.  If `object' is provided,
the authorization backend can apply additional row-level permissions
checking.


File: django-tastypie.info,  Node: is_authenticated,  Next: throttle_check,  Prev: is_authorized,  Up: Resource Methods

1.8.12.19 `is_authenticated'
............................

 -- Method: Resource.is_authenticated (self, request)

  Handles checking if the user is authenticated and dealing with
unauthenticated users.

  Mostly a hook, this uses class assigned to `authentication' from
`Resource._meta'.


File: django-tastypie.info,  Node: throttle_check,  Next: log_throttled_access,  Prev: is_authenticated,  Up: Resource Methods

1.8.12.20 `throttle_check'
..........................

 -- Method: Resource.throttle_check (self, request)

  Handles checking if the user should be throttled.

  Mostly a hook, this uses class assigned to `throttle' from
`Resource._meta'.


File: django-tastypie.info,  Node: log_throttled_access,  Next: build_bundle,  Prev: throttle_check,  Up: Resource Methods

1.8.12.21 `log_throttled_access'
................................

 -- Method: Resource.log_throttled_access (self, request)

  Handles the recording of the user's access for throttling purposes.

  Mostly a hook, this uses class assigned to `throttle' from
`Resource._meta'.


File: django-tastypie.info,  Node: build_bundle,  Next: build_filters,  Prev: log_throttled_access,  Up: Resource Methods

1.8.12.22 `build_bundle'
........................

 -- Method: Resource.build_bundle (self, obj=None, data=None,
          request=None)

  Given either an object, a data dictionary or both, builds a `Bundle'
for use throughout the `dehydrate/hydrate' cycle.

  If no object is provided, an empty object from
`Resource._meta.object_class' is created so that attempts to access
`bundle.obj' do not fail.


File: django-tastypie.info,  Node: build_filters,  Next: apply_sorting,  Prev: build_bundle,  Up: Resource Methods

1.8.12.23 `build_filters'
.........................

 -- Method: Resource.build_filters (self, filters=None)

  Allows for the filtering of applicable objects.

  _This needs to be implemented at the user level._

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: apply_sorting,  Next: get_bundle_detail_data,  Prev: build_filters,  Up: Resource Methods

1.8.12.24 `apply_sorting'
.........................

 -- Method: Resource.apply_sorting (self, obj_list, options=None)

  Allows for the sorting of objects being returned.

  _This needs to be implemented at the user level._

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: get_bundle_detail_data,  Next: get_resource_uri,  Prev: apply_sorting,  Up: Resource Methods

1.8.12.25 `get_bundle_detail_data'
..................................

 -- Method: Resource.get_bundle_detail_data (self, bundle)

  Convenience method to return the `detail_uri_name' attribute off
`bundle.obj'.

  Usually just accesses `bundle.obj.pk' by default.


File: django-tastypie.info,  Node: get_resource_uri,  Next: resource_uri_kwargs,  Prev: get_bundle_detail_data,  Up: Resource Methods

1.8.12.26 `get_resource_uri'
............................

 -- Method: Resource.get_resource_uri (self, bundle_or_obj=None,
          url_name='api_dispatch_list')

  Handles generating a resource URI.

  If the `bundle_or_obj' argument is not provided, it builds the URI
for the list endpoint.

  If the `bundle_or_obj' argument is provided, it builds the URI for
the detail endpoint.

  Return the generated URI. If that URI can not be reversed (not found
in the URLconf), it will return an empty string.


File: django-tastypie.info,  Node: resource_uri_kwargs,  Next: detail_uri_kwargs,  Prev: get_resource_uri,  Up: Resource Methods

1.8.12.27 `resource_uri_kwargs'
...............................

 -- Method: Resource.resource_uri_kwargs (self, bundle_or_obj=None)

  Handles generating a resource URI.

  If the `bundle_or_obj' argument is not provided, it builds the URI
for the list endpoint.

  If the `bundle_or_obj' argument is provided, it builds the URI for
the detail endpoint.

  Return the generated URI. If that URI can not be reversed (not found
in the URLconf), it will return `None'.


File: django-tastypie.info,  Node: detail_uri_kwargs,  Next: get_via_uri,  Prev: resource_uri_kwargs,  Up: Resource Methods

1.8.12.28 `detail_uri_kwargs'
.............................

 -- Method: Resource.detail_uri_kwargs (self, bundle_or_obj)

  This needs to be implemented at the user level.

  Given a `Bundle' or an object, it returns the extra kwargs needed to
generate a detail URI.

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: get_via_uri,  Next: full_dehydrate,  Prev: detail_uri_kwargs,  Up: Resource Methods

1.8.12.29 `get_via_uri'
.......................

 -- Method: Resource.get_via_uri (self, uri, request=None)

  This pulls apart the salient bits of the URI and populates the
resource via a `obj_get'.

  Optionally accepts a `request'.

  If you need custom behavior based on other portions of the URI,
simply override this method.


File: django-tastypie.info,  Node: full_dehydrate,  Next: dehydrate<2>,  Prev: get_via_uri,  Up: Resource Methods

1.8.12.30 `full_dehydrate'
..........................

 -- Method: Resource.full_dehydrate (self, bundle)

  Given a bundle with an object instance, extract the information from
it to populate the resource.


File: django-tastypie.info,  Node: dehydrate<2>,  Next: full_hydrate,  Prev: full_dehydrate,  Up: Resource Methods

1.8.12.31 `dehydrate'
.....................

 -- Method: Resource.dehydrate (self, bundle)

  A hook to allow a final manipulation of data once all fields/methods
have built out the dehydrated data.

  Useful if you need to access more than one dehydrated field or want
to annotate on additional data.

  Must return the modified bundle.


File: django-tastypie.info,  Node: full_hydrate,  Next: hydrate<2>,  Prev: dehydrate<2>,  Up: Resource Methods

1.8.12.32 `full_hydrate'
........................

 -- Method: Resource.full_hydrate (self, bundle)

  Given a populated bundle, distill it and turn it back into a
full-fledged object instance.


File: django-tastypie.info,  Node: hydrate<2>,  Next: hydrate_m2m,  Prev: full_hydrate,  Up: Resource Methods

1.8.12.33 `hydrate'
...................

 -- Method: Resource.hydrate (self, bundle)

  A hook to allow a final manipulation of data once all fields/methods
have built out the hydrated data.

  Useful if you need to access more than one hydrated field or want to
annotate on additional data.

  Must return the modified bundle.


File: django-tastypie.info,  Node: hydrate_m2m,  Next: build_schema,  Prev: hydrate<2>,  Up: Resource Methods

1.8.12.34 `hydrate_m2m'
.......................

 -- Method: Resource.hydrate_m2m (self, bundle)

  Populate the ManyToMany data on the instance.


File: django-tastypie.info,  Node: build_schema,  Next: dehydrate_resource_uri,  Prev: hydrate_m2m,  Up: Resource Methods

1.8.12.35 `build_schema'
........................

 -- Method: Resource.build_schema (self)

  Returns a dictionary of all the fields on the resource and some
properties about those fields.

  Used by the `schema/' endpoint to describe what will be available.


File: django-tastypie.info,  Node: dehydrate_resource_uri,  Next: generate_cache_key,  Prev: build_schema,  Up: Resource Methods

1.8.12.36 `dehydrate_resource_uri'
..................................

 -- Method: Resource.dehydrate_resource_uri (self, bundle)

  For the automatically included `resource_uri' field, dehydrate the
URI for the given bundle.

  Returns empty string if no URI can be generated.


File: django-tastypie.info,  Node: generate_cache_key,  Next: get_object_list,  Prev: dehydrate_resource_uri,  Up: Resource Methods

1.8.12.37 `generate_cache_key'
..............................

 -- Method: Resource.generate_cache_key (self, *args, **kwargs)

  Creates a unique-enough cache key.

  This is based off the current api_name/resource_name/args/kwargs.


File: django-tastypie.info,  Node: get_object_list,  Next: apply_authorization_limits,  Prev: generate_cache_key,  Up: Resource Methods

1.8.12.38 `get_object_list'
...........................

 -- Method: Resource.get_object_list (self, request)

  A hook to allow making returning the list of available objects.

  _This needs to be implemented at the user level._

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: apply_authorization_limits,  Next: can_create,  Prev: get_object_list,  Up: Resource Methods

1.8.12.39 `apply_authorization_limits'
......................................

 -- Method: Resource.apply_authorization_limits (self, request,
          object_list)

  Allows the `Authorization' class to further limit the object list.
Also a hook to customize per `Resource'.

  Calls `Authorization.apply_limits' if available.


File: django-tastypie.info,  Node: can_create,  Next: can_update,  Prev: apply_authorization_limits,  Up: Resource Methods

1.8.12.40 `can_create'
......................

 -- Method: Resource.can_create (self)

  Checks to ensure `post' is within `allowed_methods'.


File: django-tastypie.info,  Node: can_update,  Next: can_delete,  Prev: can_create,  Up: Resource Methods

1.8.12.41 `can_update'
......................

 -- Method: Resource.can_update (self)

  Checks to ensure `put' is within `allowed_methods'.

  Used when hydrating related data.


File: django-tastypie.info,  Node: can_delete,  Next: apply_filters,  Prev: can_update,  Up: Resource Methods

1.8.12.42 `can_delete'
......................

 -- Method: Resource.can_delete (self)

  Checks to ensure `delete' is within `allowed_methods'.


File: django-tastypie.info,  Node: apply_filters,  Next: obj_get_list,  Prev: can_delete,  Up: Resource Methods

1.8.12.43 `apply_filters'
.........................

 -- Method: Resource.apply_filters (self, request, applicable_filters)

  A hook to alter how the filters are applied to the object list.

  This needs to be implemented at the user level.

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: obj_get_list,  Next: cached_obj_get_list,  Prev: apply_filters,  Up: Resource Methods

1.8.12.44 `obj_get_list'
........................

 -- Method: Resource.obj_get_list (self, request=None, **kwargs)

  Fetches the list of objects available on the resource.

  _This needs to be implemented at the user level._

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: cached_obj_get_list,  Next: obj_get,  Prev: obj_get_list,  Up: Resource Methods

1.8.12.45 `cached_obj_get_list'
...............................

 -- Method: Resource.cached_obj_get_list (self, request=None, **kwargs)

  A version of `obj_get_list' that uses the cache as a means to get
commonly-accessed data faster.


File: django-tastypie.info,  Node: obj_get,  Next: cached_obj_get,  Prev: cached_obj_get_list,  Up: Resource Methods

1.8.12.46 `obj_get'
...................

 -- Method: Resource.obj_get (self, request=None, **kwargs)

  Fetches an individual object on the resource.

  _This needs to be implemented at the user level._ If the object can
not be found, this should raise a `NotFound' exception.

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: cached_obj_get,  Next: obj_create,  Prev: obj_get,  Up: Resource Methods

1.8.12.47 `cached_obj_get'
..........................

 -- Method: Resource.cached_obj_get (self, request=None, **kwargs)

  A version of `obj_get' that uses the cache as a means to get
commonly-accessed data faster.


File: django-tastypie.info,  Node: obj_create,  Next: lookup_kwargs_with_identifiers,  Prev: cached_obj_get,  Up: Resource Methods

1.8.12.48 `obj_create'
......................

 -- Method: Resource.obj_create (self, bundle, request=None, **kwargs)

  Creates a new object based on the provided data.

  _This needs to be implemented at the user level._

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: lookup_kwargs_with_identifiers,  Next: obj_update,  Prev: obj_create,  Up: Resource Methods

1.8.12.49 `lookup_kwargs_with_identifiers'
..........................................

 -- Method: Resource.lookup_kwargs_with_identifiers (self, bundle,
          kwargs)

  Kwargs here represent uri identifiers. Ex:
/repos/<user_id>/<repo_name>/ We need to turn those identifiers into
Python objects for generating lookup parameters that can find them in
the DB.


File: django-tastypie.info,  Node: obj_update,  Next: obj_delete_list,  Prev: lookup_kwargs_with_identifiers,  Up: Resource Methods

1.8.12.50 `obj_update'
......................

 -- Method: Resource.obj_update (self, bundle, request=None, **kwargs)

  Updates an existing object (or creates a new object) based on the
provided data.

  _This needs to be implemented at the user level._

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: obj_delete_list,  Next: obj_delete,  Prev: obj_update,  Up: Resource Methods

1.8.12.51 `obj_delete_list'
...........................

 -- Method: Resource.obj_delete_list (self, request=None, **kwargs)

  Deletes an entire list of objects.

  _This needs to be implemented at the user level._

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: obj_delete,  Next: create_response,  Prev: obj_delete_list,  Up: Resource Methods

1.8.12.52 `obj_delete'
......................

 -- Method: Resource.obj_delete (self, request=None, **kwargs)

  Deletes a single object.

  _This needs to be implemented at the user level._

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: create_response,  Next: is_valid,  Prev: obj_delete,  Up: Resource Methods

1.8.12.53 `create_response'
...........................

 -- Method: Resource.create_response (self, request, data,
          response_class=HttpResponse, **response_kwargs)

  Extracts the common "which-format/serialize/return-response" cycle.

  Mostly a useful shortcut/hook.


File: django-tastypie.info,  Node: is_valid,  Next: rollback,  Prev: create_response,  Up: Resource Methods

1.8.12.54 `is_valid'
....................

 -- Method: Resource.is_valid (self, bundle, request=None)

  Handles checking if the data provided by the user is valid.

  Mostly a hook, this uses class assigned to `validation' from
`Resource._meta'.

  If validation fails, an error is raised with the error messages
serialized inside it.


File: django-tastypie.info,  Node: rollback,  Next: get_list,  Prev: is_valid,  Up: Resource Methods

1.8.12.55 `rollback'
....................

 -- Method: Resource.rollback (self, bundles)

  Given the list of bundles, delete all objects pertaining to those
bundles.

  This needs to be implemented at the user level. No exceptions should
be raised if possible.

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: get_list,  Next: get_detail,  Prev: rollback,  Up: Resource Methods

1.8.12.56 `get_list'
....................

 -- Method: Resource.get_list (self, request, **kwargs)

  Returns a serialized list of resources.

  Calls `obj_get_list' to provide the data, then handles that result
set and serializes it.

  Should return a HttpResponse (200 OK).


File: django-tastypie.info,  Node: get_detail,  Next: put_list,  Prev: get_list,  Up: Resource Methods

1.8.12.57 `get_detail'
......................

 -- Method: Resource.get_detail (self, request, **kwargs)

  Returns a single serialized resource.

  Calls `cached_obj_get/obj_get' to provide the data, then handles that
result set and serializes it.

  Should return a HttpResponse (200 OK).


File: django-tastypie.info,  Node: put_list,  Next: put_detail,  Prev: get_detail,  Up: Resource Methods

1.8.12.58 `put_list'
....................

 -- Method: Resource.put_list (self, request, **kwargs)

  Replaces a collection of resources with another collection.

  Calls `delete_list' to clear out the collection then `obj_create'
with the provided the data to create the new collection.

  Return `HttpNoContent' (204 No Content) if `Meta.always_return_data =
False' (default).

  Return `HttpAccepted' (202 Accepted) if `Meta.always_return_data =
True'.


File: django-tastypie.info,  Node: put_detail,  Next: post_list,  Prev: put_list,  Up: Resource Methods

1.8.12.59 `put_detail'
......................

 -- Method: Resource.put_detail (self, request, **kwargs)

  Either updates an existing resource or creates a new one with the
provided data.

  Calls `obj_update' with the provided data first, but falls back to
`obj_create' if the object does not already exist.

  If a new resource is created, return `HttpCreated' (201 Created).  If
`Meta.always_return_data = True', there will be a populated body of
serialized data.

  If an existing resource is modified and `Meta.always_return_data =
False' (default), return `HttpNoContent' (204 No Content).  If an
existing resource is modified and `Meta.always_return_data = True',
return `HttpAccepted' (202 Accepted).


File: django-tastypie.info,  Node: post_list,  Next: post_detail,  Prev: put_detail,  Up: Resource Methods

1.8.12.60 `post_list'
.....................

 -- Method: Resource.post_list (self, request, **kwargs)

  Creates a new resource/object with the provided data.

  Calls `obj_create' with the provided data and returns a response with
the new resource's location.

  If a new resource is created, return `HttpCreated' (201 Created).  If
`Meta.always_return_data = True', there will be a populated body of
serialized data.


File: django-tastypie.info,  Node: post_detail,  Next: delete_list,  Prev: post_list,  Up: Resource Methods

1.8.12.61 `post_detail'
.......................

 -- Method: Resource.post_detail (self, request, **kwargs)

  Creates a new subcollection of the resource under a resource.

  This is not implemented by default because most people's data models
aren't self-referential.

  If a new resource is created, return `HttpCreated' (201 Created).


File: django-tastypie.info,  Node: delete_list,  Next: delete_detail,  Prev: post_detail,  Up: Resource Methods

1.8.12.62 `delete_list'
.......................

 -- Method: Resource.delete_list (self, request, **kwargs)

  Destroys a collection of resources/objects.

  Calls `obj_delete_list'.

  If the resources are deleted, return `HttpNoContent' (204 No Content).


File: django-tastypie.info,  Node: delete_detail,  Next: patch_list,  Prev: delete_list,  Up: Resource Methods

1.8.12.63 `delete_detail'
.........................

 -- Method: Resource.delete_detail (self, request, **kwargs)

  Destroys a single resource/object.

  Calls `obj_delete'.

  If the resource is deleted, return `HttpNoContent' (204 No Content).
If the resource did not exist, return `HttpNotFound' (404 Not Found).


File: django-tastypie.info,  Node: patch_list,  Next: patch_detail,  Prev: delete_detail,  Up: Resource Methods

1.8.12.64 `patch_list'
......................

 -- Method: Resource.patch_list (self, request, **kwargs)

  Updates a collection in-place.

  The exact behavior of `PATCH' to a list resource is still the matter
of some debate in REST circles, and the `PATCH' RFC isn't standard. So
the behavior this method implements (described below) is something of a
stab in the dark. It's mostly cribbed from GData, with a smattering of
ActiveResource-isms and maybe even an original idea or two.

  The `PATCH' format is one that's similar to the response returned from
a `GET' on a list resource:

    {
      "objects": [{object}, {object}, ...],
      "deleted_objects": ["URI", "URI", "URI", ...],
    }

For each object in `objects':

        * If the dict does not have a `resource_uri' key then the item
          is considered "new" and is handled like a `POST' to the
          resource list.

        * If the dict has a `resource_uri' key and the `resource_uri'
          refers to an existing resource then the item is a update;
          it's treated like a `PATCH' to the corresponding resource
          detail.

        * If the dict has a `resource_uri' but the resource _doesn't_
          exist, then this is considered to be a create-via-`PUT'.

  Each entry in `deleted_objects' referes to a resource URI of an
existing resource to be deleted; each is handled like a `DELETE' to the
relevent resource.

  In any case:

        * If there's a resource URI it _must_ refer to a resource of
          this type. It's an error to include a URI of a different
          resource.

        * `PATCH' is all or nothing. If a single sub-operation fails,
          the entire request will fail and all resources will be rolled
          back.

        * For `PATCH' to work, you *must* have `put' in your *note
          detail_allowed_methods: be. setting.

        * To delete objects via `deleted_objects' in a `PATCH' request
          you *must* have `delete' in your *note
          detail_allowed_methods: be. setting.


File: django-tastypie.info,  Node: patch_detail,  Next: get_schema,  Prev: patch_list,  Up: Resource Methods

1.8.12.65 `patch_detail'
........................

 -- Method: Resource.patch_detail (self, request, **kwargs)

  Updates a resource in-place.

  Calls `obj_update'.

  If the resource is updated, return `HttpAccepted' (202 Accepted).  If
the resource did not exist, return `HttpNotFound' (404 Not Found).


File: django-tastypie.info,  Node: get_schema,  Next: get_multiple,  Prev: patch_detail,  Up: Resource Methods

1.8.12.66 `get_schema'
......................

 -- Method: Resource.get_schema (self, request, **kwargs)

  Returns a serialized form of the schema of the resource.

  Calls `build_schema' to generate the data. This method only responds
to HTTP GET.

  Should return a HttpResponse (200 OK).


File: django-tastypie.info,  Node: get_multiple,  Prev: get_schema,  Up: Resource Methods

1.8.12.67 `get_multiple'
........................

 -- Method: Resource.get_multiple (self, request, **kwargs)

  Returns a serialized list of resources based on the identifiers from
the URL.

  Calls `obj_get' to fetch only the objects requested. This method only
responds to HTTP GET.

  Should return a HttpResponse (200 OK).


File: django-tastypie.info,  Node: ModelResource Methods,  Prev: Resource Methods,  Up: Resources

1.8.13 `ModelResource' Methods
------------------------------

A subclass of `Resource' designed to work with Django's `Models'.

  This class will introspect a given `Model' and build a field list
based on the fields found on the model (excluding relational fields).

  Given that it is aware of Django's ORM, it also handles the CRUD data
operations of the resource.

* Menu:

* should_skip_field::
* api_field_from_django_field::
* get_fields::
* check_filtering::
* build_filters: build_filters<2>.
* apply_sorting: apply_sorting<2>.
* apply_filters: apply_filters<2>.
* get_object_list: get_object_list<2>.
* obj_get_list: obj_get_list<2>.
* obj_get: obj_get<2>.
* obj_create: obj_create<2>.
* obj_update: obj_update<2>.
* obj_delete_list: obj_delete_list<2>.
* obj_delete: obj_delete<2>.
* rollback: rollback<2>.
* save_related::
* save_m2m::
* get_resource_uri: get_resource_uri<2>.


File: django-tastypie.info,  Node: should_skip_field,  Next: api_field_from_django_field,  Up: ModelResource Methods

1.8.13.1 `should_skip_field'
............................

 -- Method: ModelResource.should_skip_field (cls, field)

  _Class method_

  Given a Django model field, return if it should be included in the
contributed ApiFields.


File: django-tastypie.info,  Node: api_field_from_django_field,  Next: get_fields,  Prev: should_skip_field,  Up: ModelResource Methods

1.8.13.2 `api_field_from_django_field'
......................................

 -- Method: ModelResource.api_field_from_django_field (cls, f,
          default=CharField)

  _Class method_

  Returns the field type that would likely be associated with each
Django type.


File: django-tastypie.info,  Node: get_fields,  Next: check_filtering,  Prev: api_field_from_django_field,  Up: ModelResource Methods

1.8.13.3 `get_fields'
.....................

 -- Method: ModelResource.get_fields (cls, fields=None, excludes=None)

  _Class method_

  Given any explicit fields to include and fields to exclude, add
additional fields based on the associated model.


File: django-tastypie.info,  Node: check_filtering,  Next: build_filters<2>,  Prev: get_fields,  Up: ModelResource Methods

1.8.13.4 `check_filtering'
..........................

 -- Method: ModelResource.check_filtering (self, field_name,
          filter_type='exact', filter_bits=None)

  Given a field name, a optional filter type and an optional list of
additional relations, determine if a field can be filtered on.

  If a filter does not meet the needed conditions, it should raise an
`InvalidFilterError'.

  If the filter meets the conditions, a list of attribute names (not
field names) will be returned.


File: django-tastypie.info,  Node: build_filters<2>,  Next: apply_sorting<2>,  Prev: check_filtering,  Up: ModelResource Methods

1.8.13.5 `build_filters'
........................

 -- Method: ModelResource.build_filters (self, filters=None)

  Given a dictionary of filters, create the necessary ORM-level filters.

  Keys should be resource fields, *NOT* model fields.

  Valid values are either a list of Django filter types (i.e.
`['startswith', 'exact', 'lte']'), the `ALL' constant or the
`ALL_WITH_RELATIONS' constant.

  At the declarative level:

    filtering = {
        'resource_field_name': ['exact', 'startswith', 'endswith', 'contains'],
        'resource_field_name_2': ['exact', 'gt', 'gte', 'lt', 'lte', 'range'],
        'resource_field_name_3': ALL,
        'resource_field_name_4': ALL_WITH_RELATIONS,
        ...
    }

Accepts the filters as a dict. `None' by default, meaning no filters.


File: django-tastypie.info,  Node: apply_sorting<2>,  Next: apply_filters<2>,  Prev: build_filters<2>,  Up: ModelResource Methods

1.8.13.6 `apply_sorting'
........................

 -- Method: ModelResource.apply_sorting (self, obj_list, options=None)

  Given a dictionary of options, apply some ORM-level sorting to the
provided `QuerySet'.

  Looks for the `order_by' key and handles either ascending (just the
field name) or descending (the field name with a `-' in front).

  The field name should be the resource field, *NOT* model field.


File: django-tastypie.info,  Node: apply_filters<2>,  Next: get_object_list<2>,  Prev: apply_sorting<2>,  Up: ModelResource Methods

1.8.13.7 `apply_filters'
........................

 -- Method: ModelResource.apply_filters (self, request,
          applicable_filters)

  An ORM-specific implementation of `apply_filters'.

  The default simply applies the `applicable_filters' as `**kwargs',
but should make it possible to do more advanced things.


File: django-tastypie.info,  Node: get_object_list<2>,  Next: obj_get_list<2>,  Prev: apply_filters<2>,  Up: ModelResource Methods

1.8.13.8 `get_object_list'
..........................

 -- Method: ModelResource.get_object_list (self, request)

  A ORM-specific implementation of `get_object_list'.

  Returns a `QuerySet' that may have been limited by other overrides.


File: django-tastypie.info,  Node: obj_get_list<2>,  Next: obj_get<2>,  Prev: get_object_list<2>,  Up: ModelResource Methods

1.8.13.9 `obj_get_list'
.......................

 -- Method: ModelResource.obj_get_list (self, filters=None, **kwargs)

  A ORM-specific implementation of `obj_get_list'.

  Takes an optional `filters' dictionary, which can be used to narrow
the query.


File: django-tastypie.info,  Node: obj_get<2>,  Next: obj_create<2>,  Prev: obj_get_list<2>,  Up: ModelResource Methods

1.8.13.10 `obj_get'
...................

 -- Method: ModelResource.obj_get (self, **kwargs)

  A ORM-specific implementation of `obj_get'.

  Takes optional `kwargs', which are used to narrow the query to find
the instance.


File: django-tastypie.info,  Node: obj_create<2>,  Next: obj_update<2>,  Prev: obj_get<2>,  Up: ModelResource Methods

1.8.13.11 `obj_create'
......................

 -- Method: ModelResource.obj_create (self, bundle, **kwargs)

  A ORM-specific implementation of `obj_create'.


File: django-tastypie.info,  Node: obj_update<2>,  Next: obj_delete_list<2>,  Prev: obj_create<2>,  Up: ModelResource Methods

1.8.13.12 `obj_update'
......................

 -- Method: ModelResource.obj_update (self, bundle, **kwargs)

  A ORM-specific implementation of `obj_update'.


File: django-tastypie.info,  Node: obj_delete_list<2>,  Next: obj_delete<2>,  Prev: obj_update<2>,  Up: ModelResource Methods

1.8.13.13 `obj_delete_list'
...........................

 -- Method: ModelResource.obj_delete_list (self, **kwargs)

  A ORM-specific implementation of `obj_delete_list'.

  Takes optional `kwargs', which can be used to narrow the query.


File: django-tastypie.info,  Node: obj_delete<2>,  Next: rollback<2>,  Prev: obj_delete_list<2>,  Up: ModelResource Methods

1.8.13.14 `obj_delete'
......................

 -- Method: ModelResource.obj_delete (self, **kwargs)

  A ORM-specific implementation of `obj_delete'.

  Takes optional `kwargs', which are used to narrow the query to find
the instance.


File: django-tastypie.info,  Node: rollback<2>,  Next: save_related,  Prev: obj_delete<2>,  Up: ModelResource Methods

1.8.13.15 `rollback'
....................

 -- Method: ModelResource.rollback (self, bundles)

  A ORM-specific implementation of `rollback'.

  Given the list of bundles, delete all models pertaining to those
bundles.


File: django-tastypie.info,  Node: save_related,  Next: save_m2m,  Prev: rollback<2>,  Up: ModelResource Methods

1.8.13.16 `save_related'
........................

 -- Method: ModelResource.save_related (self, bundle)

  Handles the saving of related non-M2M data.

  Calling assigning `child.parent = parent' & then calling `Child.save'
isn't good enough to make sure the `parent' is saved.

  To get around this, we go through all our related fields & call
`save' on them if they have related, non-M2M data.  M2M data is handled
by the `ModelResource.save_m2m' method.


File: django-tastypie.info,  Node: save_m2m,  Next: get_resource_uri<2>,  Prev: save_related,  Up: ModelResource Methods

1.8.13.17 `save_m2m'
....................

 -- Method: ModelResource.save_m2m (self, bundle)

  Handles the saving of related M2M data.

  Due to the way Django works, the M2M data must be handled after the
main instance, which is why this isn't a part of the main `save' bits.

  Currently slightly inefficient in that it will clear out the whole
relation and recreate the related data as needed.


File: django-tastypie.info,  Node: get_resource_uri<2>,  Prev: save_m2m,  Up: ModelResource Methods

1.8.13.18 `get_resource_uri'
............................

 -- Method: ModelResource.get_resource_uri (self, bundle_or_obj)

  Handles generating a resource URI for a single resource.

  Uses the model's `pk' in order to create the URI.


File: django-tastypie.info,  Node: Bundles,  Next: Api,  Prev: Resources,  Up: Welcome to Tastypie!

1.9 Bundles
===========

* Menu:

* What Are Bundles?::
* Attributes::


File: django-tastypie.info,  Node: What Are Bundles?,  Next: Attributes,  Up: Bundles

1.9.1 What Are Bundles?
-----------------------

Bundles are a small abstraction that allow Tastypie to pass data between
resources. This allows us not to depend on passing `request' to every
single method (especially in places where this would be overkill). It
also allows resources to work with data coming into the application
paired together with an unsaved instance of the object in question.
Finally, it aids in keeping Tastypie more thread-safe.

  Think of it as package of user data & an object instance (either of
which are optionally present).


File: django-tastypie.info,  Node: Attributes,  Prev: What Are Bundles?,  Up: Bundles

1.9.2 Attributes
----------------

All data within a bundle can be optional, especially depending on how
it's being used. If you write custom code using `Bundle', make sure
appropriate guards are in place.

* Menu:

* obj::
* data::
* request::
* related_obj::
* related_name::


File: django-tastypie.info,  Node: obj,  Next: data,  Up: Attributes

1.9.2.1 `obj'
.............

Either a Python object or `None'.

  Usually a Django model, though it may/may not have been saved already.


File: django-tastypie.info,  Node: data,  Next: request,  Prev: obj,  Up: Attributes

1.9.2.2 `data'
..............

Always a plain Python dictionary of data. If not provided, it will be
empty.


File: django-tastypie.info,  Node: request,  Next: related_obj,  Prev: data,  Up: Attributes

1.9.2.3 `request'
.................

Either the Django `request' that's part of the issued request or an
empty `HttpRequest' if it wasn't provided.


File: django-tastypie.info,  Node: related_obj,  Next: related_name,  Prev: request,  Up: Attributes

1.9.2.4 `related_obj'
.....................

Either another "parent" Python object or `None'.

  Useful when handling one-to-many relations. Used in conjunction with
`related_name'.


File: django-tastypie.info,  Node: related_name,  Prev: related_obj,  Up: Attributes

1.9.2.5 `related_name'
......................

Either a Python string name of an attribute or `None'.

  Useful when handling one-to-many relations. Used in conjunction with
`related_obj'.


File: django-tastypie.info,  Node: Api,  Next: Resource Fields,  Prev: Bundles,  Up: Welcome to Tastypie!

1.10 Api
========

In terms of a REST-style architecture, the "api" is a collection of
resources.  In Tastypie, the `Api' gathers together the `Resources' &
provides a nice way to use them as a set. It handles many of the
URLconf details for you, provides a helpful "top-level" view to show
what endpoints are available & some extra URL resolution juice.

* Menu:

* Quick Start: Quick Start<2>.
* Api Methods::


File: django-tastypie.info,  Node: Quick Start<2>,  Next: Api Methods,  Up: Api

1.10.1 Quick Start
------------------

A sample api definition might look something like (usually located in a
URLconf):

    from tastypie.api import Api
    from myapp.api.resources import UserResource, EntryResource

    v1_api = Api(api_name='v1')
    v1_api.register(UserResource())
    v1_api.register(EntryResource())

    # Standard bits...
    urlpatterns = patterns('',
        (r'^api/', include(v1_api.urls)),
    )



File: django-tastypie.info,  Node: Api Methods,  Prev: Quick Start<2>,  Up: Api

1.10.2 `Api' Methods
--------------------

Implements a registry to tie together the various resources that make up
an API.

  Especially useful for navigation, HATEOAS and for providing multiple
versions of your API.

  Optionally supplying `api_name' allows you to name the API. Generally,
this is done with version numbers (i.e. `v1', `v2', etc.) but can be
named any string.

* Menu:

* register::
* unregister::
* canonical_resource_for::
* urls: urls<2>.
* top_level::


File: django-tastypie.info,  Node: register,  Next: unregister,  Up: Api Methods

1.10.2.1 `register'
...................

 -- Method: Api.register(self, resource, canonical=True):

  Registers an instance of a `Resource' subclass with the API.

  Optionally accept a `canonical' argument, which indicates that the
resource being registered is the canonical variant. Defaults to `True'.


File: django-tastypie.info,  Node: unregister,  Next: canonical_resource_for,  Prev: register,  Up: Api Methods

1.10.2.2 `unregister'
.....................

 -- Method: Api.unregister(self, resource_name):

  If present, unregisters a resource from the API.


File: django-tastypie.info,  Node: canonical_resource_for,  Next: urls<2>,  Prev: unregister,  Up: Api Methods

1.10.2.3 `canonical_resource_for'
.................................

 -- Method: Api.canonical_resource_for(self, resource_name):

  Returns the canonical resource for a given `resource_name'.

* Menu:

* override_urls: override_urls<2>.
* prepend_urls: prepend_urls<2>.


File: django-tastypie.info,  Node: override_urls<2>,  Next: prepend_urls<2>,  Up: canonical_resource_for

1.10.2.4 `override_urls'
........................

 -- Method: Api.override_urls(self):

  Deprecated. Will be removed by v1.0.0. Please use `Api.prepend_urls'
instead.


File: django-tastypie.info,  Node: prepend_urls<2>,  Prev: override_urls<2>,  Up: canonical_resource_for

1.10.2.5 `prepend_urls'
.......................

 -- Method: Api.prepend_urls(self):

  A hook for adding your own URLs or matching before the default URLs.
Useful for adding custom endpoints or overriding the built-in ones.

  Should return a list of individual URLconf lines (*NOT* wrapped in
`patterns').


File: django-tastypie.info,  Node: urls<2>,  Next: top_level,  Prev: canonical_resource_for,  Up: Api Methods

1.10.2.6 `urls'
...............

 -- Method: Api.urls(self):

  _Property_

  Provides URLconf details for the `Api' and all registered `Resources'
beneath it.


File: django-tastypie.info,  Node: top_level,  Prev: urls<2>,  Up: Api Methods

1.10.2.7 `top_level'
....................

 -- Method: Api.top_level(self, request, api_name=None):

  A view that returns a serialized list of all resources registers to
the `Api'. Useful for discovery.


File: django-tastypie.info,  Node: Resource Fields,  Next: Caching,  Prev: Api,  Up: Welcome to Tastypie!

1.11 Resource Fields
====================

When designing an API, an important component is defining the
representation of the data you're presenting. Like Django models, you
can control the representation of a `Resource' using fields. There are
a variety of fields for various types of data.

* Menu:

* Quick Start: Quick Start<3>.
* Standard Data Fields::
* Relationship Fields::


File: django-tastypie.info,  Node: Quick Start<3>,  Next: Standard Data Fields,  Up: Resource Fields

1.11.1 Quick Start
------------------

For the impatient:

    from tastypie import fields, utils
    from tastypie.resources import Resource
    from myapp.api.resources import ProfileResource, NoteResource


    class PersonResource(Resource):
        name = fields.CharField(attribute='name')
        age = fields.IntegerField(attribute='years_old', null=True)
        created = fields.DateTimeField(readonly=True, help_text='When the person was created', default=utils.now)
        is_active = fields.BooleanField(default=True)
        profile = fields.ToOneField(ProfileResource, 'profile')
        notes = fields.ToManyField(NoteResource, 'notes', full=True)



File: django-tastypie.info,  Node: Standard Data Fields,  Next: Relationship Fields,  Prev: Quick Start<3>,  Up: Resource Fields

1.11.2 Standard Data Fields
---------------------------

All standard data fields have a common base class `ApiField' which
handles the basic implementation details.

     Note: You should not use the `ApiField' class directly. Please use
     one of the subclasses that is more correct for your data.

* Menu:

* Common Field Options::
* Field Types::
* BooleanField::
* CharField::
* DateField::
* DateTimeField::
* DecimalField::
* DictField::
* FileField::
* FloatField::
* IntegerField::
* ListField::
* TimeField::

Common Field Options

* attribute::
* default::
* null::
* blank::
* readonly::
* unique::
* help_text::


File: django-tastypie.info,  Node: Common Field Options,  Next: Field Types,  Up: Standard Data Fields

1.11.2.1 Common Field Options
.............................

All `ApiField' objects accept the following options.

* Menu:

* attribute::
* default::
* null::
* blank::
* readonly::
* unique::
* help_text::


File: django-tastypie.info,  Node: attribute,  Next: default,  Up: Common Field Options

1.11.2.2 `attribute'
....................

 -- Attribute: ApiField.attribute

  A string naming an instance attribute of the object wrapped by the
Resource. The attribute will be accessed during the `dehydrate' or or
written during the `hydrate'.

  Defaults to `None', meaning data will be manually accessed.


File: django-tastypie.info,  Node: default,  Next: null,  Prev: attribute,  Up: Common Field Options

1.11.2.3 `default'
..................

 -- Attribute: ApiField.default

  Provides default data when the object being `dehydrated'/`hydrated'
has no data on the field.

  Defaults to `tastypie.fields.NOT_PROVIDED'.


File: django-tastypie.info,  Node: null,  Next: blank,  Prev: default,  Up: Common Field Options

1.11.2.4 `null'
...............

 -- Attribute: ApiField.null

  Indicates whether or not a `None' is allowable data on the field.
Defaults to `False'.


File: django-tastypie.info,  Node: blank,  Next: readonly,  Prev: null,  Up: Common Field Options

1.11.2.5 `blank'
................

 -- Attribute: ApiField.blank

  Indicates whether or not data may be omitted on the field. Defaults
to `False'.

  This is useful for allowing the user to omit data that you can
populate based on the request, such as the `user' or `site' to
associate a record with.


File: django-tastypie.info,  Node: readonly,  Next: unique,  Prev: blank,  Up: Common Field Options

1.11.2.6 `readonly'
...................

 -- Attribute: ApiField.readonly

  Indicates whether the field is used during the `hydrate' or not.
Defaults to `False'.


File: django-tastypie.info,  Node: unique,  Next: help_text,  Prev: readonly,  Up: Common Field Options

1.11.2.7 `unique'
.................

 -- Attribute: ApiField.unique

  Indicates whether the field is a unique identifier for the object.


File: django-tastypie.info,  Node: help_text,  Prev: unique,  Up: Common Field Options

1.11.2.8 `help_text'
....................

 -- Attribute: ApiField.help_text

  A human-readable description of the field exposed at the schema level.
Defaults to the per-Field definition.


File: django-tastypie.info,  Node: Field Types,  Next: BooleanField,  Prev: Common Field Options,  Up: Standard Data Fields

1.11.2.9 Field Types
....................


File: django-tastypie.info,  Node: BooleanField,  Next: CharField,  Prev: Field Types,  Up: Standard Data Fields

1.11.2.10 `BooleanField'
........................

A boolean field.

  Covers both `models.BooleanField' and `models.NullBooleanField'.


File: django-tastypie.info,  Node: CharField,  Next: DateField,  Prev: BooleanField,  Up: Standard Data Fields

1.11.2.11 `CharField'
.....................

A text field of arbitrary length.

  Covers both `models.CharField' and `models.TextField'.


File: django-tastypie.info,  Node: DateField,  Next: DateTimeField,  Prev: CharField,  Up: Standard Data Fields

1.11.2.12 `DateField'
.....................

A date field.


File: django-tastypie.info,  Node: DateTimeField,  Next: DecimalField,  Prev: DateField,  Up: Standard Data Fields

1.11.2.13 `DateTimeField'
.........................

A datetime field.


File: django-tastypie.info,  Node: DecimalField,  Next: DictField,  Prev: DateTimeField,  Up: Standard Data Fields

1.11.2.14 `DecimalField'
........................

A decimal field.


File: django-tastypie.info,  Node: DictField,  Next: FileField,  Prev: DecimalField,  Up: Standard Data Fields

1.11.2.15 `DictField'
.....................

A dictionary field.


File: django-tastypie.info,  Node: FileField,  Next: FloatField,  Prev: DictField,  Up: Standard Data Fields

1.11.2.16 `FileField'
.....................

A file-related field.

  Covers both `models.FileField' and `models.ImageField'.


File: django-tastypie.info,  Node: FloatField,  Next: IntegerField,  Prev: FileField,  Up: Standard Data Fields

1.11.2.17 `FloatField'
......................

A floating point field.


File: django-tastypie.info,  Node: IntegerField,  Next: ListField,  Prev: FloatField,  Up: Standard Data Fields

1.11.2.18 `IntegerField'
........................

An integer field.

  Covers `models.IntegerField', `models.PositiveIntegerField',
`models.PositiveSmallIntegerField' and `models.SmallIntegerField'.


File: django-tastypie.info,  Node: ListField,  Next: TimeField,  Prev: IntegerField,  Up: Standard Data Fields

1.11.2.19 `ListField'
.....................

A list field.


File: django-tastypie.info,  Node: TimeField,  Prev: ListField,  Up: Standard Data Fields

1.11.2.20 `TimeField'
.....................

A time field.


File: django-tastypie.info,  Node: Relationship Fields,  Prev: Standard Data Fields,  Up: Resource Fields

1.11.3 Relationship Fields
--------------------------

Provides access to data that is related within the database.

  The `RelatedField' base class is not intended for direct use but
provides functionality that `ToOneField' and `ToManyField' build upon.

  The contents of this field actually point to another `Resource',
rather than the related object. This allows the field to represent its
data in different ways.

  The abstractions based around this are "leaky" in that, unlike the
other fields provided by `tastypie', these fields don't handle
arbitrary objects very well. The subclasses use Django's ORM layer to
make things go, though there is no ORM-specific code at this level.

* Menu:

* Common Field Options: Common Field Options<2>.
* Field Types: Field Types<2>.

Common Field Options

* to::
* full::
* related_name: related_name<2>.

Field Types

* ToOneField::
* OneToOneField::
* ForeignKey::
* ToManyField::
* ManyToManyField::
* OneToManyField::


File: django-tastypie.info,  Node: Common Field Options<2>,  Next: Field Types<2>,  Up: Relationship Fields

1.11.3.1 Common Field Options
.............................

In addition to the common attributes for all `ApiField', relationship
fields accept the following.

* Menu:

* to::
* full::
* related_name: related_name<2>.


File: django-tastypie.info,  Node: to,  Next: full,  Up: Common Field Options<2>

1.11.3.2 `to'
.............

 -- Attribute: RelatedField.to

  The `to' argument should point to a `Resource' class, NOT to a
`Model'.  Required.


File: django-tastypie.info,  Node: full,  Next: related_name<2>,  Prev: to,  Up: Common Field Options<2>

1.11.3.3 `full'
...............

 -- Attribute: RelatedField.full

  Indicates how the related `Resource' will appear post-`dehydrate'. If
`False', the related `Resource' will appear as a URL to the endpoint of
that resource. If `True', the result of the sub-resource's `dehydrate'
will be included in full.


File: django-tastypie.info,  Node: related_name<2>,  Prev: full,  Up: Common Field Options<2>

1.11.3.4 `related_name'
.......................

 -- Attribute: RelatedField.related_name

  Used to help automatically populate reverse relations when creating
data.  Defaults to `None'.

  In order for this option to work correctly, there must be a field on
the other `Resource' with this as an `attribute/instance_name'. Usually
this just means adding a reflecting `ToOneField' pointing back.

  Example:

    class EntryResource(ModelResource):
        authors = fields.ToManyField('path.to.api.resources.AuthorResource', 'author_set', related_name='entry')

        class Meta:
            queryset = Entry.objects.all()
            resource_name = 'entry'

    class AuthorResource(ModelResource):
        entry = fields.ToOneField(EntryResource, 'entry')

        class Meta:
            queryset = Author.objects.all()
            resource_name = 'author'



File: django-tastypie.info,  Node: Field Types<2>,  Prev: Common Field Options<2>,  Up: Relationship Fields

1.11.3.5 Field Types
....................

* Menu:

* ToOneField::
* OneToOneField::
* ForeignKey::
* ToManyField::
* ManyToManyField::
* OneToManyField::


File: django-tastypie.info,  Node: ToOneField,  Next: OneToOneField,  Up: Field Types<2>

1.11.3.6 `ToOneField'
.....................

Provides access to related data via foreign key.

  This subclass requires Django's ORM layer to work properly.


File: django-tastypie.info,  Node: OneToOneField,  Next: ForeignKey,  Prev: ToOneField,  Up: Field Types<2>

1.11.3.7 `OneToOneField'
........................

An alias to `ToOneField' for those who prefer to mirror
`django.db.models'.


File: django-tastypie.info,  Node: ForeignKey,  Next: ToManyField,  Prev: OneToOneField,  Up: Field Types<2>

1.11.3.8 `ForeignKey'
.....................

An alias to `ToOneField' for those who prefer to mirror
`django.db.models'.


File: django-tastypie.info,  Node: ToManyField,  Next: ManyToManyField,  Prev: ForeignKey,  Up: Field Types<2>

1.11.3.9 `ToManyField'
......................

Provides access to related data via a join table.

  This subclass requires Django's ORM layer to work properly.

  This field also has special behavior when dealing with `attribute' in
that it can take a callable. For instance, if you need to filter the
reverse relation, you can do something like:

    subjects = fields.ToManyField(SubjectResource, attribute=lambda bundle: Subject.objects.filter(notes=bundle.obj, name__startswith='Personal'))

Note that the `hydrate' portions of this field are quite different than
any other field. `hydrate_m2m' actually handles the data and relations.
This is due to the way Django implements M2M relationships.


File: django-tastypie.info,  Node: ManyToManyField,  Next: OneToManyField,  Prev: ToManyField,  Up: Field Types<2>

1.11.3.10 `ManyToManyField'
...........................

An alias to `ToManyField' for those who prefer to mirror
`django.db.models'.


File: django-tastypie.info,  Node: OneToManyField,  Prev: ManyToManyField,  Up: Field Types<2>

1.11.3.11 `OneToManyField'
..........................

An alias to `ToManyField' for those who prefer to mirror
`django.db.models'.


File: django-tastypie.info,  Node: Caching,  Next: Validation,  Prev: Resource Fields,  Up: Welcome to Tastypie!

1.12 Caching
============

When adding an API to your site, it's important to understand that most
consumers of the API will not be people, but instead machines. This
means that the traditional "fetch-read-click" cycle is no longer
measured in minutes but in seconds or milliseconds.

  As such, caching is a very important part of the deployment of your
API.  Tastypie ships with two classes to make working with caching
easier. These caches store at the object level, reducing access time on
the database.

  However, it's worth noting that these do _NOT_ cache serialized
representations.  For heavy traffic, we'd encourage the use of a
caching proxy, especially Varnish(1), as it shines under this kind of
usage. It's far faster than Django views and already neatly handles
most situations.

  The first section below demonstrates how to cache at the Django
level, reducing the amount of work required to satisfy a request. In
many cases your API serves web browsers or is behind by a caching proxy
such as Varnish(2) and it is possible to set HTTP Cache-Control headers
to avoid issuing a request to your application at all. This is
discussed in the *note HTTP Cache-Control: 1c4. section below.

* Menu:

* Usage::
* Caching Options::
* Implementing Your Own Cache::
* HTTP Cache-Control::
* HTTP Vary::

  ---------- Footnotes ----------

  (1) http://www.varnish-cache.org/

  (2) http://www.varnish-cache.org/


File: django-tastypie.info,  Node: Usage,  Next: Caching Options,  Up: Caching

1.12.1 Usage
------------

Using these classes is simple. Simply provide them (or your own class)
as a `Meta' option to the `Resource' in question. For example:

    from django.contrib.auth.models import User
    from tastypie.cache import SimpleCache
    from tastypie.resources import ModelResource


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']
            # Add it here.
            cache = SimpleCache(timeout=10)



File: django-tastypie.info,  Node: Caching Options,  Next: Implementing Your Own Cache,  Prev: Usage,  Up: Caching

1.12.2 Caching Options
----------------------

Tastypie ships with the following `Cache' classes:

* Menu:

* NoCache::
* SimpleCache::


File: django-tastypie.info,  Node: NoCache,  Next: SimpleCache,  Up: Caching Options

1.12.2.1 `NoCache'
..................

The no-op cache option, this does no caching but serves as an
api-compatible plug. Very useful for development.


File: django-tastypie.info,  Node: SimpleCache,  Prev: NoCache,  Up: Caching Options

1.12.2.2 `SimpleCache'
......................

This option does basic object caching, attempting to find the object in
the cache & writing the object to the cache. It uses Django's current
`CACHE_BACKEND' to store cached data. The constructor receive a
`timeout' parameter to control per-resource the default timeout for the
cache.


File: django-tastypie.info,  Node: Implementing Your Own Cache,  Next: HTTP Cache-Control,  Prev: Caching Options,  Up: Caching

1.12.3 Implementing Your Own Cache
----------------------------------

Implementing your own `Cache' class is as simple as subclassing
`NoCache' and overriding the `get' & `set' methods. For example, a
json-backed cache might look like:

    import json
    from django.conf import settings
    from tastypie.cache import NoCache


    class JSONCache(NoCache):
        def _load(self):
            data_file = open(settings.TASTYPIE_JSON_CACHE, 'r')
            return json.load(data_file)

        def _save(self, data):
            data_file = open(settings.TASTYPIE_JSON_CACHE, 'w')
            return json.dump(data, data_file)

        def get(self, key):
            data = self._load()
            return data.get(key, None)

        def set(self, key, value, timeout=60):
            data = self._load()
            data[key] = value
            self._save(data)

Note that this is _NOT_ necessarily an optimal solution, but is simply
demonstrating how one might go about implementing your own `Cache'.


File: django-tastypie.info,  Node: HTTP Cache-Control,  Next: HTTP Vary,  Prev: Implementing Your Own Cache,  Up: Caching

1.12.4 HTTP Cache-Control
-------------------------

The HTTP protocol defines a `Cache-Control' header, which can be used
to tell clients and intermediaries who is allowed to cache a response
and for how long.  Mark Nottingham has a general caching
introduction(1) and the Django cache documentation(2) describes how to
set caching-related headers in your code. The range of possible options
is beyond the scope of this documentation, but it's important to know
that, by default, Tastypie will prevent responses from being cached to
ensure that clients always receive current information.

  To override the default `no-cache' response, your `Resource' should
ensure that your `cache' class implements `cache_control'. The default
`SimpleCache' does this by default. It uses the timeout passed to the
initialization as the `max-age' and `s-maxage'. By default, it does not
claim to know if the results should be public or privately cached but
this can be changed by passing either a `public=True' or a
`private=True' to the initialization of the `SimpleClass'.

  Behind the scenes, the return value from the `cache_control' method
is passed to the cache_control(3) helper provided by Django. If you
wish to add your own methods to it, you can do so by overloading the
`cache_control' method and modifying the dictionary it returns.:

    from tastypie.cache import SimpleCache

    class NoTransformCache(SimpleCache):

        def cache_control(self):
            control = super(NoTransformCache, self).cache_control()
            control.update({"no_transform": True})
            return control


  ---------- Footnotes ----------

  (1) http://www.mnot.net/cache_docs/

  (2)
https://docs.djangoproject.com/en/dev/topics/cache/#controlling-cache-using-other-headers

  (3)
https://docs.djangoproject.com/en/dev/topics/cache/?from=olddocs#controlling-cache-using-other-headers


File: django-tastypie.info,  Node: HTTP Vary,  Prev: HTTP Cache-Control,  Up: Caching

1.12.5 HTTP Vary
----------------

The HTTP protocol defines a `Vary' header, which can be used to tell
clients and intermediaries on what headers your response varies. This
allows clients to store a correct response for each type. By default,
Tastypie will send the `Vary: Accept' header so that a seperate
response is cached for each `Content-Type'. However, if you wish to
change this, simply pass a list to the `varies' kwarg of any `Cache'
class.

  It is important to note that if a list is passed, Tastypie not
automatically include the `Vary: Accept' and you should include it as a
member of your list.:

    class ExampleResource(Resource):
        class Meta:
            cache = SimpleCache(varies=["Accept", "Cookie"])



File: django-tastypie.info,  Node: Validation,  Next: Authentication / Authorization,  Prev: Caching,  Up: Welcome to Tastypie!

1.13 Validation
===============

Validation allows you to ensure that the data being submitted by the
user is appropriate for storage. This can range from simple type
checking on up to complex validation that compares different fields
together.

  If the data is valid, an empty dictionary is returned and processing
continues as normal. If the data is invalid, a dictionary of error
messages (keys being the field names, values being a list of error
messages). This will be immediately returned to the user, serialized in
the format they requested.

* Menu:

* Usage: Usage<2>.
* Validation Options::
* Implementing Your Own Validation::


File: django-tastypie.info,  Node: Usage<2>,  Next: Validation Options,  Up: Validation

1.13.1 Usage
------------

Using these classes is simple. Simply provide them (or your own class)
as a `Meta' option to the `Resource' in question. For example:

    from django.contrib.auth.models import User
    from tastypie.validation import Validation
    from tastypie.resources import ModelResource


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']
            # Add it here.
            validation = Validation()



File: django-tastypie.info,  Node: Validation Options,  Next: Implementing Your Own Validation,  Prev: Usage<2>,  Up: Validation

1.13.2 Validation Options
-------------------------

Tastypie ships with the following `Validation' classes:

* Menu:

* Validation: Validation<2>.
* FormValidation::
* CleanedDataFormValidation::


File: django-tastypie.info,  Node: Validation<2>,  Next: FormValidation,  Up: Validation Options

1.13.2.1 `Validation'
.....................

The no-op validation option, the data submitted is always considered to
be valid.

  This is the default class hooked up to `Resource/ModelResource'.


File: django-tastypie.info,  Node: FormValidation,  Next: CleanedDataFormValidation,  Prev: Validation<2>,  Up: Validation Options

1.13.2.2 `FormValidation'
.........................

A more complex form of validation, this class accepts a `form_class'
argument to its constructor. You supply a Django `Form' (or
`ModelForm', though `save' will never get called) and Tastypie will
verify the `data' in the `Bundle' against the form.

  This class *DOES NOT* alter the data sent, only verifies it. If you
want to alter the data, please use the `CleanDataFormValidation' class
instead.

     Warning: Data in the bundle must line up with the fieldnames in
     the `Form'. If they do not, you'll need to either munge the data
     or change your form.

  Usage looks like:

    from django import forms

    class NoteForm(forms.Form):
        title = forms.CharField(max_length=100)
        slug = forms.CharField(max_length=50)
        content = forms.CharField(required=False, widget=forms.Textarea)
        is_active = forms.BooleanField()

    form = FormValidation(form_class=NoteForm)



File: django-tastypie.info,  Node: CleanedDataFormValidation,  Prev: FormValidation,  Up: Validation Options

1.13.2.3 `CleanedDataFormValidation'
....................................

Similar to the `FormValidation' class, this uses a Django `Form' to
handle validation. *However*, it will use the `form.cleaned_data' to
replace the `bundle' data sent by user! Usage is identical to
`FormValidation'.


File: django-tastypie.info,  Node: Implementing Your Own Validation,  Prev: Validation Options,  Up: Validation

1.13.3 Implementing Your Own Validation
---------------------------------------

Implementing your own `Validation' classes is a simple process. The
constructor can take whatever `**kwargs' it needs (if any). The only
other method to implement is the `is_valid' method:

    from tastypie.validation import Validation


    class AwesomeValidation(Validation):
        def is_valid(self, bundle, request=None):
            if not bundle.data:
                return {'__all__': 'Not quite what I had in mind.'}

            errors = {}

            for key, value in bundle.data.items():
                if not isinstance(value, basestring):
                    continue

                if not 'awesome' in value:
                    errors[key] = ['NOT ENOUGH AWESOME. NEEDS MORE.']

            return errors

Under this validation, every field that's a string is checked for the
word 'awesome'. If it's not in the string, it's an error.


File: django-tastypie.info,  Node: Authentication / Authorization,  Next: Serialization,  Prev: Validation,  Up: Welcome to Tastypie!

1.14 Authentication / Authorization
===================================

Authentication & authorization make up the components needed to verify
who a certain user is and to validate their access to the API and what
they can do with it.

  Authentication answers the question "Who is this person?" This
usually involves requiring credentials, such as an API key or
username/password or oAuth tokens.

  Authorization answers the question "Is permission granted for this
user to take this action?" This usually involves checking permissions
such as Create/Read/Update/Delete access, or putting limits on what
data the user can access.

* Menu:

* Usage: Usage<3>.
* Authentication Options::
* Authorization Options::
* Implementing Your Own Authentication/Authorization::


File: django-tastypie.info,  Node: Usage<3>,  Next: Authentication Options,  Up: Authentication / Authorization

1.14.1 Usage
------------

Using these classes is simple. Simply provide them (or your own class)
as a `Meta' option to the `Resource' in question. For example:

    from django.contrib.auth.models import User
    from tastypie.authentication import BasicAuthentication
    from tastypie.authorization import DjangoAuthorization
    from tastypie.resources import ModelResource


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']
            # Add it here.
            authentication = BasicAuthentication()
            authorization = DjangoAuthorization()



File: django-tastypie.info,  Node: Authentication Options,  Next: Authorization Options,  Prev: Usage<3>,  Up: Authentication / Authorization

1.14.2 Authentication Options
-----------------------------

Tastypie ships with the following `Authentication' classes:

* Menu:

* Authentication::
* BasicAuthentication::
* ApiKeyAuthentication::
* SessionAuthentication::
* DigestAuthentication::
* OAuthAuthentication::
* MultiAuthentication::


File: django-tastypie.info,  Node: Authentication,  Next: BasicAuthentication,  Up: Authentication Options

1.14.2.1 `Authentication'
.........................

The no-op authentication option, the client is always allowed through.
Very useful for development and read-only APIs.


File: django-tastypie.info,  Node: BasicAuthentication,  Next: ApiKeyAuthentication,  Prev: Authentication,  Up: Authentication Options

1.14.2.2 `BasicAuthentication'
..............................

This authentication scheme uses HTTP Basic Auth to check a user's
credentials.  The username is their `django.contrib.auth.models.User'
username (assuming it is present) and their password should also
correspond to that entry.

     Warning: If you're using Apache & `mod_wsgi', you will need to
     enable `WSGIPassAuthorization On'. See this post(1) for details.

  ---------- Footnotes ----------

  (1) http://www.nerdydork.com/basic-authentication-on-mod_wsgi.html


File: django-tastypie.info,  Node: ApiKeyAuthentication,  Next: SessionAuthentication,  Prev: BasicAuthentication,  Up: Authentication Options

1.14.2.3 `ApiKeyAuthentication'
...............................

As an alternative to requiring sensitive data like a password, the
`ApiKeyAuthentication' allows you to collect just username & a
machine-generated api key. Tastypie ships with a special `Model' just
for this purpose, so you'll need to ensure `tastypie' is in
`INSTALLED_APPS'.

  To use this mechanism, the end user can either specify an
`Authorization' header or pass the `username/api_key' combination as
`GET/POST' parameters.  Examples:

    # As a header
    # Format is ``Authorization: ApiKey <username>:<api_key>
    Authorization: ApiKey daniel:204db7bcfafb2deb7506b89eb3b9b715b09905c8

    # As GET params
    http://127.0.0.1:8000/api/v1/entries/?username=daniel&api_key=204db7bcfafb2deb7506b89eb3b9b715b09905c8

Tastypie includes a signal function you can use to auto-create `ApiKey'
objects. Hooking it up looks like:

    from django.contrib.auth.models import User
    from django.db import models
    from tastypie.models import create_api_key

    models.signals.post_save.connect(create_api_key, sender=User)


     Warning: If you're using Apache & `mod_wsgi', you will need to
     enable `WSGIPassAuthorization On', otherwise `mod_wsgi' strips out
     the `Authorization' header. See this post(1) for details (even
     though it only mentions Basic auth).

  ---------- Footnotes ----------

  (1) http://www.nerdydork.com/basic-authentication-on-mod_wsgi.html


File: django-tastypie.info,  Node: SessionAuthentication,  Next: DigestAuthentication,  Prev: ApiKeyAuthentication,  Up: Authentication Options

1.14.2.4 `SessionAuthentication'
................................

This authentication scheme uses the built-in Django sessions to check if
a user is logged. This is typically useful when used by Javascript on
the same site as the API is hosted on.

  It requires that the user has logged in & has an active session. They
also must have a valid CSRF token.


File: django-tastypie.info,  Node: DigestAuthentication,  Next: OAuthAuthentication,  Prev: SessionAuthentication,  Up: Authentication Options

1.14.2.5 `DigestAuthentication'
...............................

This authentication scheme uses HTTP Digest Auth to check a user's
credentials. The username is their `django.contrib.auth.models.User'
username (assuming it is present) and their password should be their
machine-generated api key. As with ApiKeyAuthentication, `tastypie'
should be included in `INSTALLED_APPS'.

     Warning: If you're using Apache & `mod_wsgi', you will need to
     enable `WSGIPassAuthorization On'. See this post(1) for details
     (even though it only mentions Basic auth).

  ---------- Footnotes ----------

  (1) http://www.nerdydork.com/basic-authentication-on-mod_wsgi.html


File: django-tastypie.info,  Node: OAuthAuthentication,  Next: MultiAuthentication,  Prev: DigestAuthentication,  Up: Authentication Options

1.14.2.6 `OAuthAuthentication'
..............................

Handles OAuth, which checks a user's credentials against a separate
service.  Currently verifies against OAuth 1.0a services.

  This does _NOT_ provide OAuth authentication in your API, strictly
consumption.

     Warning: If you're used to in-browser OAuth flow (click a "Sign
     In" button, get redirected, login on remote service, get
     redirected back), this isn't the same. Most prominently, expecting
     that would cause API clients to have to use tools like
     mechanize(1) to fill in forms, which would be difficult.

     This authentication expects that you're already followed some sort
     of OAuth flow & that the credentials (Nonce/token/etc) are simply
     being passed to it.  It merely checks that the credentials are
     valid. No requests are made to remote services as part of this
     authentication class.

  ---------- Footnotes ----------

  (1) http://pypi.python.org/pypi/mechanize/


File: django-tastypie.info,  Node: MultiAuthentication,  Prev: OAuthAuthentication,  Up: Authentication Options

1.14.2.7 `MultiAuthentication'
..............................

This authentication class actually wraps any number of other
authentication classes, attempting each until successfully
authenticating. For example:

    from django.contrib.auth.models import User
    from tastypie.authentication import BasicAuthentication, ApiKeyAuthentication, MultiAuthentication
    from tastypie.authorization import DjangoAuthorization
    from tastypie.resources import ModelResource

    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']

            authentication = MultiAuthentication(BasicAuthentication(), ApiKeyAuthentication())
            authorization = DjangoAuthorization()

In the case of an authentication returning a customized
HttpUnauthorized, MultiAuthentication defaults to the first returned
one. Authentication schemes that need to control the response, such as
the included BasicAuthentication and DigestAuthentication, should be
placed first.


File: django-tastypie.info,  Node: Authorization Options,  Next: Implementing Your Own Authentication/Authorization,  Prev: Authentication Options,  Up: Authentication / Authorization

1.14.3 Authorization Options
----------------------------

Tastypie ships with the following `Authorization' classes:

* Menu:

* Authorization::
* ReadOnlyAuthorization::
* DjangoAuthorization::


File: django-tastypie.info,  Node: Authorization,  Next: ReadOnlyAuthorization,  Up: Authorization Options

1.14.3.1 `Authorization'
........................

The no-op authorization option, no permissions checks are performed.

     Warning: This is a potentially dangerous option, as it means _ANY_
     recognized user can modify _ANY_ data they encounter in the API.
     Be careful who you trust.


File: django-tastypie.info,  Node: ReadOnlyAuthorization,  Next: DjangoAuthorization,  Prev: Authorization,  Up: Authorization Options

1.14.3.2 `ReadOnlyAuthorization'
................................

This authorization class only permits reading data, regardless of what
the `Resource' might think is allowed. This is the default
`Authorization' class and the safe option.


File: django-tastypie.info,  Node: DjangoAuthorization,  Prev: ReadOnlyAuthorization,  Up: Authorization Options

1.14.3.3 `DjangoAuthorization'
..............................

The most advanced form of authorization, this checks the permission a
user has granted to them (via `django.contrib.auth.models.Permission').
In conjunction with the admin, this is a very effective means of
control.


File: django-tastypie.info,  Node: Implementing Your Own Authentication/Authorization,  Prev: Authorization Options,  Up: Authentication / Authorization

1.14.4 Implementing Your Own Authentication/Authorization
---------------------------------------------------------

Implementing your own `Authentication/Authorization' classes is a simple
process. `Authentication' has two methods to override (one of which is
optional but recommended to be customized) and `Authorization' has just
one required method and one optional method:

    from tastypie.authentication import Authentication
    from tastypie.authorization import Authorization


    class SillyAuthentication(Authentication):
        def is_authenticated(self, request, **kwargs):
            if 'daniel' in request.user.username:
              return True

            return False

        # Optional but recommended
        def get_identifier(self, request):
            return request.user.username

    class SillyAuthorization(Authorization):
        def is_authorized(self, request, object=None):
            if request.user.date_joined.year == 2010:
                return True
            else:
                return False

        # Optional but useful for advanced limiting, such as per user.
        def apply_limits(self, request, object_list):
            if request and hasattr(request, 'user'):
                return object_list.filter(author__username=request.user.username)

            return object_list.none()

Under this scheme, only users with 'daniel' in their username will be
allowed in, and only those who joined the site in 2010 will be allowed
to affect data.

  If the optional `apply_limits' method is included, each user that
fits the above criteria will only be able to access their own records.


File: django-tastypie.info,  Node: Serialization,  Next: Throttling,  Prev: Authentication / Authorization,  Up: Welcome to Tastypie!

1.15 Serialization
==================

Serialization can be one of the most contentious areas of an API.
Everyone has their own requirements, their own preferred output format
& the desire to have control over what is returned.

  As a result, Tastypie ships with a serializer that tries to meet the
basic needs of most use cases, and the flexibility to go outside of
that when you need to.

  The default `Serializer' supports the following formats:

   * json

   * jsonp

   * xml

   * yaml

   * html

   * plist (see <http://explorapp.com/biplist/>)

* Menu:

* Usage: Usage<4>.
* Implementing Your Own Serializer::
* Serializer Methods::


File: django-tastypie.info,  Node: Usage<4>,  Next: Implementing Your Own Serializer,  Up: Serialization

1.15.1 Usage
------------

Using this class is simple. It is the default option on all `Resource'
classes unless otherwise specified. The following code is a no-op, but
demonstrate how you could use your own serializer:

    from django.contrib.auth.models import User
    from tastypie.resources import ModelResource
    from tastypie.serializers import Serializer


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']
            # Add it here.
            serializer = Serializer()

Not everyone wants to install or support all the serialization options.
To that end, you can limit the ones available by passing a `formats='
kwarg.  For example, to provide only JSON & binary plist serialization:

    from django.contrib.auth.models import User
    from tastypie.resources import ModelResource
    from tastypie.serializers import Serializer


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']
            serializer = Serializer(formats=['json', 'plist'])



File: django-tastypie.info,  Node: Implementing Your Own Serializer,  Next: Serializer Methods,  Prev: Usage<4>,  Up: Serialization

1.15.2 Implementing Your Own Serializer
---------------------------------------

There are several different use cases here. We'll cover simple examples
of wanting a tweaked format & adding a different format.

  To tweak a format, simply override it's `to_<format>' &
`from_<format>' methods. So adding the server time to all output might
look like so:

    import time
    from django.utils import simplejson
    from django.core.serializers import json
    from tastypie.serializers import Serializer

    class CustomJSONSerializer(Serializer):
        def to_json(self, data, options=None):
            options = options or {}

            data = self.to_simple(data, options)

            # Add in the current time.
            data['requested_time'] = time.time()

            return simplejson.dumps(data, cls=json.DjangoJSONEncoder, sort_keys=True)

        def from_json(self, content):
            data = simplejson.loads(content)

            if 'requested_time' in data:
                # Log the request here...
                pass

            return data

In the case of adding a different format, let's say you want to add a
CSV output option to the existing set. Your `Serializer' subclass might
look like:

    import csv
    import StringIO
    from tastypie.serializers import Serializer


    class CSVSerializer(Serializer):
        formats = ['json', 'jsonp', 'xml', 'yaml', 'html', 'plist', 'csv']
        content_types = {
            'json': 'application/json',
            'jsonp': 'text/javascript',
            'xml': 'application/xml',
            'yaml': 'text/yaml',
            'html': 'text/html',
            'plist': 'application/x-plist',
            'csv': 'text/csv',
        }

        def to_csv(self, data, options=None):
            options = options or {}
            data = self.to_simple(data, options)
            raw_data = StringIO.StringIO()
            # Untested, so this might not work exactly right.
            for item in data:
                writer = csv.DictWriter(raw_data, item.keys(), extrasaction='ignore')
                writer.write(item)
            return raw_data

        def from_csv(self, content):
            raw_data = StringIO.StringIO(content)
            data = []
            # Untested, so this might not work exactly right.
            for item in csv.DictReader(raw_data):
                data.append(item)
            return data



File: django-tastypie.info,  Node: Serializer Methods,  Prev: Implementing Your Own Serializer,  Up: Serialization

1.15.3 `Serializer' Methods
---------------------------

A swappable class for serialization.

  This handles most types of data as well as the following output
formats:

    * json
    * jsonp
    * xml
    * yaml
    * html
    * plist

It was designed to make changing behavior easy, either by overridding
the various format methods (i.e. `to_json'), by changing the
`formats/content_types' options or by altering the other hook methods.

* Menu:

* get_mime_for_format::
* format_datetime::
* format_date::
* format_time::
* serialize: serialize<3>.
* deserialize: deserialize<3>.
* to_simple::
* to_etree::
* from_etree::
* to_json::
* from_json::
* to_jsonp::
* to_xml::
* from_xml::
* to_yaml::
* from_yaml::
* to_plist::
* from_plist::
* to_html::
* from_html::


File: django-tastypie.info,  Node: get_mime_for_format,  Next: format_datetime,  Up: Serializer Methods

1.15.3.1 `get_mime_for_format'
..............................

 -- Method: Serializer.get_mime_for_format(self, format):

  Given a format, attempts to determine the correct MIME type.

  If not available on the current `Serializer', returns
`application/json' by default.


File: django-tastypie.info,  Node: format_datetime,  Next: format_date,  Prev: get_mime_for_format,  Up: Serializer Methods

1.15.3.2 `format_datetime'
..........................

 -- Method: Serializer.format_datetime(data):

  A hook to control how datetimes are formatted.

  Can be overridden at the `Serializer' level (`datetime_formatting')
or globally (via `settings.TASTYPIE_DATETIME_FORMATTING').

  Default is `iso-8601', which looks like "2010-12-16T03:02:14".


File: django-tastypie.info,  Node: format_date,  Next: format_time,  Prev: format_datetime,  Up: Serializer Methods

1.15.3.3 `format_date'
......................

 -- Method: Serializer.format_date(data):

  A hook to control how dates are formatted.

  Can be overridden at the `Serializer' level (`datetime_formatting')
or globally (via `settings.TASTYPIE_DATETIME_FORMATTING').

  Default is `iso-8601', which looks like "2010-12-16".


File: django-tastypie.info,  Node: format_time,  Next: serialize<3>,  Prev: format_date,  Up: Serializer Methods

1.15.3.4 `format_time'
......................

 -- Method: Serializer.format_time(data):

  A hook to control how times are formatted.

  Can be overridden at the `Serializer' level (`datetime_formatting')
or globally (via `settings.TASTYPIE_DATETIME_FORMATTING').

  Default is `iso-8601', which looks like "03:02:14".


File: django-tastypie.info,  Node: serialize<3>,  Next: deserialize<3>,  Prev: format_time,  Up: Serializer Methods

1.15.3.5 `serialize'
....................

 -- Method: Serializer.serialize(self, bundle,
          format='application/json', options={}):

  Given some data and a format, calls the correct method to serialize
the data and returns the result.


File: django-tastypie.info,  Node: deserialize<3>,  Next: to_simple,  Prev: serialize<3>,  Up: Serializer Methods

1.15.3.6 `deserialize'
......................

 -- Method: Serializer.deserialize(self, content,
          format='application/json'):

  Given some data and a format, calls the correct method to deserialize
the data and returns the result.


File: django-tastypie.info,  Node: to_simple,  Next: to_etree,  Prev: deserialize<3>,  Up: Serializer Methods

1.15.3.7 `to_simple'
....................

 -- Method: Serializer.to_simple(self, data, options):

  For a piece of data, attempts to recognize it and provide a simplified
form of something complex.

  This brings complex Python data structures down to native types of the
serialization format(s).


File: django-tastypie.info,  Node: to_etree,  Next: from_etree,  Prev: to_simple,  Up: Serializer Methods

1.15.3.8 `to_etree'
...................

 -- Method: Serializer.to_etree(self, data, options=None, name=None,
          depth=0):

  Given some data, converts that data to an `etree.Element' suitable
for use in the XML output.


File: django-tastypie.info,  Node: from_etree,  Next: to_json,  Prev: to_etree,  Up: Serializer Methods

1.15.3.9 `from_etree'
.....................

 -- Method: Serializer.from_etree(self, data):

  Not the smartest deserializer on the planet. At the request level, it
first tries to output the deserialized subelement called "object" or
"objects" and falls back to deserializing based on hinted types in the
XML element attribute "type".


File: django-tastypie.info,  Node: to_json,  Next: from_json,  Prev: from_etree,  Up: Serializer Methods

1.15.3.10 `to_json'
...................

 -- Method: Serializer.to_json(self, data, options=None):

  Given some Python data, produces JSON output.


File: django-tastypie.info,  Node: from_json,  Next: to_jsonp,  Prev: to_json,  Up: Serializer Methods

1.15.3.11 `from_json'
.....................

 -- Method: Serializer.from_json(self, content):

  Given some JSON data, returns a Python dictionary of the decoded data.


File: django-tastypie.info,  Node: to_jsonp,  Next: to_xml,  Prev: from_json,  Up: Serializer Methods

1.15.3.12 `to_jsonp'
....................

 -- Method: Serializer.to_jsonp(self, data, options=None):

  Given some Python data, produces JSON output wrapped in the provided
callback.


File: django-tastypie.info,  Node: to_xml,  Next: from_xml,  Prev: to_jsonp,  Up: Serializer Methods

1.15.3.13 `to_xml'
..................

 -- Method: Serializer.to_xml(self, data, options=None):

  Given some Python data, produces XML output.


File: django-tastypie.info,  Node: from_xml,  Next: to_yaml,  Prev: to_xml,  Up: Serializer Methods

1.15.3.14 `from_xml'
....................

 -- Method: Serializer.from_xml(self, content):

  Given some XML data, returns a Python dictionary of the decoded data.


File: django-tastypie.info,  Node: to_yaml,  Next: from_yaml,  Prev: from_xml,  Up: Serializer Methods

1.15.3.15 `to_yaml'
...................

 -- Method: Serializer.to_yaml(self, data, options=None):

  Given some Python data, produces YAML output.


File: django-tastypie.info,  Node: from_yaml,  Next: to_plist,  Prev: to_yaml,  Up: Serializer Methods

1.15.3.16 `from_yaml'
.....................

 -- Method: Serializer.from_yaml(self, content):

  Given some YAML data, returns a Python dictionary of the decoded data.


File: django-tastypie.info,  Node: to_plist,  Next: from_plist,  Prev: from_yaml,  Up: Serializer Methods

1.15.3.17 `to_plist'
....................

 -- Method: Serializer.to_plist(self, data, options=None):

  Given some Python data, produces binary plist output.


File: django-tastypie.info,  Node: from_plist,  Next: to_html,  Prev: to_plist,  Up: Serializer Methods

1.15.3.18 `from_plist'
......................

 -- Method: Serializer.from_plist(self, content):

  Given some binary plist data, returns a Python dictionary of the
decoded data.


File: django-tastypie.info,  Node: to_html,  Next: from_html,  Prev: from_plist,  Up: Serializer Methods

1.15.3.19 `to_html'
...................

 -- Method: Serializer.to_html(self, data, options=None):

  Reserved for future usage.

  The desire is to provide HTML output of a resource, making an API
available to a browser. This is on the TODO list but not currently
implemented.


File: django-tastypie.info,  Node: from_html,  Prev: to_html,  Up: Serializer Methods

1.15.3.20 `from_html'
.....................

 -- Method: Serializer.from_html(self, content):

  Reserved for future usage.

  The desire is to handle form-based (maybe Javascript?) input, making
an API available to a browser. This is on the TODO list but not
currently implemented.


File: django-tastypie.info,  Node: Throttling,  Next: Paginator,  Prev: Serialization,  Up: Welcome to Tastypie!

1.16 Throttling
===============

Sometimes, the client on the other end may request data too frequently
or you have a business use case that dictates that the client should be
limited to a certain number of requests per hour.

  For this, Tastypie includes throttling as a way to limit the number
of requests in a timeframe.

* Menu:

* Usage: Usage<5>.
* Throttle Options::
* Implementing Your Own Throttle::


File: django-tastypie.info,  Node: Usage<5>,  Next: Throttle Options,  Up: Throttling

1.16.1 Usage
------------

To specify a throttle, add the `Throttle' class to the `Meta' class on
the `Resource':

    from django.contrib.auth.models import User
    from tastypie.resources import ModelResource
    from tastypie.throttle import BaseThrottle


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']
            # Add it here.
            throttle = BaseThrottle(throttle_at=100)



File: django-tastypie.info,  Node: Throttle Options,  Next: Implementing Your Own Throttle,  Prev: Usage<5>,  Up: Throttling

1.16.2 Throttle Options
-----------------------

Each of the `Throttle' classes accepts the following initialization
arguments:

   * `throttle_at' - the number of requests at which the user should be
     throttled. Default is 150 requests.

   * `timeframe' - the length of time (in seconds) in which the user
     make up to the `throttle_at' requests. Default is 3600 seconds ( 1
     hour).

   * `expiration' - the length of time to retain the times the user has
     accessed the api in the cache. Default is 604800 (1 week).

  Tastypie ships with the following `Throttle' classes:

* Menu:

* BaseThrottle::
* CacheThrottle::
* CacheDBThrottle::


File: django-tastypie.info,  Node: BaseThrottle,  Next: CacheThrottle,  Up: Throttle Options

1.16.2.1 `BaseThrottle'
.......................

The no-op throttle option, this does no throttling but implements much
of the common logic and serves as an api-compatible plug. Very useful
for development.


File: django-tastypie.info,  Node: CacheThrottle,  Next: CacheDBThrottle,  Prev: BaseThrottle,  Up: Throttle Options

1.16.2.2 `CacheThrottle'
........................

This uses just the cache to manage throttling. Fast but prone to cache
misses and/or cache restarts.


File: django-tastypie.info,  Node: CacheDBThrottle,  Prev: CacheThrottle,  Up: Throttle Options

1.16.2.3 `CacheDBThrottle'
..........................

A write-through option that uses the cache first & foremost, but also
writes through to the database to persist access times. Useful for
logging client accesses & with RAM-only caches.


File: django-tastypie.info,  Node: Implementing Your Own Throttle,  Prev: Throttle Options,  Up: Throttling

1.16.3 Implementing Your Own Throttle
-------------------------------------

Writing a `Throttle' class is not quite as simple as the other
components.  There are two important methods, `should_be_throttled' &
`accessed'. The `should_be_throttled' method dictates whether or not
the client should be throttled. The `accessed' method allows for the
recording of the hit to the API.

  An example of a subclass might be:

    import random
    from tastypie.throttle import BaseThrottle


    class RandomThrottle(BaseThrottle):
        def should_be_throttled(self, identifier, **kwargs):
            if random.randint(0, 10) % 2 == 0:
              return True

            return False

        def accessed(self, identifier, **kwargs):
            pass

This throttle class would pick a random number between 0 & 10. If the
number is even, their request is allowed through; otherwise, their
request is throttled & rejected.


File: django-tastypie.info,  Node: Paginator,  Next: GeoDjango,  Prev: Throttling,  Up: Welcome to Tastypie!

1.17 Paginator
==============

Similar to Django's `Paginator', Tastypie includes a `Paginator' object
which limits result sets down to sane amounts for passing to the client.

  This is used in place of Django's `Paginator' due to the way
pagination works. `limit' & `offset' (tastypie) are used in place of
`page' (Django) so none of the page-related calculations are necessary.

  This implementation also provides additional details like the
`total_count' of resources seen and convenience links to the
`previous'/`next' pages of data as available.

* Menu:

* Usage: Usage<6>.
* Implementing Your Own Paginator::


File: django-tastypie.info,  Node: Usage<6>,  Next: Implementing Your Own Paginator,  Up: Paginator

1.17.1 Usage
------------

Using this class is simple, but slightly different than the other
classes used by Tastypie. Like the others, you provide the `Paginator'
(or your own subclass) as a `Meta' option to the `Resource' in
question. *Unlike* the others, you provide the class, _NOT_ an
instance. For example:

    from django.contrib.auth.models import User
    from tastypie.paginator import Paginator
    from tastypie.resources import ModelResource


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']
            # Add it here.
            paginator_class = Paginator



File: django-tastypie.info,  Node: Implementing Your Own Paginator,  Prev: Usage<6>,  Up: Paginator

1.17.2 Implementing Your Own Paginator
--------------------------------------

Adding other features to a paginator usually consists of overriding one
of the built-in methods. For instance, adding a page number to the
output might look like:

    from tastypie.paginator import Paginator


    class PageNumberPaginator(Paginator):
        def page(self):
            output = super(PageNumberPaginator, self).page()
            output['page_number'] = int(self.offset / self.limit) + 1
            return output

Another common request is to alter the structure Tastypie uses in the
list view. Here's an example of renaming:

    from tastypie.paginator import Paginator


    class BlogEntryPaginator(Paginator):
        def page(self):
            output = super(BlogEntryPaginator, self).page()

            # First keep a reference.
            output['pagination'] = output['meta']
            output['entries'] = output['objects']

            # Now nuke the original keys.
            del output['meta']
            del output['objects']

            return output



File: django-tastypie.info,  Node: GeoDjango,  Next: ContentTypes and GenericForeignKeys,  Prev: Paginator,  Up: Welcome to Tastypie!

1.18 GeoDjango
==============

Tastypie features support for GeoDjango!  Resources return and accept
GeoJSON(1) (or similarly-formatted analogs for other formats) and all
spatial lookup(2) filters are supported.  Distance lookups are not yet
supported.

* Menu:

* Usage: Usage<7>.

Usage

* Filtering::

  ---------- Footnotes ----------

  (1) http://geojson.org/geojson-spec.html

  (2)
https://docs.djangoproject.com/en/1.3/ref/contrib/gis/geoquerysets/#spatial-lookups


File: django-tastypie.info,  Node: Usage<7>,  Up: GeoDjango

1.18.1 Usage
------------

Here's an example geographic model for leaving notes in polygonal
regions:

    from django.contrib.gis import models

    class GeoNote(models.Model):
        content = models.TextField()
        polys = models.MultiPolygonField(null=True, blank=True)

        objects = models.GeoManager()

To define a resource that takes advantage of the geospatial features,
we use `tastypie.contrib.gis.resources.ModelResource':

    from tastypie.contrib.gis.resources import ModelResource

    class GeoNoteResource(ModelResource):
        class Meta:
            resource_name = 'geonotes'
            queryset = GeoNote.objects.all()

            filtering = {
                'polys': ALL,
            }

Now when we do a `GET' on our GeoNoteResource we get back GeoJSON in
our response:

    {
        "content": "My note content",
        "id": "1",
        "polys": {
            "coordinates": [[[
                [-122.511067, 37.771276], [-122.510037, 37.766390999999999],
                [-122.510037, 37.763812999999999], [-122.456822, 37.765847999999998],
                [-122.45296, 37.766458999999998], [-122.454848, 37.773989999999998],
                [-122.475362, 37.773040000000002], [-122.511067, 37.771276]
            ]]],
            "type": "MultiPolygon"
        },
        "resource_uri": "/api/v1/geonotes/1/"
    }

When updating or creating new resources, simply provide GeoJSON or the
GeoJSON analog for your perferred format.

* Menu:

* Filtering::


File: django-tastypie.info,  Node: Filtering,  Up: Usage<7>

1.18.1.1 Filtering
..................

We can filter using any standard GeoDjango spatial lookup(1) filter.
Simply provide a GeoJSON (or the analog) as a `GET' parameter value.

  Let's find all of our `GeoNote' resources that contain a point inside
of Golden Gate Park(2):

    /api/v1/geonotes/?polys__contains={"type": "Point", "coordinates": [-122.475233, 37.768617]}

Returns:

    {
        "meta": {
            "limit": 20, "next": null, "offset": 0, "previous": null, "total_count": 1},
        "objects": [
            {
                "content": "My note content",
                "id": "1",
                "polys": {
                    "coordinates": [[[
                        [-122.511067, 37.771276], [-122.510037, 37.766390999999999],
                        [-122.510037, 37.763812999999999], [-122.456822, 37.765847999999998],
                        [-122.45296, 37.766458999999998], [-122.454848, 37.773989999999998],
                        [-122.475362, 37.773040000000002], [-122.511067, 37.771276]
                    ]]],
                    "type": "MultiPolygon"
                },
                "resource_uri": "/api/geonotes/1/"
            }
        ]
    }

We get back the `GeoNote' resource defining Golden Gate Park.  Awesome!

  ---------- Footnotes ----------

  (1)
https://docs.djangoproject.com/en/1.3/ref/contrib/gis/geoquerysets/#spatial-lookups

  (2) https://sf.localwiki.org/Golden_Gate_Park


File: django-tastypie.info,  Node: ContentTypes and GenericForeignKeys,  Next: Tastypie Cookbook,  Prev: GeoDjango,  Up: Welcome to Tastypie!

1.19 ContentTypes and GenericForeignKeys
========================================

Content Types(1) and GenericForeignKeys are for relationships where the
model on one end is not defined by the model's schema.

  If you're using GenericForeignKeys in django, you can use a
GenericForeignKeyField in Tastypie.

* Menu:

* Usage: Usage<8>.

  ---------- Footnotes ----------

  (1) https://docs.djangoproject.com/en/dev/ref/contrib/contenttypes/


File: django-tastypie.info,  Node: Usage<8>,  Up: ContentTypes and GenericForeignKeys

1.19.1 Usage
------------

Here's an example model with a GenericForeignKey taken from the Django
docs:

    from django.db import models
    from django.contrib.contenttypes.models import ContentType
    from django.contrib.contenttypes import generic

    class TaggedItem(models.Model):
        tag = models.SlugField()
        content_type = models.ForeignKey(ContentType)
        object_id = models.PositiveIntegerField()
        content_object = generic.GenericForeignKey('content_type', 'object_id')

        def __unicode__(self):
            return self.tag

A simple ModelResource for this model might look like this:

    from tastypie.contrib.contenttypes.fields import GenericForeignKeyField
    from tastypie.resources import ModelResource

    from .models import Note, Quote, TaggedItem


    class QuoteResource(ModelResource):

        class Meta:
            resource_name = 'quotes'
            queryset = Quote.objects.all()


    class NoteResource(ModelResource):

        class Meta:
            resource_name = 'notes'
            queryset = Note.objects.all()


    class TaggedItemResource(ModelResource):
        content_object = GenericForeignKeyField({
            Note: NoteResource,
            Quote: QuoteResource
        }, 'content_object')

        class Meta:
            resource_name = 'tagged_items'
            queryset = TaggedItem.objects.all()

Like ToOneField, you must add your GenericForeignKey attribute to your
ModelResource definition. It will not be added automatically like most
other field or attribute types. When you define it, you must also
define the other models and match them to their resources in a
dictionary, and pass that as the first argument, the second argument is
the name of the attribute on the model that holds the GenericForeignKey.


File: django-tastypie.info,  Node: Tastypie Cookbook,  Next: Debugging Tastypie,  Prev: ContentTypes and GenericForeignKeys,  Up: Welcome to Tastypie!

1.20 Tastypie Cookbook
======================

* Menu:

* Adding Custom Values::
* Per-Request Alterations To The Queryset::
* Using Your Resource In Regular Views::
* Using Non-PK Data For Your URLs::
* Nested Resources::
* Adding Search Functionality::
* Creating per-user resources::
* camelCase JSON Serialization::
* Pretty-printed JSON Serialization::
* Determining format via URL::
* Adding to the Django Admin::
* Using SessionAuthentication::


File: django-tastypie.info,  Node: Adding Custom Values,  Next: Per-Request Alterations To The Queryset,  Up: Tastypie Cookbook

1.20.1 Adding Custom Values
---------------------------

You might encounter cases where you wish to include additional data in a
response which is not obtained from a field or method on your model.
You can easily extend the `dehydrate()' method to provide additional
values:

    class MyModelResource(Resource):
        class Meta:
            qs = MyModel.objects.all()

        def dehydrate(self, bundle):
            bundle.data['custom_field'] = "Whatever you want"
            return bundle



File: django-tastypie.info,  Node: Per-Request Alterations To The Queryset,  Next: Using Your Resource In Regular Views,  Prev: Adding Custom Values,  Up: Tastypie Cookbook

1.20.2 Per-Request Alterations To The Queryset
----------------------------------------------

A common pattern is needing to limit a queryset by something that
changes per-request, for instance the date/time. You can accomplish
this by lightly modifying `get_object_list':

    from tastypie.utils import now

    class MyResource(ModelResource):
        class Meta:
            queryset = MyObject.objects.all()

        def get_object_list(self, request):
            return super(MyResource, self).get_object_list(request).filter(start_date__gte=now)



File: django-tastypie.info,  Node: Using Your Resource In Regular Views,  Next: Using Non-PK Data For Your URLs,  Prev: Per-Request Alterations To The Queryset,  Up: Tastypie Cookbook

1.20.3 Using Your `Resource' In Regular Views
---------------------------------------------

In addition to using your resource classes to power the API, you can
also use them to write other parts of your application, such as your
views. For instance, if you wanted to encode user information in the
page for some Javascript's use, you could do the following:

    # views.py
    from django.shortcuts import render_to_response
    from myapp.api.resources import UserResource


    def user_detail(request, username):
        ur = UserResource()
        user = ur.obj_get(username=username)

        # Other things get prepped to go into the context then...

        ur_bundle = ur.build_bundle(obj=user, request=request)
        return render_to_response('myapp/user_detail.html', {
            # Other things here.
            "user_json": ur.serialize(None, ur.full_dehydrate(ur_bundle), 'application/json'),
        })



File: django-tastypie.info,  Node: Using Non-PK Data For Your URLs,  Next: Nested Resources,  Prev: Using Your Resource In Regular Views,  Up: Tastypie Cookbook

1.20.4 Using Non-PK Data For Your URLs
--------------------------------------

By convention, `ModelResource's usually expose the detail endpoints
utilizing the primary key of the `Model' they represent. However, this
is not a strict requirement. Each URL can take other named URLconf
parameters that can be used for the lookup.

  For example, if you want to expose `User' resources by username, you
can do something like the following:

    # myapp/api/resources.py
    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()

        def prepend_urls(self):
            return [
                url(r"^(?P<resource_name>%s)/(?P<username>[\w\d_.-]+)/$" % self._meta.resource_name, self.wrap_view('dispatch_detail'), name="api_dispatch_detail"),
            ]

The added URLconf matches before the standard URLconf included by
default & matches on the username provided in the URL.


File: django-tastypie.info,  Node: Nested Resources,  Next: Adding Search Functionality,  Prev: Using Non-PK Data For Your URLs,  Up: Tastypie Cookbook

1.20.5 Nested Resources
-----------------------

You can also do "nested resources" (resources within another related
resource) by lightly overriding the `prepend_urls' method & adding on a
new method to handle the children:

    class ParentResource(ModelResource):
        children = fields.ToManyField(ChildResource, 'children')

        def prepend_urls(self):
            return [
                url(r"^(?P<resource_name>%s)/(?P<pk>\w[\w/-]*)/children%s$" % (self._meta.resource_name, trailing_slash()), self.wrap_view('get_children'), name="api_get_children"),
            ]

        def get_children(self, request, **kwargs):
            try:
                obj = self.cached_obj_get(request=request, **self.remove_api_resource_names(kwargs))
            except ObjectDoesNotExist:
                return HttpGone()
            except MultipleObjectsReturned:
                return HttpMultipleChoices("More than one resource is found at this URI.")

            child_resource = ChildResource()
            return child_resource.get_detail(request, parent_id=obj.pk)

Another alternative approach is to override the `dispatch' method:

    # myapp/api/resources.py
    class EntryResource(ModelResource):
        user = fields.ForeignKey(UserResource, 'user')

        class Meta:
            queryset = Entry.objects.all()
            resource_name = 'entry'

        def dispatch(self, request_type, request, **kwargs):
            username = kwargs.pop('username')
            kwargs['user'] = get_object_or_404(User, username=username)
            return super(EntryResource, self).dispatch(request_type, request, **kwargs)

    # urls.py
    from django.conf.urls.defaults import *
    from myapp.api import EntryResource

    entry_resource = EntryResource()

    urlpatterns = patterns('',
        # The normal jazz here, then...
        (r'^api/(?P<username>\w+)/', include(entry_resource.urls)),
    )



File: django-tastypie.info,  Node: Adding Search Functionality,  Next: Creating per-user resources,  Prev: Nested Resources,  Up: Tastypie Cookbook

1.20.6 Adding Search Functionality
----------------------------------

Another common request is being able to integrate search functionality.
This approach uses Haystack(1), though you could hook it up to any
search technology.  We leave the CRUD methods of the resource alone,
choosing to add a new endpoint at `/api/v1/notes/search/':

    from django.conf.urls.defaults import *
    from django.core.paginator import Paginator, InvalidPage
    from django.http import Http404
    from haystack.query import SearchQuerySet
    from tastypie.resources import ModelResource
    from tastypie.utils import trailing_slash
    from notes.models import Note


    class NoteResource(ModelResource):
        class Meta:
            queryset = Note.objects.all()
            resource_name = 'notes'

        def prepend_urls(self):
            return [
                url(r"^(?P<resource_name>%s)/search%s$" % (self._meta.resource_name, trailing_slash()), self.wrap_view('get_search'), name="api_get_search"),
            ]

        def get_search(self, request, **kwargs):
            self.method_check(request, allowed=['get'])
            self.is_authenticated(request)
            self.throttle_check(request)

            # Do the query.
            sqs = SearchQuerySet().models(Note).load_all().auto_query(request.GET.get('q', ''))
            paginator = Paginator(sqs, 20)

            try:
                page = paginator.page(int(request.GET.get('page', 1)))
            except InvalidPage:
                raise Http404("Sorry, no results on that page.")

            objects = []

            for result in page.object_list:
                bundle = self.build_bundle(obj=result.object, request=request)
                bundle = self.full_dehydrate(bundle)
                objects.append(bundle)

            object_list = {
                'objects': objects,
            }

            self.log_throttled_access(request)
            return self.create_response(request, object_list)


  ---------- Footnotes ----------

  (1) http://haystacksearch.org/


File: django-tastypie.info,  Node: Creating per-user resources,  Next: camelCase JSON Serialization,  Prev: Adding Search Functionality,  Up: Tastypie Cookbook

1.20.7 Creating per-user resources
----------------------------------

One might want to create an API which will require every user to
authenticate and every user will be working only with objects
associated with them. Let's see how to implement it for two basic
operations: listing and creation of an object.

  For listing we want to list only objects for which 'user' field
matches 'request.user'. This could be done by applying a filter in the
`apply_authorization_limits' method of your resource.

  For creating we'd have to wrap `obj_create' method of
`ModelResource'. Then the resulting code will look something like:

    # myapp/api/resources.py
    class EnvironmentResource(ModelResource):
        class Meta:
            queryset = Environment.objects.all()
            resource_name = 'environment'
            list_allowed_methods = ['get', 'post']
            authentication = ApiKeyAuthentication()
            authorization = Authorization()

        def obj_create(self, bundle, request=None, **kwargs):
            return super(EnvironmentResource, self).obj_create(bundle, request, user=request.user)

        def apply_authorization_limits(self, request, object_list):
            return object_list.filter(user=request.user)



File: django-tastypie.info,  Node: camelCase JSON Serialization,  Next: Pretty-printed JSON Serialization,  Prev: Creating per-user resources,  Up: Tastypie Cookbook

1.20.8 camelCase JSON Serialization
-----------------------------------

The convention in the world of Javascript has standardized on camelCase,
where Tastypie uses underscore syntax, which can lead to "ugly" looking
code in Javascript. You can create a custom serializer that emits
values in camelCase instead:

    from tastypie.serializers import Serializer

    class CamelCaseJSONSerializer(Serializer):
        formats = ['json']
        content_types = {
            'json': 'application/json',
        }

        def to_json(self, data, options=None):
            # Changes underscore_separated names to camelCase names to go from python convention to javacsript convention
            data = self.to_simple(data, options)

            def underscoreToCamel(match):
                return match.group()[0] + match.group()[2].upper()

            def camelize(data):
                if isinstance(data, dict):
                    new_dict = {}
                    for key, value in data.items():
                        new_key = re.sub(r"[a-z]_[a-z]", underscoreToCamel, key)
                        new_dict[new_key] = camelize(value)
                    return new_dict
                if isinstance(data, (list, tuple)):
                    for i in range(len(data)):
                        data[i] = camelize(data[i])
                    return data
                return data

            camelized_data = camelize(data)

            return simplejson.dumps(camelized_data, sort_keys=True)

        def from_json(self, content):
            # Changes camelCase names to underscore_separated names to go from javascript convention to python convention
            data = simplejson.loads(content)

            def camelToUnderscore(match):
                return match.group()[0] + "_" + match.group()[1].lower()

            def underscorize(data):
                if isinstance(data, dict):
                    new_dict = {}
                    for key, value in data.items():
                        new_key = re.sub(r"[a-z][A-Z]", camelToUnderscore, key)
                        new_dict[new_key] = underscorize(value)
                    return new_dict
                if isinstance(data, (list, tuple)):
                    for i in range(len(data)):
                        data[i] = underscorize(data[i])
                    return data
                return data

        underscored_data = underscorize(data)

        return underscored_data



File: django-tastypie.info,  Node: Pretty-printed JSON Serialization,  Next: Determining format via URL,  Prev: camelCase JSON Serialization,  Up: Tastypie Cookbook

1.20.9 Pretty-printed JSON Serialization
----------------------------------------

By default, Tastypie outputs JSON with no indentation or newlines
(equivalent to calling `json.dumps()' with _indent_ set to `None'). You
can override this behavior in a custom serializer:

    from django.core.serializers import json
    from django.utils import simplejson
    from tastypie.serializers import Serializer

    class PrettyJSONSerializer(Serializer):
        json_indent = 2

        def to_json(self, data, options=None):
            options = options or {}
            data = self.to_simple(data, options)
            return simplejson.dumps(data, cls=json.DjangoJSONEncoder,
                    sort_keys=True, ensure_ascii=False, indent=self.json_indent)



File: django-tastypie.info,  Node: Determining format via URL,  Next: Adding to the Django Admin,  Prev: Pretty-printed JSON Serialization,  Up: Tastypie Cookbook

1.20.10 Determining format via URL
----------------------------------

Sometimes it's required to allow selecting the response format by
specifying it in the API URL, for example `/api/v1/users.json' instead
of `/api/v1/users/?format=json'. The following snippet allows that kind
of syntax additional to the default URL scheme:

    # myapp/api/resources.py
    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()

        def prepend_urls(self):
            """
            Returns a URL scheme based on the default scheme to specify
            the response format as a file extension, e.g. /api/v1/users.json
            """
            return [
                url(r"^(?P<resource_name>%s)\.(?P<format>\w+)$" % self._meta.resource_name, self.wrap_view('dispatch_list'), name="api_dispatch_list"),
                url(r"^(?P<resource_name>%s)/schema\.(?P<format>\w+)$" % self._meta.resource_name, self.wrap_view('get_schema'), name="api_get_schema"),
                url(r"^(?P<resource_name>%s)/set/(?P<pk_list>\w[\w/;-]*)\.(?P<format>\w+)$" % self._meta.resource_name, self.wrap_view('get_multiple'), name="api_get_multiple"),
                url(r"^(?P<resource_name>%s)/(?P<pk>\w[\w/-]*)\.(?P<format>\w+)$" % self._meta.resource_name, self.wrap_view('dispatch_detail'), name="api_dispatch_detail"),
            ]

        def determine_format(self, request):
            """
            Used to determine the desired format from the request.format
            attribute.
            """
            if (hasattr(request, 'format') and
                    request.format in self._meta.serializer.formats):
                return self._meta.serializer.get_mime_for_format(request.format)
            return super(UserResource, self).determine_format(request)

        def wrap_view(self, view):
            def wrapper(request, *args, **kwargs):
                request.format = kwargs.pop('format', None)
                wrapped_view = super(UserResource, self).wrap_view(view)
                return wrapped_view(request, *args, **kwargs)
            return wrapper



File: django-tastypie.info,  Node: Adding to the Django Admin,  Next: Using SessionAuthentication,  Prev: Determining format via URL,  Up: Tastypie Cookbook

1.20.11 Adding to the Django Admin
----------------------------------

If you're using the django admin and ApiKeyAuthentication, you may want
to see or edit ApiKeys next to users. To do this, you need to
unregister the built-in UserAdmin, alter the inlines, and re-register
it. This could go in any of your admin.py files. You may also want to
register ApiAccess and ApiKey models on their own.:

    from tastypie.admin import ApiKeyInline
    from tastypie.models import ApiAccess, ApiKey
    from django.contrib.auth.admin import UserAdmin
    from django.contrib.auth.models import User

    admin.site.register(ApiKey)
    admin.site.register(ApiAccess)

    class UserModelAdmin(UserAdmin):
        inlines = UserAdmin.inlines + [ApiKeyInline]

    admin.site.unregister(User)
    admin.site.register(User,UserModelAdmin)



File: django-tastypie.info,  Node: Using SessionAuthentication,  Prev: Adding to the Django Admin,  Up: Tastypie Cookbook

1.20.12 Using `SessionAuthentication'
-------------------------------------

If your users are logged into the site & you want Javascript to be able
to access the API (assuming jQuery), the first thing to do is setup
`SessionAuthentication':

    from django.contrib.auth.models import User
    from tastypie.authentication import SessionAuthentication
    from tastypie.resources import ModelResource


    class UserResource(ModelResource):
        class Meta:
            resource_name = 'users'
            queryset = User.objects.all()
            authentication = SessionAuthentication()

Then you'd build a template like:

    <html>
        <head>
            <title></title>
            <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
            <script type="text/javascript">
                $(document).ready(function() {
                    // We use ``.ajax`` here due to the overrides.
                    $.ajax({
                        // Substitute in your API endpoint here.
                        url: '/api/v1/users/',
                        contentType: 'application/json',
                        // The ``X-CSRFToken`` evidently can't be set in the
                        // ``headers`` option, so force it here.
                        // This method requires jQuery 1.5+.
                        beforeSend: function(jqXHR, settings) {
                            // Pull the token out of the DOM.
                            jqXHR.setRequestHeader('X-CSRFToken', $('input[name=csrfmiddlewaretoken]').val());
                        },
                        success: function(data, textStatus, jqXHR) {
                            // Your processing of the data here.
                            console.log(data);
                        }
                    });
                });
            </script>
        </head>
        <body>
            <!-- Include the CSRF token in the body of the HTML -->
            {% csrf_token %}
        </body>
    </html>

There are other ways to make this function, with other libraries or
other techniques for supplying the token (see
<https://docs.djangoproject.com/en/dev/ref/contrib/csrf/#ajax> for an
alternative). This is simply a starting point for getting things
working.


File: django-tastypie.info,  Node: Debugging Tastypie,  Next: Sites Using Tastypie,  Prev: Tastypie Cookbook,  Up: Welcome to Tastypie!

1.21 Debugging Tastypie
=======================

There are some common problems people run into when using Tastypie for
the first time. Some of the common problems and things to try appear
below.

* Menu:

* "I'm getting XML output in my browser but I want JSON output!"::
* "What's the format for a POST or PUT?"::
* "Why is my syncdb with superuser failing with a DatabaseError?"::


File: django-tastypie.info,  Node: "I'm getting XML output in my browser but I want JSON output!",  Next: "What's the format for a POST or PUT?",  Up: Debugging Tastypie

1.21.1 "I'm getting XML output in my browser but I want JSON output!"
---------------------------------------------------------------------

This is actually not a bug and JSON support is present in your
`Resource'.  This issue is that Tastypie respects the `Accept' header
your browser sends.  Most browsers send something like:

    Accept: application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5

Note that `application/xml' comes first, which is a format that Tastypie
handles by default, hence why you receive XML.

  If you use `curl' from the command line, you should receive JSON by
default:

    curl http://localhost:8000/api/v1/

If you want JSON in the browser, simply append `?format=json' to your
URL.  Tastypie always respects this override first, before it falls
back to the `Accept' header.


File: django-tastypie.info,  Node: "What's the format for a POST or PUT?",  Next: "Why is my syncdb with superuser failing with a DatabaseError?",  Prev: "I'm getting XML output in my browser but I want JSON output!",  Up: Debugging Tastypie

1.21.2 "What's the format for a POST or PUT?"
---------------------------------------------

You can view full schema for your resource through *note Inspecting The
Resource's Schema: 1e.

  In general, Tastypie will accept resources in the same format as it
gives you.  This means that you can see what any POST or PUT should
look like by performing a GET of that resource.

  Creating a duplicate of an entry, using Python and Requests(1):

    import requests
    import json

    response = requests.get('http://localhost:8000/api/v1/entry/1/')
    event = json.loads(response.content)

    del event['id'] # We want the server to assign a new id

    response = requests.post('http://localhost:8000/api/v1/entry/',
                             data=json.dumps(event),
                             headers={'content-type': 'application/json'})

The new event should be almost identical, with the exception of readonly
fields. This method may fail if your model has a unique constraint, or
otherwise fails validation.

  This is less likely to happen on PUT, except for application logic
changes (e.g. a `last_update' field). The following two `curl' commands
replace and entry with an copy:

    curl -H 'Accept: application/json' 'http://localhost:8000/api/v1/entry/1/' | \
    curl -H 'Content-Type: application/json' -X PUT --data @- "http://localhost:8000/api/v1/entry/1/"

You can do this over an entire collection as well:

    curl -H 'Accept: application/json' 'http://localhost:8000/api/v1/entry/?limit=0' | \
    curl -H 'Content-Type: application/json' -X PUT --data @- "http://localhost:8000/api/v1/entry/"


  ---------- Footnotes ----------

  (1) http://python-requests.org


File: django-tastypie.info,  Node: "Why is my syncdb with superuser failing with a DatabaseError?",  Prev: "What's the format for a POST or PUT?",  Up: Debugging Tastypie

1.21.3 "Why is my syncdb with superuser failing with a DatabaseError?"
----------------------------------------------------------------------

More specifically, this specific `DatabaseError':

    django.db.utils.DatabaseError: no such table: tastypie_apikey

This is a side effect of the (disabled by default) `create_api_key'
signal as described in the *note Authentication / Authorization: 1d6.
section of the documentation when used in conjunction with South.

  To work around this issue, you can disable the `create_api_key' signal
until you have completed running `syncdb --migrate' for the first time.


File: django-tastypie.info,  Node: Sites Using Tastypie,  Next: Contributing,  Prev: Debugging Tastypie,  Up: Welcome to Tastypie!

1.22 Sites Using Tastypie
=========================

The following sites are a partial list of people using Tastypie. I'm
always interested in adding more sites, so please find me
(`daniellindsley') via IRC or start a mailing list thread.

* Menu:

* LJWorld Marketplace::
* Forkinit::
* Read The Docs::
* Luzme::
* Politifact::
* Crate::
* LocalWiki::
* I-Am-CC.org: I-Am-CC org.


File: django-tastypie.info,  Node: LJWorld Marketplace,  Next: Forkinit,  Up: Sites Using Tastypie

1.22.1 LJWorld Marketplace
--------------------------

   * <http://www2.ljworld.com/marketplace/api/v1/?format=json>


File: django-tastypie.info,  Node: Forkinit,  Next: Read The Docs,  Prev: LJWorld Marketplace,  Up: Sites Using Tastypie

1.22.2 Forkinit
---------------

Read-only API access to recipes.

   * <http://forkinit.com/>

   * <http://forkinit.com/api/v1/?format=json>


File: django-tastypie.info,  Node: Read The Docs,  Next: Luzme,  Prev: Forkinit,  Up: Sites Using Tastypie

1.22.3 Read The Docs
--------------------

A hosted documentation site, primarily for Python docs. General purpose
read-write access.

   * <http://readthedocs.org/>

   * <http://readthedocs.org/api/v1/?format=json>


File: django-tastypie.info,  Node: Luzme,  Next: Politifact,  Prev: Read The Docs,  Up: Sites Using Tastypie

1.22.4 Luzme
------------

An e-book search site that lets you fetch pricing information.

   * <http://luzme.com/>

   * <http://luzme.readthedocs.org/en/latest/>


File: django-tastypie.info,  Node: Politifact,  Next: Crate,  Prev: Luzme,  Up: Sites Using Tastypie

1.22.5 Politifact
-----------------

To power their mobile (iPhone/Android/Playbook) applications.

   * <http://www.politifact.com/mobile/>


File: django-tastypie.info,  Node: Crate,  Next: LocalWiki,  Prev: Politifact,  Up: Sites Using Tastypie

1.22.6 Crate
------------

Crate is a PyPI mirror/replacement. It's using Tastypie to provide a
convenient REST API.

   * <https://crate.io/api/v1/>


File: django-tastypie.info,  Node: LocalWiki,  Next: I-Am-CC org,  Prev: Crate,  Up: Sites Using Tastypie

1.22.7 LocalWiki
----------------

LocalWiki(1) is a tool for collaborating in local, geographic
communities. It's using Tastypie to provide an geospatially-aware REST
API.

   * <http://localwiki.readthedocs.org/en/latest/api.html>

   * <http://localwiki.org/blog/2012/aug/31/localwiki-api-released/>

  ---------- Footnotes ----------

  (1) http://localwiki.org


File: django-tastypie.info,  Node: I-Am-CC org,  Prev: LocalWiki,  Up: Sites Using Tastypie

1.22.8 I-Am-CC.org
------------------

I-Am-CC.org(1) is a tool for releasing Instagram photos under a
Creative Commons license.

   * <http://i-am-cc.org/api/?format=json>

  ---------- Footnotes ----------

  (1) http://i-am-cc.org


File: django-tastypie.info,  Node: Contributing,  Prev: Sites Using Tastypie,  Up: Welcome to Tastypie!

1.23 Contributing
=================

Tastypie is open-source and, as such, grows (or shrinks) & improves in
part due to the community. Below are some guidelines on how to help
with the project.

* Menu:

* Philosophy::
* Guidelines For Reporting An Issue/Feature::
* Guidelines For Contributing Code::
* Guidelines For Core Contributors::


File: django-tastypie.info,  Node: Philosophy,  Next: Guidelines For Reporting An Issue/Feature,  Up: Contributing

1.23.1 Philosophy
-----------------

   * Tastypie is BSD-licensed. All contributed code must be either

        * the original work of the author, contributed under the BSD,
          or...

        * work taken from another project released under a
          BSD-compatible license.

   * GPL'd (or similar) works are not eligible for inclusion.

   * Tastypie's git master branch should always be stable,
     production-ready & passing all tests.

   * Major releases (1.x.x) are commitments to backward-compatibility
     of the public APIs.  Any documented API should ideally not change
     between major releases.  The exclusion to this rule is in the
     event of either a security issue or to accommodate changes in
     Django itself.

   * Minor releases (x.3.x) are for the addition of substantial
     features or major bugfixes.

   * Patch releases (x.x.4) are for minor features or bugfixes.


File: django-tastypie.info,  Node: Guidelines For Reporting An Issue/Feature,  Next: Guidelines For Contributing Code,  Prev: Philosophy,  Up: Contributing

1.23.2 Guidelines For Reporting An Issue/Feature
------------------------------------------------

So you've found a bug or have a great idea for a feature. Here's the
steps you should take to help get it added/fixed in Tastypie:

   * First, check to see if there's an existing issue/pull request for
     the bug/feature. All issues are at
     <https://github.com/toastdriven/django-tastypie/issues> and pull
     reqs are at <https://github.com/toastdriven/django-tastypie/pulls>.

   * If there isn't one there, please file an issue. The ideal report
     includes:

        * A description of the problem/suggestion.

        * How to recreate the bug.

        * If relevant, including the versions of your:

             * Python interpreter

             * Django

             * Tastypie

             * Optionally of the other dependencies involved

        * Ideally, creating a pull request with a (failing) test case
          demonstrating what's wrong. This makes it easy for us to
          reproduce & fix the problem.  Instructions for running the
          tests are at *note Welcome to Tastypie!: 2.

  You might also hop into the IRC channel (`#tastypie' on
`irc.freenode.net') & raise your question there, as there may be
someone who can help you with a work-around.


File: django-tastypie.info,  Node: Guidelines For Contributing Code,  Next: Guidelines For Core Contributors,  Prev: Guidelines For Reporting An Issue/Feature,  Up: Contributing

1.23.3 Guidelines For Contributing Code
---------------------------------------

If you're ready to take the plunge & contribute back some code/docs, the
process should look like:

   * Fork the project on GitHub into your own account.

   * Clone your copy of Tastypie.

   * Make a new branch in git & commit your changes there.

   * Push your new branch up to GitHub.

   * Again, ensure there isn't already an issue or pull request out
     there on it.  If there is & you feel you have a better fix, please
     take note of the issue number & mention it in your pull request.

   * Create a new pull request (based on your branch), including what
     the problem/feature is, versions of your software & referencing
     any related issues/pull requests.

  In order to be merged into Tastypie, contributions must have the
following:

   * A solid patch that:

        * is clear.

        * works across all supported versions of Python/Django.

        * follows the existing style of the code base (mostly PEP-8).

        * comments included as needed.

   * A test case that demonstrates the previous flaw that now passes
     with the included patch.

   * If it adds/changes a public API, it must also include documentation
     for those changes.

   * Must be appropriately licensed (see "Philosophy").

   * Adds yourself to the AUTHORS file.

  If your contribution lacks any of these things, they will have to be
added by a core contributor before being merged into Tastypie proper,
which may take substantial time for the all-volunteer team to get to.


File: django-tastypie.info,  Node: Guidelines For Core Contributors,  Prev: Guidelines For Contributing Code,  Up: Contributing

1.23.4 Guidelines For Core Contributors
---------------------------------------

If you've been granted the commit bit, here's how to shepherd the
changes in:

   * Any time you go to work on Tastypie, please use `git pull
     --rebase' to fetch the latest changes.

   * Any new features/bug fixes must meet the above guidelines for
     contributing code (solid patch/tests passing/docs included).

   * Commits are typically cherry-picked onto a branch off master.

        * This is done so as not to include extraneous commits, as some
          people submit pull reqs based on their git master that has
          other things applied to it.

   * A set of commits should be squashed down to a single commit.

        * `git merge --squash' is a good tool for performing this, as is
          `git rebase -i HEAD~N'.

        * This is done to prevent anyone using the git repo from
          accidently pulling work-in-progress commits.

   * Commit messages should use past tense, describe what changed &
     thank anyone involved. Examples:

         """Added a new way to do per-object authorization."""
         """Fixed a bug in ``Serializer.to_xml``. Thanks to joeschmoe for the report!"""
         """BACKWARD-INCOMPATIBLE: Altered the arguments passed to ``Bundle.__init__``.

         Further description appears here if the change warrants an explanation
         as to why it was done."""


   * For any patches applied from a contributor, please ensure their
     name appears in the AUTHORS file.

   * When closing issues or pull requests, please reference the SHA in
     the closing message (i.e. `Thanks! Fixed in SHA: 6b93f6'). GitHub
     will automatically link to it.


File: django-tastypie.info,  Node: Getting Help,  Next: Quick Start<4>,  Prev: Welcome to Tastypie!,  Up: Top

2 Getting Help
**************

There are two primary ways of getting help. We have a mailing list(1)
hosted at Google (<http://groups.google.com/group/django-tastypie/>)
and an IRC channel (#tastypie on irc.freenode.net(2)) to get help, want
to bounce idea or generally shoot the breeze.

  ---------- Footnotes ----------

  (1) http://groups.google.com/group/django-tastypie/

  (2) irc://irc.freenode.net/tastypie


File: django-tastypie.info,  Node: Quick Start<4>,  Next: Requirements,  Prev: Getting Help,  Up: Top

3 Quick Start
*************

  1. Add `tastypie' to `INSTALLED_APPS'.

  2. Create an `api' directory in your app with a bare `__init__.py'.

  3. Create an `<my_app>/api/resources.py' file and place the following
     in it:

         from tastypie.resources import ModelResource
         from my_app.models import MyModel


         class MyModelResource(ModelResource):
             class Meta:
                 queryset = MyModel.objects.all()
                 allowed_methods = ['get']


  4. In your root URLconf, add the following code (around where the
     admin code might be):

         from tastypie.api import Api
         from my_app.api.resources import MyModelResource

         v1_api = Api(api_name='v1')
         v1_api.register(MyModelResource())

         urlpatterns = patterns('',
           # ...more URLconf bits here...
           # Then add:
           (r'^api/', include(v1_api.urls)),
         )


  5. Hit <http://localhost:8000/api/v1/?format=json> in your browser!


File: django-tastypie.info,  Node: Requirements,  Next: Why Tastypie?,  Prev: Quick Start<4>,  Up: Top

4 Requirements
**************

Tastypie requires the following modules. If you use Pip(1), you can
install the necessary bits via the included `requirements.txt':

* Menu:

* Required::
* Optional::

  ---------- Footnotes ----------

  (1) http://pip.openplans.org/


File: django-tastypie.info,  Node: Required,  Next: Optional,  Up: Requirements

4.1 Required
============

   * Python 2.6+

   * Django 1.3+

   * mimeparse 0.1.3+ (<http://code.google.com/p/mimeparse/>)

        * Older versions will work, but their behavior on JSON/JSONP is
          a touch wonky.

   * dateutil (<http://labix.org/python-dateutil>) >= 1.5, < 2.0


File: django-tastypie.info,  Node: Optional,  Prev: Required,  Up: Requirements

4.2 Optional
============

   * python_digest (<https://bitbucket.org/akoha/python-digest/>)

   * lxml (<http://lxml.de/>) if using the XML serializer

   * pyyaml (<http://pyyaml.org/>) if using the YAML serializer

   * biplist (<http://explorapp.com/biplist/>) if using the binary
     plist serializer


File: django-tastypie.info,  Node: Why Tastypie?,  Next: Reference Material,  Prev: Requirements,  Up: Top

5 Why Tastypie?
***************

There are other, better known API frameworks out there for Django. You
need to assess the options available and decide for yourself. That
said, here are some common reasons for tastypie.

   * You need an API that is RESTful and uses HTTP well.

   * You want to support deep relations.

   * You DON'T want to have to write your own serializer to make the
     output right.

   * You want an API framework that has little magic, very flexible and
     maps well to the problem domain.

   * You want/need XML serialization that is treated equally to JSON
     (and YAML is there too).

   * You want to support my perceived NIH syndrome, which is less about
     NIH and more about trying to help out friends/coworkers.


File: django-tastypie.info,  Node: Reference Material,  Next: Running The Tests,  Prev: Why Tastypie?,  Up: Top

6 Reference Material
********************

   *
     <http://github.com/toastdriven/django-tastypie/tree/master/tests/basic>
     shows basic usage of tastypie

   * <http://en.wikipedia.org/wiki/REST>

   * <http://en.wikipedia.org/wiki/List_of_HTTP_status_codes>

   * <http://www.ietf.org/rfc/rfc2616.txt>

   * <http://jacobian.org/writing/rest-worst-practices/>


File: django-tastypie.info,  Node: Running The Tests,  Next: Commercial Support,  Prev: Reference Material,  Up: Top

7 Running The Tests
*******************

The easiest way to get setup to run Tastypie's tests looks like:

    $ git clone https://github.com/toastdriven/django-tastypie.git
    $ cd django-tastypie
    $ virtualenv env
    $ . env/bin/activate
    $ ./env/bin/pip install -U -r requirements.txt

Then running the tests is as simple as:

    # From the same directory as above:
    $ ./env/bin/pip install -U -r tests/requirements.txt
    $ cd tests
    $ ./run_all_test.sh

Tastypie is maintained with all tests passing at all times. If you find
a failure, please report it(1) along with the versions of the installed
software.

  ---------- Footnotes ----------

  (1) https://github.com/toastdriven/django-tastypie/issues


File: django-tastypie.info,  Node: Commercial Support,  Next: Getting Started with Tastypie<2>,  Prev: Running The Tests,  Up: Top

8 Commercial Support
********************

If you're using Tastypie in a commercial environment, paid support is
available from Toast Driven(1). Services offered include:

   * Advice/help with setup

   * Implementation in your project

   * Bugfixes in Tastypie itself

   * Features in Tastypie itself

  If you're interested, please contact Daniel Lindsley
(<daniel@toastdriven.com>).

  ---------- Footnotes ----------

  (1) http://toastdriven.com/


File: django-tastypie.info,  Node: Getting Started with Tastypie<2>,  Next: Interacting With The API<2>,  Prev: Commercial Support,  Up: Top

9 Getting Started with Tastypie
*******************************

Tastypie is a reusable app (that is, it relies only on it's own code and
focuses on providing just a REST-style API) and is suitable for
providing an API to any application without having to modify the
sources of that app.

  Not everyone's needs are the same, so Tastypie goes out of its way to
provide plenty of hooks for overriding or extending how it works.

     Note: If you hit a stumbling block, you can join #tastypie on
     irc.freenode.net(1) to get help.

  This tutorial assumes that you have a basic understanding of Django
as well as how proper REST-style APIs ought to work. We will only
explain the portions of the code that are Tastypie-specific in any kind
of depth.

  For example purposes, we'll be adding an API to a simple blog
application.  Here is `myapp/models.py':

    from tastypie.utils.timezone import now
    from django.contrib.auth.models import User
    from django.db import models
    from django.template.defaultfilters import slugify


    class Entry(models.Model):
        user = models.ForeignKey(User)
        pub_date = models.DateTimeField(default=now)
        title = models.CharField(max_length=200)
        slug = models.SlugField()
        body = models.TextField()

        def __unicode__(self):
            return self.title

        def save(self, *args, **kwargs):
            # For automatic slug generation.
            if not self.slug:
                self.slug = slugify(self.title)[:50]

            return super(Entry, self).save(*args, **kwargs)

With that, we'll move on to installing and configuring Tastypie.

* Menu:

* Installation: Installation<2>.
* Configuration: Configuration<2>.
* Creating Resources: Creating Resources<2>.
* Hooking Up The Resource(s): Hooking Up The Resource s<2>.
* Creating More Resources: Creating More Resources<2>.
* Adding To The Api: Adding To The Api<2>.
* Limiting Data And Access: Limiting Data And Access<2>.
* Beyond The Basics: Beyond The Basics<2>.

  ---------- Footnotes ----------

  (1) irc://irc.freenode.net/tastypie


File: django-tastypie.info,  Node: Installation<2>,  Next: Configuration<2>,  Up: Getting Started with Tastypie<2>

9.1 Installation
================

Installing Tastypie is as simple as checking out the source and adding
it to your project or `PYTHONPATH'.

       1. Download the dependencies:

             * Python 2.4+

             * Django 1.0+ (tested on Django 1.1+)

             * `mimeparse' 0.1.3+
               (<http://code.google.com/p/mimeparse/>)

                  * Older versions will work, but their behavior on
                    JSON/JSONP is a touch wonky.

             * `dateutil' (<http://labix.org/python-dateutil>)

             * *OPTIONAL* - `lxml' (<http://lxml.de/>) if using the XML
               serializer

             * *OPTIONAL* - `pyyaml' (<http://pyyaml.org/>) if using
               the YAML serializer

             * *OPTIONAL* - `uuid' (present in 2.5+, downloadable from
               <http://pypi.python.org/pypi/uuid/>) if using the
               `ApiKey' authentication

       2. Either check out tastypie from GitHub(1) or to pull a release
          off PyPI(2).  Doing `sudo pip install django-tastypie' or
          `sudo easy_install django-tastypie' is all that should be
          required.

       3. Either symlink the `tastypie' directory into your project or
          copy the directory in. What ever works best for you.

     Note: Once tastypie reaches version 1.0, it will become officially
     available on PyPI(3). Once that is the case, a `sudo pip install
     tastypie' or `sudo easy_install tastypie' should be available.

  ---------- Footnotes ----------

  (1) http://github.com/toastdriven/django-tastypie

  (2) http://pypi.python.org/

  (3) http://pypi.python.org/


File: django-tastypie.info,  Node: Configuration<2>,  Next: Creating Resources<2>,  Prev: Installation<2>,  Up: Getting Started with Tastypie<2>

9.2 Configuration
=================

The only mandatory configuration is adding `'tastypie'' to your
`INSTALLED_APPS'. This isn't strictly necessary, as Tastypie has only
two non-required models, but may ease usage.

  You have the option to set up a number of settings (see *note
Tastypie Settings: b.) but they all have sane defaults and are not
required unless you need to tweak their values.


File: django-tastypie.info,  Node: Creating Resources<2>,  Next: Hooking Up The Resource s<2>,  Prev: Configuration<2>,  Up: Getting Started with Tastypie<2>

9.3 Creating Resources
======================

REST-style architecture talks about resources, so unsurprisingly
integrating with Tastypie involves creating `Resource' classes.  For
our simple application, we'll create a file for these in `myapp/api.py',
though they can live anywhere in your application:

    # myapp/api.py
    from tastypie.resources import ModelResource
    from myapp.models import Entry


    class EntryResource(ModelResource):
        class Meta:
            queryset = Entry.objects.all()
            resource_name = 'entry'

This class, by virtue of being a `ModelResource' subclass, will
introspect all non-relational fields on the `Entry' model and create
it's own *note ApiFields: 0. that map to those fields, much like the
way Django's `ModelForm' class introspects.

     Note: The `resource_name' within the `Meta' class is optional. If
     not provided, it is automatically generated off the classname,
     removing any instances of `Resource' and lowercasing the string.
     So `EntryResource' would become just `entry'.

     We've included the `resource_name' attribute in this example for
     clarity, especially when looking at the URLs, but you should feel
     free to omit it if you're comfortable with the automatic behavior.


File: django-tastypie.info,  Node: Hooking Up The Resource s<2>,  Next: Creating More Resources<2>,  Prev: Creating Resources<2>,  Up: Getting Started with Tastypie<2>

9.4 Hooking Up The Resource(s)
==============================

Now that we have our `EntryResource', we can hook it up in our URLconf.
To do this, we simply instantiate the resource in our URLconf and hook
up its `urls':

    # urls.py
    from django.conf.urls.defaults import *
    from myapp.api import EntryResource

    entry_resource = EntryResource()

    urlpatterns = patterns('',
        # The normal jazz here...
        (r'^blog/', include('myapp.urls')),
        (r'^api/', include(entry_resource.urls)),
    )

Now it's just a matter of firing up server (`./manage.py runserver') and
going to <http://127.0.0.1:8000/api/entry/?format=json>. You should get
back a list of `Entry'-like objects.

     Note: The `?format=json' is an override required to make things
     look decent in the browser (accept headers vary between browsers).
     Tastypie properly handles the `Accept' header. So the following
     will work properly:

         curl -H "Accept: application/json" http://127.0.0.1:8000/api/entry/

     But if you're sure you want something else (or want to test in a
     browser), Tastypie lets you specify `?format=...' when you really
     want to force a certain type.

  At this point, a bunch of other URLs are also available. Try out
any/all of the following (assuming you have at least three records in
the database):

        * <http://127.0.0.1:8000/api/entry/?format=json>

        * <http://127.0.0.1:8000/api/entry/1/?format=json>

        * <http://127.0.0.1:8000/api/entry/schema/?format=json>

        * <http://127.0.0.1:8000/api/entry/set/1;3/?format=json>

  However, if you try sending a POST/PUT/DELETE to the resource, you
find yourself getting "401 Unauthorized" errors. For safety, Tastypie
ships with the `authorization' class ("what are you allowed to do") set
to `ReadOnlyAuthorization'. This makes it safe to expose on the web,
but prevents us from doing POST/PUT/DELETE. Let's enable those:

    # myapp/api.py
    from tastypie.authorization import Authorization
    from tastypie.resources import ModelResource
    from myapp.models import Entry


    class EntryResource(ModelResource):
        class Meta:
            queryset = Entry.objects.all()
            resource_name = 'entry'
            authorization= Authorization()


     Warning: This is now great for testing in development but *VERY
     INSECURE*. You should never put a `Resource' like this out on the
     internet. Please spend some time looking at the
     authentication/authorization classes available in Tastypie.

  With just nine lines of code, we have a full working REST interface
to our `Entry' model. In addition, full GET/POST/PUT/DELETE support is
already there, so it's possible to really work with all of the data.
Well, _almost_.

  You see, you'll note that not quite all of our data is there.
Markedly absent is the `user' field, which is a `ForeignKey' to
Django's `User' model.  Tastypie does *NOT* introspect related data
because it has no way to know how you want to represent that data.

  And since that relation isn't there, any attempt to POST/PUT new data
will fail, because no `user' is present, which is a required field on
the model.

  This is easy to fix, but we'll need to flesh out our API a little
more.


File: django-tastypie.info,  Node: Creating More Resources<2>,  Next: Adding To The Api<2>,  Prev: Hooking Up The Resource s<2>,  Up: Getting Started with Tastypie<2>

9.5 Creating More Resources
===========================

In order to handle our `user' relation, we'll need to create a
`UserResource' and tell the `EntryResource' to use it. So we'll modify
`myapp/api.py' to match the following code:

    # myapp/api.py
    from django.contrib.auth.models import User
    from tastypie import fields
    from tastypie.resources import ModelResource
    from myapp.models import Entry


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'user'


    class EntryResource(ModelResource):
        user = fields.ForeignKey(UserResource, 'user')

        class Meta:
            queryset = Entry.objects.all()
            resource_name = 'entry'

We simply created a new `ModelResource' subclass called `UserResource'.
Then we added a field to `EntryResource' that specified that the `user'
field points to a `UserResource' for that data.

  Now we should be able to get all of the fields back in our response.
But since we have another full, working resource on our hands, we
should hook that up to our API as well. And there's a better way to do
it.


File: django-tastypie.info,  Node: Adding To The Api<2>,  Next: Limiting Data And Access<2>,  Prev: Creating More Resources<2>,  Up: Getting Started with Tastypie<2>

9.6 Adding To The Api
=====================

Tastypie ships with an `Api' class, which lets you bind multiple
`Resources' together to form a coherent API. Adding it to the mix is
simple.

  We'll go back to our URLconf (`urls.py') and change it to match the
following:

    # urls.py
    from django.conf.urls.defaults import *
    from tastypie.api import Api
    from myapp.api import EntryResource, UserResource

    v1_api = Api(api_name='v1')
    v1_api.register(UserResource())
    v1_api.register(EntryResource())

    urlpatterns = patterns('',
        # The normal jazz here...
        (r'^blog/', include('myapp.urls')),
        (r'^api/', include(v1_api.urls)),
    )

Note that we're now creating an `Api' instance, registering our
`EntryResource' and `UserResource' instances with it and that we've
modified the urls to now point to `v1_api.urls'.

  This makes even more data accessible, so if we start up the
`runserver' again, the following URLs should work:

        * <http://127.0.0.1:8000/api/v1/?format=json>

        * <http://127.0.0.1:8000/api/v1/user/?format=json>

        * <http://127.0.0.1:8000/api/v1/user/1/?format=json>

        * <http://127.0.0.1:8000/api/v1/user/schema/?format=json>

        * <http://127.0.0.1:8000/api/v1/user/set/1;3/?format=json>

        * <http://127.0.0.1:8000/api/v1/entry/?format=json>

        * <http://127.0.0.1:8000/api/v1/entry/1/?format=json>

        * <http://127.0.0.1:8000/api/v1/entry/schema/?format=json>

        * <http://127.0.0.1:8000/api/v1/entry/set/1;3/?format=json>

  Additionally, the representations out of `EntryResource' will now
include the `user' field and point to an endpoint like
`/api/v1/users/1/' to access that user's data. And full POST/PUT delete
support should now work.

  But there's several new problems. One is that our new `UserResource'
leaks too much data, including fields like `email', `password',
`is_active' and `is_staff'. Another is that we may not want to allow
end users to alter `User' data. Both of these problems are easily fixed
as well.


File: django-tastypie.info,  Node: Limiting Data And Access<2>,  Next: Beyond The Basics<2>,  Prev: Adding To The Api<2>,  Up: Getting Started with Tastypie<2>

9.7 Limiting Data And Access
============================

Cutting out the `email', `password', `is_active' and `is_staff' fields
is easy to do. We simply modify our `UserResource' code to match the
following:

    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'user'
            excludes = ['email', 'password', 'is_active', 'is_staff', 'is_superuser']

The `excludes' directive tells `UserResource' which fields not to
include in the output. If you'd rather whitelist fields, you could do:

    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'user'
            fields = ['username', 'first_name', 'last_name', 'last_login']

Now that the undesirable fields are no longer included, we can look at
limiting access. This is also easy and involves making our
`UserResource' look like:

    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'user'
            excludes = ['email', 'password', 'is_active', 'is_staff', 'is_superuser']
            allowed_methods = ['get']

Now only HTTP GET requests will be allowed on `/api/v1/user/'
endpoints. If you require more granular control, both
`list_allowed_methods' and `detail_allowed_methods' options are
supported.


File: django-tastypie.info,  Node: Beyond The Basics<2>,  Prev: Limiting Data And Access<2>,  Up: Getting Started with Tastypie<2>

9.8 Beyond The Basics
=====================

We now have a full working API for our application. But Tastypie
supports many more features, like:

        * *note Authentication / Authorization: 12.

        * *note Caching: 13.

        * *note Throttling: 14.

        * *note Resources: 15. (filtering & sorting)

        * *note Serialization: 16.

  Tastypie is also very easy to override and extend. For some common
patterns and approaches, you should refer to the *note Tastypie
Cookbook: 17. documentation.


File: django-tastypie.info,  Node: Interacting With The API<2>,  Next: Tastypie Settings<2>,  Prev: Getting Started with Tastypie<2>,  Up: Top

10 Interacting With The API
***************************

Now that you've got a shiny new REST-style API in place, let's
demonstrate how to interact with it. We'll assume that you have cURL(1)
installed on your system (generally available on most modern Mac &
Linux machines), but any tool that allows you to control headers &
bodies on requests will do.

  We'll assume that we're interacting with the following Tastypie code:

    # myapp/api/resources.py
    from django.contrib.auth.models import User
    from tastypie.authorization import Authorization
    from tastypie import fields
    from tastypie.resources import ModelResource, ALL, ALL_WITH_RELATIONS
    from myapp.models import Entry


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'user'
            excludes = ['email', 'password', 'is_active', 'is_staff', 'is_superuser']
            filtering = {
                'username': ALL,
            }


    class EntryResource(ModelResource):
        user = fields.ForeignKey(UserResource, 'user')

        class Meta:
            queryset = Entry.objects.all()
            resource_name = 'entry'
            authorization = Authorization()
            filtering = {
                'user': ALL_WITH_RELATIONS,
                'pub_date': ['exact', 'lt', 'lte', 'gte', 'gt'],
            }


    # urls.py
    from django.conf.urls.defaults import *
    from tastypie.api import Api
    from myapp.api.resources import EntryResource, UserResource

    v1_api = Api(api_name='v1')
    v1_api.register(UserResource())
    v1_api.register(EntryResource())

    urlpatterns = patterns('',
        # The normal jazz here...
        (r'^blog/', include('myapp.urls')),
        (r'^api/', include(v1_api.urls)),
    )

Let's fire up a shell & start exploring the API!

* Menu:

* Front Matter: Front Matter<2>.
* Fetching Data: Fetching Data<2>.
* Sending Data: Sending Data<2>.
* Deleting Data: Deleting Data<2>.
* Bulk Operations: Bulk Operations<2>.
* You Did It!: You Did It!<2>.

  ---------- Footnotes ----------

  (1) http://curl.haxx.se/


File: django-tastypie.info,  Node: Front Matter<2>,  Next: Fetching Data<2>,  Up: Interacting With The API<2>

10.1 Front Matter
=================

Tastypie tries to treat all clients & all serialization types as
equally as possible. It also tries to be a good 'Net citizen & respects
the HTTP method used as well as the `Accepts' headers sent. Between
these two, you control all interactions with Tastypie through
relatively few endpoints.

     Warning: Should you try these URLs in your browser, be warned you
     *WILL* need to append `?format=json' (or `xml' or `yaml') to the
     URL. Your browser requests `application/xml' before
     `application/json', so you'll always get back XML if you don't
     specify it.

     That's also why it's recommended that you explore via curl,
     because you avoid your browser's opinionated requests & get
     something closer to what any programmatic clients will get.


File: django-tastypie.info,  Node: Fetching Data<2>,  Next: Sending Data<2>,  Prev: Front Matter<2>,  Up: Interacting With The API<2>

10.2 Fetching Data
==================

Since reading data out of an API is a very common activity (and the
easiest type of request to make), we'll start there. Tastypie tries to
expose various parts of the API & interlink things within the API
(HATEOAS).

* Menu:

* Api-Wide: Api-Wide<2>.
* Inspecting The Resource's Schema: Inspecting The Resource's Schema<2>.
* Getting A Collection Of Resources: Getting A Collection Of Resources<2>.
* Getting A Detail Resource: Getting A Detail Resource<2>.
* Selecting A Subset Of Resources: Selecting A Subset Of Resources<2>.


File: django-tastypie.info,  Node: Api-Wide<2>,  Next: Inspecting The Resource's Schema<2>,  Up: Fetching Data<2>

10.2.1 Api-Wide
---------------

We'll start at the highest level:

    curl http://localhost:8000/api/v1/

You'll get back something like:

    {
        "entry": {
            "list_endpoint": "/api/v1/entry/",
            "schema": "/api/v1/entry/schema/"
        },
        "user": {
            "list_endpoint": "/api/v1/user/",
            "schema": "/api/v1/user/schema/"
        }
    }

This lists out all the different `Resource' classes you registered in
your URLconf with the API. Each one is listed by the `resource_name'
you gave it and provides the `list_endpoint' & the `schema' for the
resource.

  Note that these links try to direct you to other parts of the API, to
make exploration/discovery easier. We'll use these URLs in the next
several sections.

  To demonstrate another format, you could run the following to get the
XML variant of the same information:

    curl -H "Accept: application/xml" http://localhost:8000/api/v1/

To which you'd receive:

    <?xml version="1.0" encoding="utf-8"?>
    <response>
      <entry type="hash">
        <list_endpoint>/api/v1/entry/</list_endpoint>
        <schema>/api/v1/entry/schema/</schema>
      </entry>
      <user type="hash">
        <list_endpoint>/api/v1/user/</list_endpoint>
        <schema>/api/v1/user/schema/</schema>
      </user>
    </response>

We'll stick to JSON for the rest of this document, but using XML should
be OK to do at any time.


File: django-tastypie.info,  Node: Inspecting The Resource's Schema<2>,  Next: Getting A Collection Of Resources<2>,  Prev: Api-Wide<2>,  Up: Fetching Data<2>

10.2.2 Inspecting The Resource's Schema
---------------------------------------

Since the api-wide view gave us a `schema' URL, let's inspect that next.
We'll use the `entry' resource. Again, a simple GET request by curl:

    curl http://localhost:8000/api/v1/entry/schema/

This time, we get back a lot more data:

    {
        "default_format": "application/json",
        "fields": {
            "body": {
                "help_text": "Unicode string data. Ex: \"Hello World\"",
                "nullable": false,
                "readonly": false,
                "type": "string"
            },
            "id": {
                "help_text": "Unicode string data. Ex: \"Hello World\"",
                "nullable": false,
                "readonly": false,
                "type": "string"
            },
            "pub_date": {
                "help_text": "A date & time as a string. Ex: \"2010-11-10T03:07:43\"",
                "nullable": false,
                "readonly": false,
                "type": "datetime"
            },
            "resource_uri": {
                "help_text": "Unicode string data. Ex: \"Hello World\"",
                "nullable": false,
                "readonly": true,
                "type": "string"
            },
            "slug": {
                "help_text": "Unicode string data. Ex: \"Hello World\"",
                "nullable": false,
                "readonly": false,
                "type": "string"
            },
            "title": {
                "help_text": "Unicode string data. Ex: \"Hello World\"",
                "nullable": false,
                "readonly": false,
                "type": "string"
            },
            "user": {
                "help_text": "A single related resource. Can be either a URI or set of nested resource data.",
                "nullable": false,
                "readonly": false,
                "type": "related"
            }
        },
        "filtering": {
            "pub_date": ["exact", "lt", "lte", "gte", "gt"],
            "user": 2
        }
    }

This lists out the `default_format' this resource responds with, the
`fields' on the resource & the `filtering' options available. This
information can be used to prepare the other aspects of the code for the
data it can obtain & ways to filter the resources.


File: django-tastypie.info,  Node: Getting A Collection Of Resources<2>,  Next: Getting A Detail Resource<2>,  Prev: Inspecting The Resource's Schema<2>,  Up: Fetching Data<2>

10.2.3 Getting A Collection Of Resources
----------------------------------------

Let's get down to fetching live data. From the api-wide view, we'll hit
the `list_endpoint' for `entry':

    curl http://localhost:8000/api/v1/entry/

We get back data that looks like:

    {
        "meta": {
            "limit": 20,
            "next": null,
            "offset": 0,
            "previous": null,
            "total_count": 3
        },
        "objects": [{
            "body": "Welcome to my blog!",
            "id": "1",
            "pub_date": "2011-05-20T00:46:38",
            "resource_uri": "/api/v1/entry/1/",
            "slug": "first-post",
            "title": "First Post",
            "user": "/api/v1/user/1/"
        },
        {
            "body": "Well, it's been awhile and I still haven't updated. ",
            "id": "2",
            "pub_date": "2011-05-21T00:46:58",
            "resource_uri": "/api/v1/entry/2/",
            "slug": "second-post",
            "title": "Second Post",
            "user": "/api/v1/user/1/"
        },
        {
            "body": "I'm really excited to get started with this new blog. It's gonna be great!",
            "id": "3",
            "pub_date": "2011-05-20T00:47:30",
            "resource_uri": "/api/v1/entry/3/",
            "slug": "my-blog",
            "title": "My Blog",
            "user": "/api/v1/user/2/"
        }]
    }

Some things to note:

        * By default, you get a paginated set of objects (20 per page
          is the default).

        * In the `meta', you get a `previous' & `next'. If available,
          these are URIs to the previous & next pages.

        * You get a list of resources/objects under the `objects' key.

        * Each resources/object has a `resource_uri' field that points
          to the detail view for that object.

        * The foreign key to `User' is represented as a URI by default.
          If you're looking for the full `UserResource' to be embedded
          in this view, you'll need to add `full=True' to the
          `fields.ToOneField'.

  If you want to skip paginating, simply run:

    curl http://localhost:8000/api/v1/entry/?limit=0

Be warned this will return all objects, so it may be a CPU/IO-heavy
operation on large datasets.

  Let's try filtering on the resource. Since we know we can filter on
the `user', we'll fetch all posts by the `daniel' user with:

    curl http://localhost:8000/api/v1/entry/?user__username=daniel

We get back what we asked for:

    {
        "meta": {
            "limit": 20,
            "next": null,
            "offset": 0,
            "previous": null,
            "total_count": 2
        },
        "objects": [{
            "body": "Welcome to my blog!",
            "id": "1",
            "pub_date": "2011-05-20T00:46:38",
            "resource_uri": "/api/v1/entry/1/",
            "slug": "first-post",
            "title": "First Post",
            "user": "/api/v1/user/1/"
        },
        {
            "body": "Well, it's been awhile and I still haven't updated. ",
            "id": "2",
            "pub_date": "2011-05-21T00:46:58",
            "resource_uri": "/api/v1/entry/2/",
            "slug": "second-post",
            "title": "Second Post",
            "user": "/api/v1/user/1/"
        }]
    }

Where there were three posts before, now there are only two.


File: django-tastypie.info,  Node: Getting A Detail Resource<2>,  Next: Selecting A Subset Of Resources<2>,  Prev: Getting A Collection Of Resources<2>,  Up: Fetching Data<2>

10.2.4 Getting A Detail Resource
--------------------------------

Since each resource/object in the list view had a `resource_uri', let's
explore what's there:

    curl http://localhost:8000/api/v1/entry/1/

We get back a similar set of data that we received from the list view:

    {
        "body": "Welcome to my blog!",
        "id": "1",
        "pub_date": "2011-05-20T00:46:38",
        "resource_uri": "/api/v1/entry/1/",
        "slug": "first-post",
        "title": "First Post",
        "user": "/api/v1/user/1/"
    }

Where this proves useful (for example) is present in the data we got
back. We know the URI of the `User' associated with this blog entry.
Let's run:

    curl http://localhost:8000/api/v1/user/1/

Without ever seeing any aspect of the `UserResource' & just following
the URI given, we get back:

    {
        "date_joined": "2011-05-20T00:42:14.990617",
        "first_name": "",
        "id": "1",
        "last_login": "2011-05-20T00:44:57.510066",
        "last_name": "",
        "resource_uri": "/api/v1/user/1/",
        "username": "daniel"
    }

You can do a similar fetch using the following Javascript/jQuery
(though be wary of same-domain policy):

    $.ajax({
      url: 'http://localhost:8000/api/v1/user/1/',
      type: 'GET',
      accepts: 'application/json',
      dataType: 'json'
    })



File: django-tastypie.info,  Node: Selecting A Subset Of Resources<2>,  Prev: Getting A Detail Resource<2>,  Up: Fetching Data<2>

10.2.5 Selecting A Subset Of Resources
--------------------------------------

Sometimes you may want back more than one record, but not an entire
list view nor do you want to do multiple requests. Tastypie includes a
"set" view, which lets you cherry-pick the objects you want. For
example, if we just want the first & third `Entry' resources, we'd run:

    curl "http://localhost:8000/api/v1/entry/set/1;3/"


     Note: Quotes are needed in this case because of the semicolon
     delimiter between primary keys. Without the quotes, bash tries to
     split it into two statements.  No extraordinary quoting will be
     necessary in your application (unless your API client is written
     in bash :D).

  And we get back just those two objects:

    {
        "objects": [{
            "body": "Welcome to my blog!",
            "id": "1",
            "pub_date": "2011-05-20T00:46:38",
            "resource_uri": "/api/v1/entry/1/",
            "slug": "first-post",
            "title": "First Post",
            "user": "/api/v1/user/1/"
        },
        {
            "body": "I'm really excited to get started with this new blog. It's gonna be great!",
            "id": "3",
            "pub_date": "2011-05-20T00:47:30",
            "resource_uri": "/api/v1/entry/3/",
            "slug": "my-blog",
            "title": "My Blog",
            "user": "/api/v1/user/2/"
        }]
    }

Note that, like the list view, you get back a list of `objects'. Unlike
the list view, there is *NO* pagination applied to these objects. You
asked for them, you're going to get them all.


File: django-tastypie.info,  Node: Sending Data<2>,  Next: Deleting Data<2>,  Prev: Fetching Data<2>,  Up: Interacting With The API<2>

10.3 Sending Data
=================

Tastypie also gives you full write capabilities in the API. Since the
`EntryResource' has the no-limits `Authentication' & `Authorization' on
it, we can freely write data.

     Warning: Note that this is a huge security hole as well. Don't put
     unauthorized write-enabled resources on the Internet, because
     someone will trash your data.

     This is why `ReadOnlyAuthorization' is the default in Tastypie &
     why you must override to provide more access.

  The good news is that there are no new URLs to learn. The "list" &
"detail" URLs we've been using to fetch data _ALSO_ support the
`POST'/`PUT'/`DELETE' HTTP methods.

* Menu:

* Creating A New Resource (POST): Creating A New Resource POST<2>.
* Updating An Existing Resource (PUT): Updating An Existing Resource PUT<2>.
* Partially Updating An Existing Resource (PATCH): Partially Updating An Existing Resource PATCH<2>.
* Updating A Whole Collection Of Resources (PUT): Updating A Whole Collection Of Resources PUT<2>.


File: django-tastypie.info,  Node: Creating A New Resource POST<2>,  Next: Updating An Existing Resource PUT<2>,  Up: Sending Data<2>

10.3.1 Creating A New Resource (POST)
-------------------------------------

Let's add a new entry. To create new data, we'll switch from `GET'
requests to the familiar `POST' request.

     Note: Tastypie encourages "round-trippable" data, which means the
     data you can GET should be able to be POST/PUT'd back to recreate
     the same object.

     If you're ever in question about what you should send, do a GET on
     another object & see what Tastypie thinks it should look like.

  To create new resources/objects, you will `POST' to the list endpoint
of a resource. Trying to `POST' to a detail endpoint has a different
meaning in the REST mindset (meaning to add a resource as a child of a
resource of the same type).

  As with all Tastypie requests, the headers we request are important.
Since we've been using primarily JSON throughout, let's send a new
entry in JSON format:

    curl --dump-header - -H "Content-Type: application/json" -X POST --data '{"body": "This will prbbly be my lst post.", "pub_date": "2011-05-22T00:46:38", "slug": "another-post", "title": "Another Post", "user": "/api/v1/user/1/"}' http://localhost:8000/api/v1/entry/

The `Content-Type' header here informs Tastypie that we're sending it
JSON.  We send the data as a JSON-serialized body (*NOT* as form-data
in the form of URL parameters). What we get back is the following
response:

    HTTP/1.0 201 CREATED
    Date: Fri, 20 May 2011 06:48:36 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Type: text/html; charset=utf-8
    Location: http://localhost:8000/api/v1/entry/4/

You'll also note that we get a correct HTTP status code back (201) & a
`Location' header, which gives us the URI to our newly created resource.

  Passing `--dump-header -' is important, because it gives you all the
headers as well as the status code. When things go wrong, this will be
useful information to help with debugging. For instance, if we send a
request without a `user':

    curl --dump-header - -H "Content-Type: application/json" -X POST --data '{"body": "This will prbbly be my lst post.", "pub_date": "2011-05-22T00:46:38", "slug": "another-post", "title": "Another Post"}' http://localhost:8000/api/v1/entry/

We get back:

    HTTP/1.0 400 BAD REQUEST
    Date: Fri, 20 May 2011 06:53:02 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Type: text/html; charset=utf-8

    The 'user' field has no data and doesn't allow a default or null value.

You can do a similar POST using the following Javascript/jQuery (though
be wary of same-domain policy):

    # This may require the ``json2.js`` library for older browsers.
    var data = JSON.stringify({
        "body": "This will prbbly be my lst post.",
        "pub_date": "2011-05-22T00:46:38",
        "slug": "another-post",
        "title": "Another Post"
    });

    $.ajax({
      url: 'http://localhost:8000/api/v1/entry/',
      type: 'POST',
      contentType: 'application/json',
      data: data,
      dataType: 'json',
      processData: false
    })



File: django-tastypie.info,  Node: Updating An Existing Resource PUT<2>,  Next: Partially Updating An Existing Resource PATCH<2>,  Prev: Creating A New Resource POST<2>,  Up: Sending Data<2>

10.3.2 Updating An Existing Resource (PUT)
------------------------------------------

You might have noticed that we made some typos when we submitted the
POST request. We can fix this using a `PUT' request to the detail
endpoint (modify this instance of a resource).:

    curl --dump-header - -H "Content-Type: application/json" -X PUT --data '{"body": "This will probably be my last post.", "pub_date": "2011-05-22T00:46:38", "slug": "another-post", "title": "Another Post", "user": "/api/v1/user/1/"}' http://localhost:8000/api/v1/entry/4/

After fixing up the `body', we get back:

    HTTP/1.0 204 NO CONTENT
    Date: Fri, 20 May 2011 07:13:21 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Length: 0
    Content-Type: text/html; charset=utf-8

We get a 204 status code, meaning our update was successful. We don't
get a `Location' header back because we did the `PUT' on a detail URL,
which presumably did not change.

     Note: A `PUT' request requires that the entire resource
     representation be enclosed. Missing fields may cause errors, or be
     filled in by default values.


File: django-tastypie.info,  Node: Partially Updating An Existing Resource PATCH<2>,  Next: Updating A Whole Collection Of Resources PUT<2>,  Prev: Updating An Existing Resource PUT<2>,  Up: Sending Data<2>

10.3.3 Partially Updating An Existing Resource (PATCH)
------------------------------------------------------

In some cases, you may not want to send the entire resource when
updating. To update just a subset of the fields, we can send a `PATCH'
request to the detail endpoint.:

    curl --dump-header - -H "Content-Type: application/json" -X PATCH --data '{"body": "This actually is my last post."}' http://localhost:8000/api/v1/entry/4/

To which we should get back:

    HTTP/1.0 202 ACCEPTED
    Date: Fri, 20 May 2011 07:13:21 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Length: 0
    Content-Type: text/html; charset=utf-8



File: django-tastypie.info,  Node: Updating A Whole Collection Of Resources PUT<2>,  Prev: Partially Updating An Existing Resource PATCH<2>,  Up: Sending Data<2>

10.3.4 Updating A Whole Collection Of Resources (PUT)
-----------------------------------------------------

You can also, in rare circumstances, update an entire collection of
objects.  By sending a `PUT' request to the list view of a resource,
you can replace the entire collection.

     Warning: This deletes all of the objects first, then creates the
     objects afresh. This is done because determining which objects are
     the same is actually difficult to get correct in the general case
     for all people.

  Send a request like:

    curl --dump-header - -H "Content-Type: application/json" -X PUT --data '{"objects": [{"body": "Welcome to my blog!","id": "1","pub_date": "2011-05-20T00:46:38","resource_uri": "/api/v1/entry/1/","slug": "first-post","title": "First Post","user": "/api/v1/user/1/"},{"body": "I'm really excited to get started with this new blog. It's gonna be great!","id": "3","pub_date": "2011-05-20T00:47:30","resource_uri": "/api/v1/entry/3/","slug": "my-blog","title": "My Blog","user": "/api/v1/user/2/"}]}' http://localhost:8000/api/v1/entry/

And you'll get back a response like:

    HTTP/1.0 204 NO CONTENT
    Date: Fri, 20 May 2011 07:13:21 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Length: 0
    Content-Type: text/html; charset=utf-8



File: django-tastypie.info,  Node: Deleting Data<2>,  Next: Bulk Operations<2>,  Prev: Sending Data<2>,  Up: Interacting With The API<2>

10.4 Deleting Data
==================

No CRUD setup would be complete without the ability to delete
resources/objects.  Deleting also requires significantly less
complicated requests than `POST'/`PUT'.

* Menu:

* Deleting A Single Resource: Deleting A Single Resource<2>.
* Deleting A Whole Collection Of Resources: Deleting A Whole Collection Of Resources<2>.


File: django-tastypie.info,  Node: Deleting A Single Resource<2>,  Next: Deleting A Whole Collection Of Resources<2>,  Up: Deleting Data<2>

10.4.1 Deleting A Single Resource
---------------------------------

We've decided that we don't like the entry we added & edited earlier.
Let's delete it (but leave the other objects alone):

    curl --dump-header - -H "Content-Type: application/json" -X DELETE  http://localhost:8000/api/v1/entry/4/

Once again, we get back the "Accepted" response of a 204:

    HTTP/1.0 204 NO CONTENT
    Date: Fri, 20 May 2011 07:28:01 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Length: 0
    Content-Type: text/html; charset=utf-8

If we request that resource, we get a 410 to show it's no longer there:

    curl --dump-header - http://localhost:8000/api/v1/entry/4/

    HTTP/1.0 410 GONE
    Date: Fri, 20 May 2011 07:29:02 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Type: text/html; charset=utf-8

Additionally, if we try to run the `DELETE' again (using the same
original command), we get the "Gone" response again:

    HTTP/1.0 410 GONE
    Date: Fri, 20 May 2011 07:30:00 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Type: text/html; charset=utf-8



File: django-tastypie.info,  Node: Deleting A Whole Collection Of Resources<2>,  Prev: Deleting A Single Resource<2>,  Up: Deleting Data<2>

10.4.2 Deleting A Whole Collection Of Resources
-----------------------------------------------

Finally, it's possible to remove an entire collection of resources.
This is as destructive as it sounds. Once again, we use the `DELETE'
method, this time on the entire list endpoint:

    curl --dump-header - -H "Content-Type: application/json" -X DELETE  http://localhost:8000/api/v1/entry/

As a response, we get:

    HTTP/1.0 204 NO CONTENT
    Date: Fri, 20 May 2011 07:32:51 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Length: 0
    Content-Type: text/html; charset=utf-8

Hitting the list view:

    curl --dump-header - http://localhost:8000/api/v1/entry/

Gives us a 200 but no objects:

    {
        "meta": {
            "limit": 20,
            "next": null,
            "offset": 0,
            "previous": null,
            "total_count": 0
        },
        "objects": []
    }



File: django-tastypie.info,  Node: Bulk Operations<2>,  Next: You Did It!<2>,  Prev: Deleting Data<2>,  Up: Interacting With The API<2>

10.5 Bulk Operations
====================

As an optimization, it is possible to do many creations, updates, and
deletions to a collection in a single request by sending a `PATCH' to
the list endpoint.:

    curl --dump-header - -H "Content-Type: application/json" -X PATCH --data '{"objects": [{"body": "Surprise! Another post!.", "pub_date": "2012-02-16T00:46:38", "slug": "yet-another-post", "title": "Yet Another Post"}], "deleted_objects": ["http://localhost:8000/api/v1/entry/4/"]}'  http://localhost:8000/api/v1/entry/

We should get back:

    HTTP/1.0 202 ACCEPTED
    Date: Fri, 16 Feb 2012 00:46:38 GMT
    Server: WSGIServer/0.1 Python/2.7
    Content-Length: 0
    Content-Type: text/html; charset=utf-8

The Accepted response means the server has accepted the request, but
gives no details on the result. In order to see any created resources,
we would need to do a get `GET' on the list endpoint.

  For detailed information on the format of a bulk request, see *note
patch_list: 2c.


File: django-tastypie.info,  Node: You Did It!<2>,  Prev: Bulk Operations<2>,  Up: Interacting With The API<2>

10.6 You Did It!
================

That's a whirlwind tour of interacting with a Tastypie API. There's
additional functionality present, such as:

   * `POST'/`PUT' the other supported content-types

   * More filtering/`order_by'/`limit'/`offset' tricks

   * Using overridden URLconfs to support complex or non-PK lookups

   * Authentication

  But this grounds you in the basics & hopefully clarifies
usage/debugging better.


File: django-tastypie.info,  Node: Tastypie Settings<2>,  Next: Using Tastypie With Non-ORM Data Sources<2>,  Prev: Interacting With The API<2>,  Up: Top

11 Tastypie Settings
********************

This is a comprehensive list of the settings Tastypie recognizes.

* Menu:

* API_LIMIT_PER_PAGE: API_LIMIT_PER_PAGE<2>.
* TASTYPIE_FULL_DEBUG: TASTYPIE_FULL_DEBUG<2>.
* TASTYPIE_CANNED_ERROR: TASTYPIE_CANNED_ERROR<2>.
* TASTYPIE_ALLOW_MISSING_SLASH: TASTYPIE_ALLOW_MISSING_SLASH<2>.
* TASTYPIE_DATETIME_FORMATTING: TASTYPIE_DATETIME_FORMATTING<2>.


File: django-tastypie.info,  Node: API_LIMIT_PER_PAGE<2>,  Next: TASTYPIE_FULL_DEBUG<2>,  Up: Tastypie Settings<2>

11.1 `API_LIMIT_PER_PAGE'
=========================

*Optional*

  This setting controls the default number of records Tastypie will show
in a list view.

  This is only used when a user does not specify a `limit' GET
parameter and the `Resource' subclass has not overridden the number to
be shown.

  An example:

    API_LIMIT_PER_PAGE = 50

If you don't want to limit the number of records by default, you can
set this setting to 0:

    API_LIMIT_PER_PAGE = 0

Defaults to 20.


File: django-tastypie.info,  Node: TASTYPIE_FULL_DEBUG<2>,  Next: TASTYPIE_CANNED_ERROR<2>,  Prev: API_LIMIT_PER_PAGE<2>,  Up: Tastypie Settings<2>

11.2 `TASTYPIE_FULL_DEBUG'
==========================

*Optional*

  This setting controls what the behavior is when an unhandled
exception occurs.

  If set to `True' and `settings.DEBUG = True', the standard Django
technical 500 is displayed.

  If not set or set to `False', Tastypie will return a serialized
response.  If `settings.DEBUG' is `True', you'll get the actual
exception message plus a traceback. If `settings.DEBUG' is `False',
Tastypie will call `mail_admins()' and provide a canned error message
(which you can override with `TASTYPIE_CANNED_ERROR') in the response.

  An example:

    TASTYPIE_FULL_DEBUG = True

Defaults to `False'.


File: django-tastypie.info,  Node: TASTYPIE_CANNED_ERROR<2>,  Next: TASTYPIE_ALLOW_MISSING_SLASH<2>,  Prev: TASTYPIE_FULL_DEBUG<2>,  Up: Tastypie Settings<2>

11.3 `TASTYPIE_CANNED_ERROR'
============================

*Optional*

  This setting allows you to override the canned error response when an
unhandled exception is raised and `settings.DEBUG' is `False'.

  An example:

    TASTYPIE_CANNED_ERROR = "Oops, we broke it!"

Defaults to `"Sorry, this request could not be processed. Please try
again later."'.


File: django-tastypie.info,  Node: TASTYPIE_ALLOW_MISSING_SLASH<2>,  Next: TASTYPIE_DATETIME_FORMATTING<2>,  Prev: TASTYPIE_CANNED_ERROR<2>,  Up: Tastypie Settings<2>

11.4 `TASTYPIE_ALLOW_MISSING_SLASH'
===================================

*Optional*

  This setting allows your URLs to be missing the final slash. Useful
for integrating with other systems.

  You must also have `settings.APPEND_SLASH = False' so that Django
does not emit HTTP 302 redirects.

  An example:

    TASTYPIE_ALLOW_MISSING_SLASH = True

Defaults to `False'.


File: django-tastypie.info,  Node: TASTYPIE_DATETIME_FORMATTING<2>,  Prev: TASTYPIE_ALLOW_MISSING_SLASH<2>,  Up: Tastypie Settings<2>

11.5 `TASTYPIE_DATETIME_FORMATTING'
===================================

*Optional*

  This setting allows you to globally choose what format your
datetime/date/time data will be formatted in. Valid options are
`iso-8601' & `rfc-2822'.

  An example:

    TASTYPIE_DATETIME_FORMATTING = 'rfc-2822'

Defaults to `iso-8601'.


File: django-tastypie.info,  Node: Using Tastypie With Non-ORM Data Sources<2>,  Next: Tools<2>,  Prev: Tastypie Settings<2>,  Up: Top

12 Using Tastypie With Non-ORM Data Sources
*******************************************

Much of this documentation demonstrates the use of Tastypie with
Django's ORM.  You might think that Tastypie depended on the ORM, when
in fact, it was purpose-built to handle non-ORM data. This
documentation should help you get started providing APIs using other
data sources.

  Virtually all of the code that makes Tastypie actually process
requests & return data is within the `Resource' class. `ModelResource'
is actually a light wrapper around `Resource' that provides
ORM-specific access. The methods that `ModelResource' overrides are the
same ones you'll need to override when hooking up your data source.

* Menu:

* Approach: Approach<2>.
* Using Riak for MessageResource: Using Riak for MessageResource<2>.


File: django-tastypie.info,  Node: Approach<2>,  Next: Using Riak for MessageResource<2>,  Up: Using Tastypie With Non-ORM Data Sources<2>

12.1 Approach
=============

When working with `Resource', many things are handled for you. All the
authentication/authorization/caching/serialization/throttling bits
should work as normal and Tastypie can support all the REST-style
methods. Schemas & discovery views all work the same as well.

  What you don't get out of the box are the fields you're choosing to
expose & the lowest level data access methods. If you want a full
read-write API, there are nine methods you need to implement. They are:

   * `detail_uri_kwargs'

   * `get_object_list'

   * `obj_get_list'

   * `obj_get'

   * `obj_create'

   * `obj_update'

   * `obj_delete_list'

   * `obj_delete'

   * `rollback'

  If read-only is all you're exposing, you can cut that down to four
methods to override.


File: django-tastypie.info,  Node: Using Riak for MessageResource<2>,  Prev: Approach<2>,  Up: Using Tastypie With Non-ORM Data Sources<2>

12.2 Using Riak for MessageResource
===================================

As an example, we'll take integrating with Riak(1) (a Dynamo-like NoSQL
store) since it has both a simple API and demonstrate what hooking up
to a non-relational datastore looks like:

    # We need a generic object to shove data in/get data from.
    # Riak generally just tosses around dictionaries, so we'll lightly
    # wrap that.
    class RiakObject(object):
        def __init__(self, initial=None):
            self.__dict__['_data'] = {}

            if hasattr(initial, 'items'):
                self.__dict__['_data'] = initial

        def __getattr__(self, name):
            return self._data.get(name, None)

        def __setattr__(self, name, value):
            self.__dict__['_data'][name] = value

        def to_dict(self):
            return self._data


    class MessageResource(Resource):
        # Just like a Django ``Form`` or ``Model``, we're defining all the
        # fields we're going to handle with the API here.
        uuid = fields.CharField(attribute='uuid')
        user_uuid = fields.CharField(attribute='user_uuid')
        message = fields.CharField(attribute='message')
        created = fields.IntegerField(attribute='created')

        class Meta:
            resource_name = 'riak'
            object_class = RiakObject
            authorization = Authorization()

        # Specific to this resource, just to get the needed Riak bits.
        def _client(self):
            return riak.RiakClient()

        def _bucket(self):
            client = self._client()
            # Note that we're hard-coding the bucket to use. Fine for
            # example purposes, but you'll want to abstract this.
            return client.bucket('messages')

        # The following methods will need overriding regardless of your
        # data source.
        def detail_uri_kwargs(self, bundle_or_obj):
            kwargs = {}

            if isinstance(bundle_or_obj, Bundle):
                kwargs['pk'] = bundle_or_obj.obj.uuid
            else:
                kwargs['pk'] = bundle_or_obj.uuid

            return kwargs

        def get_object_list(self, request):
            query = self._client().add('messages')
            query.map("function(v) { var data = JSON.parse(v.values[0].data); return [[v.key, data]]; }")
            results = []

            for result in query.run():
                new_obj = RiakObject(initial=result[1])
                new_obj.uuid = result[0]
                results.append(new_obj)

            return results

        def obj_get_list(self, request=None, **kwargs):
            # Filtering disabled for brevity...
            return self.get_object_list(request)

        def obj_get(self, request=None, **kwargs):
            bucket = self._bucket()
            message = bucket.get(kwargs['pk'])
            return RiakObject(initial=message.get_data())

        def obj_create(self, bundle, request=None, **kwargs):
            bundle.obj = RiakObject(initial=kwargs)
            bundle = self.full_hydrate(bundle)
            bucket = self._bucket()
            new_message = bucket.new(bundle.obj.uuid, data=bundle.obj.to_dict())
            new_message.store()
            return bundle

        def obj_update(self, bundle, request=None, **kwargs):
            return self.obj_create(bundle, request, **kwargs)

        def obj_delete_list(self, request=None, **kwargs):
            bucket = self._bucket()

            for key in bucket.get_keys():
                obj = bucket.get(key)
                obj.delete()

        def obj_delete(self, request=None, **kwargs):
            bucket = self._bucket()
            obj = bucket.get(kwargs['pk'])
            obj.delete()

        def rollback(self, bundles):
            pass

This represents a full, working, Riak-powered API endpoint. All
REST-style actions (GET/POST/PUT/DELETE) all work correctly. The only
shortcut taken in this example was skipping filter-abilty, as adding in
the MapReduce bits would have decreased readability.

  All said and done, just nine methods needed overriding, eight of
which were highly specific to how data access is done.

  ---------- Footnotes ----------

  (1) http://www.basho.com/products_riak_overview.php


File: django-tastypie.info,  Node: Tools<2>,  Next: Testing<2>,  Prev: Using Tastypie With Non-ORM Data Sources<2>,  Up: Top

13 Tools
********

Here are some tools that might help in interacting with the API that
Tastypie provides:

* Menu:

* Browser: Browser<2>.
* Extensions: Extensions<2>.
* Python: Python<2>.
* Javascript: Javascript<2>.

Browser

* JSONView: JSONView<2>.

Extensions

* Tastypie-msgpack: Tastypie-msgpack<2>.

Python

* Slumber: Slumber<2>.
* drest: drest<2>.
* json.tool: json tool<2>.

Javascript

* backbone-tastypie: backbone-tastypie<2>.
* backbone-relational: backbone-relational<2>.


File: django-tastypie.info,  Node: Browser<2>,  Next: Extensions<2>,  Up: Tools<2>

13.1 Browser
============

* Menu:

* JSONView: JSONView<2>.


File: django-tastypie.info,  Node: JSONView<2>,  Up: Browser<2>

13.1.1 JSONView
---------------

   * Firefox -
     <https://addons.mozilla.org/en-US/firefox/addon/jsonview/>

   * Chrome -
     <https://chrome.google.com/webstore/detail/chklaanhfefbnpoihckbnefhakgolnmc>

  A plugin (actually two different ones that closely mirror each other)
that nicely reformats JSON data in the browser.


File: django-tastypie.info,  Node: Extensions<2>,  Next: Python<2>,  Prev: Browser<2>,  Up: Tools<2>

13.2 Extensions
===============

* Menu:

* Tastypie-msgpack: Tastypie-msgpack<2>.


File: django-tastypie.info,  Node: Tastypie-msgpack<2>,  Up: Extensions<2>

13.2.1 Tastypie-msgpack
-----------------------

<https://github.com/stephenmcd/tastypie-msgpack>

  Adds MsgPack(1) support to Tastypie's serializer.

  ---------- Footnotes ----------

  (1) http://msgpack.org/


File: django-tastypie.info,  Node: Python<2>,  Next: Javascript<2>,  Prev: Extensions<2>,  Up: Tools<2>

13.3 Python
===========

* Menu:

* Slumber: Slumber<2>.
* drest: drest<2>.
* json.tool: json tool<2>.


File: django-tastypie.info,  Node: Slumber<2>,  Next: drest<2>,  Up: Python<2>

13.3.1 Slumber
--------------

<http://slumber.in/>

  Slumber is a small Python library that makes it easy to access & work
with APIs. It works for many others, but works especially well with
Tastypie.


File: django-tastypie.info,  Node: drest<2>,  Next: json tool<2>,  Prev: Slumber<2>,  Up: Python<2>

13.3.2 drest
------------

<http://drest.rtfd.org/>

  drest is another small Python library. It focuses on extensibility &
can also work with many different API, with an emphasis on Tastypie.


File: django-tastypie.info,  Node: json tool<2>,  Prev: drest<2>,  Up: Python<2>

13.3.3 json.tool
----------------

Included with Python, this tool makes reformatting JSON easy. For
example:

    $ curl http://localhost:8000/api/v1/note/ | python -m json.tool

Will return nicely reformatted data like:

    {
        "meta": {
            "total_count": 1
        },
        "objects": [
            {
                "content": "Hello world!",
                "user": "/api/v1/user/1/"
            }
        ]
    }



File: django-tastypie.info,  Node: Javascript<2>,  Prev: Python<2>,  Up: Tools<2>

13.4 Javascript
===============

* Menu:

* backbone-tastypie: backbone-tastypie<2>.
* backbone-relational: backbone-relational<2>.


File: django-tastypie.info,  Node: backbone-tastypie<2>,  Next: backbone-relational<2>,  Up: Javascript<2>

13.4.1 backbone-tastypie
------------------------

<https://github.com/PaulUithol/backbone-tastypie>

  A small layer that makes Backbone & Tastypie plan nicely together.


File: django-tastypie.info,  Node: backbone-relational<2>,  Prev: backbone-tastypie<2>,  Up: Javascript<2>

13.4.2 backbone-relational
--------------------------

<https://github.com/PaulUithol/Backbone-relational/>

  Allows Backbone to work with relational data, like the kind of data
Tastypie provides.


File: django-tastypie.info,  Node: Testing<2>,  Next: Compatibility Notes<2>,  Prev: Tools<2>,  Up: Top

14 Testing
**********

Having integrated unit tests that cover your API's behavior is
important, as it helps provide verification that your API code is still
valid & working correctly with the rest of your application.

  Tastypie provides some basic facilities that build on top of Django's
testing(1) support, in the form of a specialized `TestApiClient' &
`ResourceTestCase'.

  The `ResourceTestCase' builds on top of Django's `TestCase'. It
provides quite a few extra assertion methods that are specific to APIs.
Under the hood, it uses the `TestApiClient' to perform requests
properly.

  The `TestApiClient' builds on & exposes an interface similar to that
of Django's `Client'. However, under the hood, it hands all the setup
needed to construct a proper request.

* Menu:

* Example Usage: Example Usage<2>.

Example Usage

* ResourceTestCase API Reference: ResourceTestCase API Reference<2>.
* TestApiClient API Reference: TestApiClient API Reference<2>.

ResourceTestCase API Reference

* get_credentials: get_credentials<2>.
* create_basic: create_basic<2>.
* create_apikey: create_apikey<2>.
* create_digest: create_digest<2>.
* create_oauth: create_oauth<2>.
* assertHttpOK: assertHttpOK<2>.
* assertHttpCreated: assertHttpCreated<2>.
* assertHttpAccepted: assertHttpAccepted<2>.
* assertHttpMultipleChoices: assertHttpMultipleChoices<2>.
* assertHttpSeeOther: assertHttpSeeOther<2>.
* assertHttpNotModified: assertHttpNotModified<2>.
* assertHttpBadRequest: assertHttpBadRequest<2>.
* assertHttpUnauthorized: assertHttpUnauthorized<2>.
* assertHttpForbidden: assertHttpForbidden<2>.
* assertHttpNotFound: assertHttpNotFound<2>.
* assertHttpMethodNotAllowed: assertHttpMethodNotAllowed<2>.
* assertHttpConflict: assertHttpConflict<2>.
* assertHttpGone: assertHttpGone<2>.
* assertHttpTooManyRequests: assertHttpTooManyRequests<2>.
* assertHttpApplicationError: assertHttpApplicationError<2>.
* assertHttpNotImplemented: assertHttpNotImplemented<2>.
* assertValidJSON: assertValidJSON<2>.
* assertValidXML: assertValidXML<2>.
* assertValidYAML: assertValidYAML<2>.
* assertValidPlist: assertValidPlist<2>.
* assertValidJSONResponse: assertValidJSONResponse<2>.
* assertValidXMLResponse: assertValidXMLResponse<2>.
* assertValidYAMLResponse: assertValidYAMLResponse<2>.
* assertValidPlistResponse: assertValidPlistResponse<2>.
* deserialize: deserialize<4>.
* serialize: serialize<4>.
* assertKeys: assertKeys<2>.

TestApiClient API Reference

* __init__: __init__<2>.
* get_content_type: get_content_type<2>.
* get: get<2>.
* post: post<2>.
* put: put<2>.
* patch: patch<2>.
* delete: delete<2>.

  ---------- Footnotes ----------

  (1) https://docs.djangoproject.com/en/dev/topics/testing/


File: django-tastypie.info,  Node: Example Usage<2>,  Up: Testing<2>

14.1 Example Usage
==================

The typical use case will primarily consist of subclassing the
`ResourceTestCase' class & using the built-in assertions to ensure your
API is behaving correctly. For the purposes of this example, we'll
assume the resource in question looks like:

    from tastypie.authentication import BasicAuthentication
    from tastypie.resources import ModelResource
    from entries.models import Entry


    class EntryResource(ModelResource):
        class Meta:
            queryset = Entry.objects.all()
            authentication = BasicAuthentication()

An example usage might look like:

    import datetime
    from django.contrib.auth.models import User
    from tastypie.test import ResourceTestCase
    from entries.models import Entry


    class EntryResourceTest(ResourceTestCase):
        # Use ``fixtures`` & ``urls`` as normal. See Django's ``TestCase``
        # documentation for the gory details.
        fixtures = ['test_entries.json']

        def setUp(self):
            super(EntryResourceTest, self).setUp()

            # Create a user.
            self.username = 'daniel'
            self.password = 'pass'
            self.user = User.objects.create_user(self.username, 'daniel@example.com', self.password)

            # Fetch the ``Entry`` object we'll use in testing.
            # Note that we aren't using PKs because they can change depending
            # on what other tests are running.
            self.entry_1 = Entry.objects.get(slug='first-post')

            # We also build a detail URI, since we will be using it all over.
            # DRY, baby. DRY.
            self.detail_url = '/api/v1/entry/{0}/'.format(self.entry_1.pk)

            # The data we'll send on POST requests. Again, because we'll use it
            # frequently (enough).
            self.post_data = {
                'user': '/api/v1/user/{0}/'.format(self.user.pk),
                'title': 'Second Post!',
                'slug': 'second-post',
                'created': '2012-05-01T22:05:12'
            }

        def get_credentials(self):
            return self.create_basic(username=self.username, password=self.password)

        def test_get_list_unauthorzied(self):
            self.assertHttpUnauthorized(self.api_client.get('/api/v1/entries/', format='json'))

        def test_get_list_json(self):
            resp = self.api_client.get('/api/v1/entries/', format='json', authentication=self.get_credentials())
            self.assertValidJSONResponse(resp)

            # Scope out the data for correctness.
            self.assertEqual(len(self.deserialize(resp)['objects']), 12)
            # Here, we're checking an entire structure for the expected data.
            self.assertEqual(self.deserialize(resp)['objects'][0], {
                'pk': str(self.entry_1.pk),
                'user': '/api/v1/user/{0}/'.format(self.user.pk),
                'title': 'First post',
                'slug': 'first-post',
                'created': '2012-05-01T19:13:42',
                'resource_uri': '/api/v1/entry/{0}/'.format(self.entry_1.pk)
            })

        def test_get_list_xml(self):
            self.assertValidXMLResponse(self.api_client.get('/api/v1/entries/', format='xml', authentication=self.get_credentials()))

        def test_get_detail_unauthenticated(self):
            self.assertHttpUnauthorized(self.api_client.get(self.detail_url, format='json'))

        def test_get_detail_json(self):
            resp = self.api_client.get(self.detail_url, format='json', authentication=self.get_credentials())
            self.assertValidJSONResponse(resp)

            # We use ``assertKeys`` here to just verify the keys, not all the data.
            self.assertKeys(self.deserialize(resp), ['created', 'slug', 'title', 'user'])
            self.assertEqual(self.deserialize(resp)['name'], 'First post')

        def test_get_detail_xml(self):
            self.assertValidXMLResponse(self.api_client.get(self.detail_url, format='xml', authentication=self.get_credentials()))

        def test_post_list_unauthenticated(self):
            self.assertHttpUnauthorized(self.api_client.post('/api/v1/entries/', format='json', data=self.post_data))

        def test_post_list(self):
            # Check how many are there first.
            self.assertEqual(Entry.objects.count(), 5)
            self.assertHttpCreated(self.api_client.post('/api/v1/entries/', format='json', data=self.post_data, authentication=self.get_credentials()))
            # Verify a new one has been added.
            self.assertEqual(Entry.objects.count(), 6)

        def test_put_detail_unauthenticated(self):
            self.assertHttpUnauthorized(self.api_client.put(self.detail_url, format='json', data={}))

        def test_put_detail(self):
            # Grab the current data & modify it slightly.
            original_data = self.deserialize(self.api_client.get(self.detail_url, format='json', authentication=self.get_credentials()))
            new_data = original_data.copy()
            new_data['title'] = 'Updated: First Post'
            new_data['created'] = '2012-05-01T20:06:12'

            self.assertEqual(Entry.objects.count(), 5)
            self.assertHttpAccepted(self.api_client.put(self.detail_url, format='json', data=new_data, authentication=self.get_credentials()))
            # Make sure the count hasn't changed & we did an update.
            self.assertEqual(Entry.objects.count(), 5)
            # Check for updated data.
            self.assertEqual(Entry.objects.get(pk=25).title, 'Updated: First Post')
            self.assertEqual(Entry.objects.get(pk=25).slug, 'first-post')
            self.assertEqual(Entry.objects.get(pk=25).created, datetime.datetime(2012, 3, 1, 13, 6, 12))

        def test_delete_detail_unauthenticated(self):
            self.assertHttpUnauthorized(self.api_client.delete(self.detail_url, format='json'))

        def test_delete_detail(self):
            self.assertEqual(Entry.objects.count(), 5)
            self.assertHttpAccepted(self.api_client.delete(self.detail_url, format='json', authentication=self.get_credentials()))
            self.assertEqual(Entry.objects.count(), 4)

Note that this example doesn't cover other cases, such as filtering,
`PUT' to a list endpoint, `DELETE' to a list endpoint, `PATCH' support,
etc.

* Menu:

* ResourceTestCase API Reference: ResourceTestCase API Reference<2>.
* TestApiClient API Reference: TestApiClient API Reference<2>.

ResourceTestCase API Reference

* get_credentials: get_credentials<2>.
* create_basic: create_basic<2>.
* create_apikey: create_apikey<2>.
* create_digest: create_digest<2>.
* create_oauth: create_oauth<2>.
* assertHttpOK: assertHttpOK<2>.
* assertHttpCreated: assertHttpCreated<2>.
* assertHttpAccepted: assertHttpAccepted<2>.
* assertHttpMultipleChoices: assertHttpMultipleChoices<2>.
* assertHttpSeeOther: assertHttpSeeOther<2>.
* assertHttpNotModified: assertHttpNotModified<2>.
* assertHttpBadRequest: assertHttpBadRequest<2>.
* assertHttpUnauthorized: assertHttpUnauthorized<2>.
* assertHttpForbidden: assertHttpForbidden<2>.
* assertHttpNotFound: assertHttpNotFound<2>.
* assertHttpMethodNotAllowed: assertHttpMethodNotAllowed<2>.
* assertHttpConflict: assertHttpConflict<2>.
* assertHttpGone: assertHttpGone<2>.
* assertHttpTooManyRequests: assertHttpTooManyRequests<2>.
* assertHttpApplicationError: assertHttpApplicationError<2>.
* assertHttpNotImplemented: assertHttpNotImplemented<2>.
* assertValidJSON: assertValidJSON<2>.
* assertValidXML: assertValidXML<2>.
* assertValidYAML: assertValidYAML<2>.
* assertValidPlist: assertValidPlist<2>.
* assertValidJSONResponse: assertValidJSONResponse<2>.
* assertValidXMLResponse: assertValidXMLResponse<2>.
* assertValidYAMLResponse: assertValidYAMLResponse<2>.
* assertValidPlistResponse: assertValidPlistResponse<2>.
* deserialize: deserialize<4>.
* serialize: serialize<4>.
* assertKeys: assertKeys<2>.

TestApiClient API Reference

* __init__: __init__<2>.
* get_content_type: get_content_type<2>.
* get: get<2>.
* post: post<2>.
* put: put<2>.
* patch: patch<2>.
* delete: delete<2>.


File: django-tastypie.info,  Node: ResourceTestCase API Reference<2>,  Next: TestApiClient API Reference<2>,  Up: Example Usage<2>

14.1.1 `ResourceTestCase' API Reference
---------------------------------------

The `ResourceTestCase' exposes the following methods for use. Most are
enhanced assertions or provide API-specific behaviors.

* Menu:

* get_credentials: get_credentials<2>.
* create_basic: create_basic<2>.
* create_apikey: create_apikey<2>.
* create_digest: create_digest<2>.
* create_oauth: create_oauth<2>.
* assertHttpOK: assertHttpOK<2>.
* assertHttpCreated: assertHttpCreated<2>.
* assertHttpAccepted: assertHttpAccepted<2>.
* assertHttpMultipleChoices: assertHttpMultipleChoices<2>.
* assertHttpSeeOther: assertHttpSeeOther<2>.
* assertHttpNotModified: assertHttpNotModified<2>.
* assertHttpBadRequest: assertHttpBadRequest<2>.
* assertHttpUnauthorized: assertHttpUnauthorized<2>.
* assertHttpForbidden: assertHttpForbidden<2>.
* assertHttpNotFound: assertHttpNotFound<2>.
* assertHttpMethodNotAllowed: assertHttpMethodNotAllowed<2>.
* assertHttpConflict: assertHttpConflict<2>.
* assertHttpGone: assertHttpGone<2>.
* assertHttpTooManyRequests: assertHttpTooManyRequests<2>.
* assertHttpApplicationError: assertHttpApplicationError<2>.
* assertHttpNotImplemented: assertHttpNotImplemented<2>.
* assertValidJSON: assertValidJSON<2>.
* assertValidXML: assertValidXML<2>.
* assertValidYAML: assertValidYAML<2>.
* assertValidPlist: assertValidPlist<2>.
* assertValidJSONResponse: assertValidJSONResponse<2>.
* assertValidXMLResponse: assertValidXMLResponse<2>.
* assertValidYAMLResponse: assertValidYAMLResponse<2>.
* assertValidPlistResponse: assertValidPlistResponse<2>.
* deserialize: deserialize<4>.
* serialize: serialize<4>.
* assertKeys: assertKeys<2>.


File: django-tastypie.info,  Node: get_credentials<2>,  Next: create_basic<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.1 `get_credentials'
..........................

 -- Method: ResourceTestCase.get_credentials (self)

  A convenience method for the user as a way to shorten up the often
repetitious calls to create the same authentication.

  Raises `NotImplementedError' by default.

  Usage:

    class MyResourceTestCase(ResourceTestCase):
        def get_credentials(self):
            return self.create_basic('daniel', 'pass')

        # Then the usual tests...



File: django-tastypie.info,  Node: create_basic<2>,  Next: create_apikey<2>,  Prev: get_credentials<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.2 `create_basic'
.......................

 -- Method: ResourceTestCase.create_basic (self, username, password)

  Creates & returns the HTTP `Authorization' header for use with BASIC
Auth.


File: django-tastypie.info,  Node: create_apikey<2>,  Next: create_digest<2>,  Prev: create_basic<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.3 `create_apikey'
........................

 -- Method: ResourceTestCase.create_apikey (self, username, api_key)

  Creates & returns the HTTP `Authorization' header for use with
`ApiKeyAuthentication'.


File: django-tastypie.info,  Node: create_digest<2>,  Next: create_oauth<2>,  Prev: create_apikey<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.4 `create_digest'
........................

 -- Method: ResourceTestCase.create_digest (self, username, api_key,
          method, uri)

  Creates & returns the HTTP `Authorization' header for use with Digest
Auth.


File: django-tastypie.info,  Node: create_oauth<2>,  Next: assertHttpOK<2>,  Prev: create_digest<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.5 `create_oauth'
.......................

 -- Method: ResourceTestCase.create_oauth (self, user)

  Creates & returns the HTTP `Authorization' header for use with Oauth.


File: django-tastypie.info,  Node: assertHttpOK<2>,  Next: assertHttpCreated<2>,  Prev: create_oauth<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.6 `assertHttpOK'
.......................

 -- Method: ResourceTestCase.assertHttpOK (self, resp)

  Ensures the response is returning a HTTP 200.


File: django-tastypie.info,  Node: assertHttpCreated<2>,  Next: assertHttpAccepted<2>,  Prev: assertHttpOK<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.7 `assertHttpCreated'
............................

 -- Method: ResourceTestCase.assertHttpCreated (self, resp)

  Ensures the response is returning a HTTP 201.


File: django-tastypie.info,  Node: assertHttpAccepted<2>,  Next: assertHttpMultipleChoices<2>,  Prev: assertHttpCreated<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.8 `assertHttpAccepted'
.............................

 -- Method: ResourceTestCase.assertHttpAccepted (self, resp)

  Ensures the response is returning either a HTTP 202 or a HTTP 204.


File: django-tastypie.info,  Node: assertHttpMultipleChoices<2>,  Next: assertHttpSeeOther<2>,  Prev: assertHttpAccepted<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.9 `assertHttpMultipleChoices'
....................................

 -- Method: ResourceTestCase.assertHttpMultipleChoices (self, resp)

  Ensures the response is returning a HTTP 300.


File: django-tastypie.info,  Node: assertHttpSeeOther<2>,  Next: assertHttpNotModified<2>,  Prev: assertHttpMultipleChoices<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.10 `assertHttpSeeOther'
..............................

 -- Method: ResourceTestCase.assertHttpSeeOther (self, resp)

  Ensures the response is returning a HTTP 303.


File: django-tastypie.info,  Node: assertHttpNotModified<2>,  Next: assertHttpBadRequest<2>,  Prev: assertHttpSeeOther<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.11 `assertHttpNotModified'
.................................

 -- Method: ResourceTestCase.assertHttpNotModified (self, resp)

  Ensures the response is returning a HTTP 304.


File: django-tastypie.info,  Node: assertHttpBadRequest<2>,  Next: assertHttpUnauthorized<2>,  Prev: assertHttpNotModified<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.12 `assertHttpBadRequest'
................................

 -- Method: ResourceTestCase.assertHttpBadRequest (self, resp)

  Ensures the response is returning a HTTP 400.


File: django-tastypie.info,  Node: assertHttpUnauthorized<2>,  Next: assertHttpForbidden<2>,  Prev: assertHttpBadRequest<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.13 `assertHttpUnauthorized'
..................................

 -- Method: ResourceTestCase.assertHttpUnauthorized (self, resp)

  Ensures the response is returning a HTTP 401.


File: django-tastypie.info,  Node: assertHttpForbidden<2>,  Next: assertHttpNotFound<2>,  Prev: assertHttpUnauthorized<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.14 `assertHttpForbidden'
...............................

 -- Method: ResourceTestCase.assertHttpForbidden (self, resp)

  Ensures the response is returning a HTTP 403.


File: django-tastypie.info,  Node: assertHttpNotFound<2>,  Next: assertHttpMethodNotAllowed<2>,  Prev: assertHttpForbidden<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.15 `assertHttpNotFound'
..............................

 -- Method: ResourceTestCase.assertHttpNotFound (self, resp)

  Ensures the response is returning a HTTP 404.


File: django-tastypie.info,  Node: assertHttpMethodNotAllowed<2>,  Next: assertHttpConflict<2>,  Prev: assertHttpNotFound<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.16 `assertHttpMethodNotAllowed'
......................................

 -- Method: ResourceTestCase.assertHttpMethodNotAllowed (self, resp)

  Ensures the response is returning a HTTP 405.


File: django-tastypie.info,  Node: assertHttpConflict<2>,  Next: assertHttpGone<2>,  Prev: assertHttpMethodNotAllowed<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.17 `assertHttpConflict'
..............................

 -- Method: ResourceTestCase.assertHttpConflict (self, resp)

  Ensures the response is returning a HTTP 409.


File: django-tastypie.info,  Node: assertHttpGone<2>,  Next: assertHttpTooManyRequests<2>,  Prev: assertHttpConflict<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.18 `assertHttpGone'
..........................

 -- Method: ResourceTestCase.assertHttpGone (self, resp)

  Ensures the response is returning a HTTP 410.


File: django-tastypie.info,  Node: assertHttpTooManyRequests<2>,  Next: assertHttpApplicationError<2>,  Prev: assertHttpGone<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.19 `assertHttpTooManyRequests'
.....................................

 -- Method: ResourceTestCase.assertHttpTooManyRequests (self, resp)

  Ensures the response is returning a HTTP 429.


File: django-tastypie.info,  Node: assertHttpApplicationError<2>,  Next: assertHttpNotImplemented<2>,  Prev: assertHttpTooManyRequests<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.20 `assertHttpApplicationError'
......................................

 -- Method: ResourceTestCase.assertHttpApplicationError (self, resp)

  Ensures the response is returning a HTTP 500.


File: django-tastypie.info,  Node: assertHttpNotImplemented<2>,  Next: assertValidJSON<2>,  Prev: assertHttpApplicationError<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.21 `assertHttpNotImplemented'
....................................

 -- Method: ResourceTestCase.assertHttpNotImplemented (self, resp)

  Ensures the response is returning a HTTP 501.


File: django-tastypie.info,  Node: assertValidJSON<2>,  Next: assertValidXML<2>,  Prev: assertHttpNotImplemented<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.22 `assertValidJSON'
...........................

 -- Method: ResourceTestCase.assertValidJSON (self, data)

  Given the provided `data' as a string, ensures that it is valid JSON &
can be loaded properly.


File: django-tastypie.info,  Node: assertValidXML<2>,  Next: assertValidYAML<2>,  Prev: assertValidJSON<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.23 `assertValidXML'
..........................

 -- Method: ResourceTestCase.assertValidXML (self, data)

  Given the provided `data' as a string, ensures that it is valid XML &
can be loaded properly.


File: django-tastypie.info,  Node: assertValidYAML<2>,  Next: assertValidPlist<2>,  Prev: assertValidXML<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.24 `assertValidYAML'
...........................

 -- Method: ResourceTestCase.assertValidYAML (self, data)

  Given the provided `data' as a string, ensures that it is valid YAML &
can be loaded properly.


File: django-tastypie.info,  Node: assertValidPlist<2>,  Next: assertValidJSONResponse<2>,  Prev: assertValidYAML<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.25 `assertValidPlist'
............................

 -- Method: ResourceTestCase.assertValidPlist (self, data)

  Given the provided `data' as a string, ensures that it is valid
binary plist & can be loaded properly.


File: django-tastypie.info,  Node: assertValidJSONResponse<2>,  Next: assertValidXMLResponse<2>,  Prev: assertValidPlist<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.26 `assertValidJSONResponse'
...................................

 -- Method: ResourceTestCase.assertValidJSONResponse (self, resp)

  Given a `HttpResponse' coming back from using the `client', assert
that you get back:

   * An HTTP 200

   * The correct content-type (`application/json')

   * The content is valid JSON


File: django-tastypie.info,  Node: assertValidXMLResponse<2>,  Next: assertValidYAMLResponse<2>,  Prev: assertValidJSONResponse<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.27 `assertValidXMLResponse'
..................................

 -- Method: ResourceTestCase.assertValidXMLResponse (self, resp)

  Given a `HttpResponse' coming back from using the `client', assert
that you get back:

   * An HTTP 200

   * The correct content-type (`application/xml')

   * The content is valid XML


File: django-tastypie.info,  Node: assertValidYAMLResponse<2>,  Next: assertValidPlistResponse<2>,  Prev: assertValidXMLResponse<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.28 `assertValidYAMLResponse'
...................................

 -- Method: ResourceTestCase.assertValidYAMLResponse (self, resp)

  Given a `HttpResponse' coming back from using the `client', assert
that you get back:

   * An HTTP 200

   * The correct content-type (`text/yaml')

   * The content is valid YAML


File: django-tastypie.info,  Node: assertValidPlistResponse<2>,  Next: deserialize<4>,  Prev: assertValidYAMLResponse<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.29 `assertValidPlistResponse'
....................................

 -- Method: ResourceTestCase.assertValidPlistResponse (self, resp)

  Given a `HttpResponse' coming back from using the `client', assert
that you get back:

   * An HTTP 200

   * The correct content-type (`application/x-plist')

   * The content is valid binary plist data


File: django-tastypie.info,  Node: deserialize<4>,  Next: serialize<4>,  Prev: assertValidPlistResponse<2>,  Up: ResourceTestCase API Reference<2>

14.1.1.30 `deserialize'
.......................

 -- Method: ResourceTestCase.deserialize (self, resp)

  Given a `HttpResponse' coming back from using the `client', this
method checks the `Content-Type' header & attempts to deserialize the
data based on that.

  It returns a Python datastructure (typically a `dict') of the
serialized data.


File: django-tastypie.info,  Node: serialize<4>,  Next: assertKeys<2>,  Prev: deserialize<4>,  Up: ResourceTestCase API Reference<2>

14.1.1.31 `serialize'
.....................

 -- Method: ResourceTestCase.serialize (self, data,
          format='application/json')

  Given a Python datastructure (typically a `dict') & a desired
content-type, this method will return a serialized string of that data.


File: django-tastypie.info,  Node: assertKeys<2>,  Prev: serialize<4>,  Up: ResourceTestCase API Reference<2>

14.1.1.32 `assertKeys'
......................

 -- Method: ResourceTestCase.assertKeys (self, data, expected)

  This method ensures that the keys of the `data' match up to the keys
of `expected'.

  It covers the (extremely) common case where you want to make sure the
keys of a response match up to what is expected. This is typically less
fragile than testing the full structure, which can be prone to data
changes.


File: django-tastypie.info,  Node: TestApiClient API Reference<2>,  Prev: ResourceTestCase API Reference<2>,  Up: Example Usage<2>

14.1.2 `TestApiClient' API Reference
------------------------------------

The `TestApiClient' simulates a HTTP client making calls to the API.
It's important to note that it uses Django's testing infrastructure, so
it's not making actual calls against a webserver.

* Menu:

* __init__: __init__<2>.
* get_content_type: get_content_type<2>.
* get: get<2>.
* post: post<2>.
* put: put<2>.
* patch: patch<2>.
* delete: delete<2>.


File: django-tastypie.info,  Node: __init__<2>,  Next: get_content_type<2>,  Up: TestApiClient API Reference<2>

14.1.2.1 `__init__'
...................

 -- Method: TestApiClient.__init__ (self, serializer=None)

  Sets up a fresh `TestApiClient' instance.

  If you are employing a custom serializer, you can pass the class to
the `serializer=' kwarg.


File: django-tastypie.info,  Node: get_content_type<2>,  Next: get<2>,  Prev: __init__<2>,  Up: TestApiClient API Reference<2>

14.1.2.2 `get_content_type'
...........................

 -- Method: TestApiClient.get_content_type (self, short_format)

  Given a short name (such as `json' or `xml'), returns the full
content-type for it (`application/json' or `application/xml' in this
case).


File: django-tastypie.info,  Node: get<2>,  Next: post<2>,  Prev: get_content_type<2>,  Up: TestApiClient API Reference<2>

14.1.2.3 `get'
..............

 -- Method: TestApiClient.get (self, uri, format='json', data=None,
          authentication=None, **kwargs)

  Performs a simulated `GET' request to the provided URI.

  Optionally accepts a `data' kwarg, which in the case of `GET', lets
you send along `GET' parameters. This is useful when testing filtering
or other things that read off the `GET' params. Example:

    from tastypie.test import TestApiClient
    client = TestApiClient()

    response = client.get('/api/v1/entry/1/', data={'format': 'json', 'title__startswith': 'a', 'limit': 20, 'offset': 60})

Optionally accepts an `authentication' kwarg, which should be an HTTP
header with the correct authentication data already setup.

  All other `**kwargs' passed in get passed through to the Django
`TestClient'. See
<https://docs.djangoproject.com/en/dev/topics/testing/#module-django.test.client>
for details.


File: django-tastypie.info,  Node: post<2>,  Next: put<2>,  Prev: get<2>,  Up: TestApiClient API Reference<2>

14.1.2.4 `post'
...............

 -- Method: TestApiClient.post (self, uri, format='json', data=None,
          authentication=None, **kwargs)

  Performs a simulated `POST' request to the provided URI.

  Optionally accepts a `data' kwarg. *Unlike* `GET', in `POST' the
`data' gets serialized & sent as the body instead of becoming part of
the URI.  Example:

    from tastypie.test import TestApiClient
    client = TestApiClient()

    response = client.post('/api/v1/entry/', data={
        'created': '2012-05-01T20:02:36',
        'slug': 'another-post',
        'title': 'Another Post',
        'user': '/api/v1/user/1/',
    })

Optionally accepts an `authentication' kwarg, which should be an HTTP
header with the correct authentication data already setup.

  All other `**kwargs' passed in get passed through to the Django
`TestClient'. See
<https://docs.djangoproject.com/en/dev/topics/testing/#module-django.test.client>
for details.


File: django-tastypie.info,  Node: put<2>,  Next: patch<2>,  Prev: post<2>,  Up: TestApiClient API Reference<2>

14.1.2.5 `put'
..............

 -- Method: TestApiClient.put (self, uri, format='json', data=None,
          authentication=None, **kwargs)

  Performs a simulated `PUT' request to the provided URI.

  Optionally accepts a `data' kwarg. *Unlike* `GET', in `PUT' the
`data' gets serialized & sent as the body instead of becoming part of
the URI.  Example:

    from tastypie.test import TestApiClient
    client = TestApiClient()

    response = client.put('/api/v1/entry/1/', data={
        'created': '2012-05-01T20:02:36',
        'slug': 'another-post',
        'title': 'Another Post',
        'user': '/api/v1/user/1/',
    })

Optionally accepts an `authentication' kwarg, which should be an HTTP
header with the correct authentication data already setup.

  All other `**kwargs' passed in get passed through to the Django
`TestClient'. See
<https://docs.djangoproject.com/en/dev/topics/testing/#module-django.test.client>
for details.


File: django-tastypie.info,  Node: patch<2>,  Next: delete<2>,  Prev: put<2>,  Up: TestApiClient API Reference<2>

14.1.2.6 `patch'
................

 -- Method: TestApiClient.patch (self, uri, format='json', data=None,
          authentication=None, **kwargs)

  Performs a simulated `PATCH' request to the provided URI.

  Optionally accepts a `data' kwarg. *Unlike* `GET', in `PATCH' the
`data' gets serialized & sent as the body instead of becoming part of
the URI.  Example:

    from tastypie.test import TestApiClient
    client = TestApiClient()

    response = client.patch('/api/v1/entry/1/', data={
        'created': '2012-05-01T20:02:36',
        'slug': 'another-post',
        'title': 'Another Post',
        'user': '/api/v1/user/1/',
    })

Optionally accepts an `authentication' kwarg, which should be an HTTP
header with the correct authentication data already setup.

  All other `**kwargs' passed in get passed through to the Django
`TestClient'. See
<https://docs.djangoproject.com/en/dev/topics/testing/#module-django.test.client>
for details.


File: django-tastypie.info,  Node: delete<2>,  Prev: patch<2>,  Up: TestApiClient API Reference<2>

14.1.2.7 `delete'
.................

 -- Method: TestApiClient.delete (self, uri, format='json', data=None,
          authentication=None, **kwargs)

  Performs a simulated `DELETE' request to the provided URI.

  Optionally accepts a `data' kwarg, which in the case of `DELETE',
lets you send along `DELETE' parameters. This is useful when testing
filtering or other things that read off the `DELETE' params. Example:

    from tastypie.test import TestApiClient
    client = TestApiClient()

    response = client.delete('/api/v1/entry/1/', data={'format': 'json'})

Optionally accepts an `authentication' kwarg, which should be an HTTP
header with the correct authentication data already setup.

  All other `**kwargs' passed in get passed through to the Django
`TestClient'. See
<https://docs.djangoproject.com/en/dev/topics/testing/#module-django.test.client>
for details.


File: django-tastypie.info,  Node: Compatibility Notes<2>,  Next: Resources<2>,  Prev: Testing<2>,  Up: Top

15 Compatibility Notes
**********************

Tastypie does its best to be a good third-party app, trying to
interoperate with the widest range of Django environments it can.
However, there are times where certain things aren't possible. We'll do
our best to document them here.

* Menu:

* ApiKey Database Index: ApiKey Database Index<2>.


File: django-tastypie.info,  Node: ApiKey Database Index<2>,  Up: Compatibility Notes<2>

15.1 `ApiKey' Database Index
============================

When the `ApiKey' model was added to Tastypie, an index was lacking on
the `key' field. This was the case until the v0.9.12 release. The model
was updated & a migration was added (`0002_add_apikey_index.py').
However, due to the way MySQL works & the way Django generates index
names, this migration would fail miserably on many MySQL installs.

  If you are using MySQL, South & the `ApiKey' authentication class,
you should manually add an index for the the `ApiKey.key' field.
Something to the effect of:

    BEGIN; -- LOLMySQL
    CREATE INDEX tastypie_apikey_key_index ON tastypie_apikey (`key`);
    COMMIT;



File: django-tastypie.info,  Node: Resources<2>,  Next: Bundles<2>,  Prev: Compatibility Notes<2>,  Up: Top

16 Resources
************

In terms of a REST-style architecture, a "resource" is a collection of
similar data. This data could be a table of a database, a collection of
other resources or a similar form of data storage. In Tastypie, these
resources are generally intermediaries between the end user & objects,
usually Django models. As such, `Resource' (and its model-specific twin
`ModelResource') form the heart of Tastypie's functionality.

* Menu:

* Quick Start: Quick Start<5>.
* Why Class-Based?: Why Class-Based?<2>.
* Why Resource vs. ModelResource?: Why Resource vs ModelResource?<2>.
* Flow Through The Request/Response Cycle: Flow Through The Request/Response Cycle<2>.
* Why Resource URIs?: Why Resource URIs?<2>.
* Advanced Data Preparation: Advanced Data Preparation<2>.
* Reverse "Relationships": Reverse "Relationships"<2>.
* Resource Options (AKA Meta): Resource Options AKA Meta<2>.
* Basic Filtering: Basic Filtering<2>.
* Advanced Filtering: Advanced Filtering<2>.
* Using PUT/DELETE/PATCH In Unsupported Places: Using PUT/DELETE/PATCH In Unsupported Places<2>.
* Resource Methods: Resource Methods<2>.
* ModelResource Methods: ModelResource Methods<2>.


File: django-tastypie.info,  Node: Quick Start<5>,  Next: Why Class-Based?<2>,  Up: Resources<2>

16.1 Quick Start
================

A sample resource definition might look something like:

    from django.contrib.auth.models import User
    from tastypie import fields
    from tastypie.authorization import DjangoAuthorization
    from tastypie.resources import ModelResource, ALL, ALL_WITH_RELATIONS
    from myapp.models import Entry


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']


    class EntryResource(ModelResource):
        user = fields.ForeignKey(UserResource, 'user')

        class Meta:
            queryset = Entry.objects.all()
            list_allowed_methods = ['get', 'post']
            detail_allowed_methods = ['get', 'post', 'put', 'delete']
            resource_name = 'myapp/entry'
            authorization = DjangoAuthorization()
            filtering = {
                'slug': ALL,
                'user': ALL_WITH_RELATIONS,
                'created': ['exact', 'range', 'gt', 'gte', 'lt', 'lte'],
            }



File: django-tastypie.info,  Node: Why Class-Based?<2>,  Next: Why Resource vs ModelResource?<2>,  Prev: Quick Start<5>,  Up: Resources<2>

16.2 Why Class-Based?
=====================

Using class-based resources make it easier to extend/modify the code to
meet your needs. APIs are rarely a one-size-fits-all problem space, so
Tastypie tries to get the fundamentals right and provide you with
enough hooks to customize things to work your way.

  As is standard, this raises potential problems for thread-safety.
Tastypie has been designed to minimize the possibility of data
"leaking" between threads.  This does however sometimes introduce some
small complexities & you should be careful not to store state on the
instances if you're going to be using the code in a threaded
environment.


File: django-tastypie.info,  Node: Why Resource vs ModelResource?<2>,  Next: Flow Through The Request/Response Cycle<2>,  Prev: Why Class-Based?<2>,  Up: Resources<2>

16.3 Why `Resource' vs. `ModelResource'?
========================================

Make no mistake that Django models are far and away the most popular
source of data. However, in practice, there are many times where the
ORM isn't the data source. Hooking up things like a NoSQL store (see
*note Using Tastypie With Non-ORM Data Sources: 37.), a search solution
like Haystack or even managed filesystem data are all good use cases
for `Resource' knowing nothing about the ORM.


File: django-tastypie.info,  Node: Flow Through The Request/Response Cycle<2>,  Next: Why Resource URIs?<2>,  Prev: Why Resource vs ModelResource?<2>,  Up: Resources<2>

16.4 Flow Through The Request/Response Cycle
============================================

Tastypie can be thought of as a set of class-based views that provide
the API functionality. As such, many part of the request/response cycle
are standard Django behaviors. For instance, all
routing/middleware/response-handling aspects are the same as a typical
Django app. Where it differs is in the view itself.

  As an example, we'll walk through what a GET request to a list
endpoint (say `/api/v1/user/?format=json') looks like:

   * The `Resource.urls' are checked by Django's url resolvers.

   * On a match for the list view,
     `Resource.wrap_view('dispatch_list')' is called. `wrap_view'
     provides basic error handling & allows for returning serialized
     errors.

   * Because `dispatch_list' was passed to `wrap_view',
     `Resource.dispatch_list' is called next. This is a thin wrapper
     around `Resource.dispatch'.

   * `dispatch' does a bunch of heavy lifting. It ensures:

        * the requested HTTP method is in `allowed_methods'
          (`method_check'),

        * the class has a method that can handle the request
          (`get_list'),

        * the user is authenticated (`is_authenticated'),

        * the user is authorized (`is_authorized'),

        * & the user has not exceeded their throttle (`throttle_check').

     At this point, `dispatch' actually calls the requested method
     (`get_list').

   * `get_list' does the actual work of the API. It does:

        * A fetch of the available objects via `Resource.obj_get_list'.
          In the case of `ModelResource', this builds the ORM filters
          to apply (`ModelResource.build_filters'). It then gets the
          `QuerySet' via `ModelResource.get_object_list' (which performs
          `Resource.apply_authorization_limits' to possibly limit the
          set the user can work with) and applies the built filters to
          it.

        * It then sorts the objects based on user input
          (`ModelResource.apply_sorting').

        * Then it paginates the results using the supplied `Paginator'
          & pulls out the data to be serialized.

        * The objects in the page have `full_dehydrate' applied to each
          of them, causing Tastypie to translate the raw object data
          into the fields the endpoint supports.

        * Finally, it calls `Resource.create_response'.

   * `create_response' is a shortcut method that:

        * Determines the desired response format
          (`Resource.determine_format'),

        * Serializes the data given to it in the proper format,

        * And returns a Django `HttpResponse' (200 OK) with the
          serialized data.

   * We bubble back up the call stack to `dispatch'. The last thing
     `dispatch' does is potentially store that a request occurred for
     future throttling (`Resource.log_throttled_access') then either
     returns the `HttpResponse' or wraps whatever data came back in a
     response (so Django doesn't freak out).

  Processing on other endpoints or using the other HTTP methods results
in a similar cycle, usually differing only in what "actual work" method
gets called (which follows the format of
"`<http_method>_<list_or_detail>'"). In the case of POST/PUT, the
`hydrate' cycle additionally takes place and is used to take the user
data & convert it to raw data for storage.


File: django-tastypie.info,  Node: Why Resource URIs?<2>,  Next: Advanced Data Preparation<2>,  Prev: Flow Through The Request/Response Cycle<2>,  Up: Resources<2>

16.5 Why Resource URIs?
=======================

Resource URIs play a heavy role in how Tastypie delivers data. This can
seem very different from other solutions which simply inline related
data. Though Tastypie can inline data like that (using `full=True' on
the field with the relation), the default is to provide URIs.

  URIs are useful because it results in smaller payloads, letting you
fetch only the data that is important to you. You can imagine an
instance where an object has thousands of related items that you may
not be interested in.

  URIs are also very cache-able, because the data at each endpoint is
less likely to frequently change.

  And URIs encourage proper use of each endpoint to display the data
that endpoint covers.

  Ideology aside, you should use whatever suits you. If you prefer
fewer requests & fewer endpoints, use of `full=True' is available, but
be aware of the consequences of each approach.


File: django-tastypie.info,  Node: Advanced Data Preparation<2>,  Next: Reverse "Relationships"<2>,  Prev: Why Resource URIs?<2>,  Up: Resources<2>

16.6 Advanced Data Preparation
==============================

Not all data can be easily pull off an object/model attribute. And
sometimes, you (or the client) may need to send data that doesn't
neatly fit back into the data model on the server side. For this,
Tastypie has the "dehydrate/hydrate" cycle.

* Menu:

* The Dehydrate Cycle: The Dehydrate Cycle<2>.
* The Hydrate Cycle: The Hydrate Cycle<2>.

The Dehydrate Cycle

* Per-field dehydrate: Per-field dehydrate<2>.
* dehydrate_FOO: dehydrate_FOO<2>.
* dehydrate: dehydrate<3>.

The Hydrate Cycle

* hydrate: hydrate<3>.
* hydrate_FOO: hydrate_FOO<2>.
* Per-field hydrate: Per-field hydrate<2>.


File: django-tastypie.info,  Node: The Dehydrate Cycle<2>,  Next: The Hydrate Cycle<2>,  Up: Advanced Data Preparation<2>

16.6.1 The Dehydrate Cycle
--------------------------

Tastypie uses a "dehydrate" cycle to prepare data for serialization,
which is to say that it takes the raw, potentially complicated data
model & turns it into a (generally simpler) processed data structure
for client consumption.  This usually means taking a complex data
object & turning it into a dictionary of simple data types.

  Broadly speaking, this takes the `bundle.obj' instance & builds
`bundle.data', which is what is actually serialized.

  The cycle looks like:

   * Put the data model into a `Bundle' instance, which is then passed
     through the various methods.

   * Run through all fields on the `Resource', letting each field
     perform its own `dehydrate' method on the `bundle'.

   * While processing each field, look for a `dehydrate_<fieldname>'
     method on the `Resource'. If it's present, call it with the
     `bundle'.

   * Finally, after all fields are processed, if the `dehydrate' method
     is present on the `Resource', it is called & given the entire
     `bundle'.

  The goal of this cycle is to populate the `bundle.data' dictionary
with data suitable for serialization. With the exception of the
`alter_*' methods (as hooks to manipulate the overall structure), this
cycle controls what is actually handed off to be serialized & sent to
the client.

* Menu:

* Per-field dehydrate: Per-field dehydrate<2>.
* dehydrate_FOO: dehydrate_FOO<2>.
* dehydrate: dehydrate<3>.


File: django-tastypie.info,  Node: Per-field dehydrate<2>,  Next: dehydrate_FOO<2>,  Up: The Dehydrate Cycle<2>

16.6.1.1 Per-field `dehydrate'
..............................

Each field (even custom `ApiField' subclasses) has its own `dehydrate'
method. If it knows how to access data (say, given the `attribute'
kwarg), it will attempt to populate values itself.

  The return value is put in the `bundle.data' dictionary (by the
`Resource') with the fieldname as the key.


File: django-tastypie.info,  Node: dehydrate_FOO<2>,  Next: dehydrate<3>,  Prev: Per-field dehydrate<2>,  Up: The Dehydrate Cycle<2>

16.6.1.2 `dehydrate_FOO'
........................

Since not all data may be ready for consumption based on just attribute
access (or may require an advanced lookup/calculation), this hook
enables you to fill in data or massage whatever the field generated.

     Note: The `FOO' here is not literal. Instead, it is a placeholder
     that should be replaced with the fieldname in question.

  Defining these methods is especially common when denormalizing
related data, providing statistics or filling in unrelated data.

  A simple example:

    class MyResource(ModelResource):
        # The ``title`` field is already added to the class by ``ModelResource``
        # and populated off ``Note.title``. But we want allcaps titles...

        class Meta:
            queryset = Note.objects.all()

        def dehydrate_title(self, bundle):
            return bundle.data['title'].upper()

A complex example:

    class MyResource(ModelResource):
        # As is, this is just an empty field. Without the ``dehydrate_rating``
        # method, no data would be populated for it.
        rating = fields.FloatField(readonly=True)

        class Meta:
            queryset = Note.objects.all()

        def dehydrate_rating(self, bundle):
            total_score = 0.0

            # Make sure we don't have to worry about "divide by zero" errors.
            if not bundle.obj.rating_set.count():
                return rating

            # We'll run over all the ``Rating`` objects & calculate an average.
            for rating in bundle.obj.rating_set.all():
                total_score += rating.rating

            return total_score /  bundle.obj.rating_set.count()

The return value is updated in the `bundle.data'. You should avoid
altering `bundle.data' here if you can help it.


File: django-tastypie.info,  Node: dehydrate<3>,  Prev: dehydrate_FOO<2>,  Up: The Dehydrate Cycle<2>

16.6.1.3 `dehydrate'
....................

The `dehydrate' method takes a now fully-populated `bundle.data' & make
any last alterations to it. This is useful for when a piece of data
might depend on more than one field, if you want to shove in extra data
that isn't worth having its own field or if you want to dynamically
remove things from the data to be returned.

  A simple example:

    class MyResource(ModelResource):
        class Meta:
            queryset = Note.objects.all()

        def dehydrate(self, bundle):
            # Include the request IP in the bundle.
            bundle.data['request_ip'] = bundle.request.META.get('REMOTE_ADDR')
            return bundle

A complex example:

    class MyResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            excludes = ['email', 'password', 'is_staff', 'is_superuser']

        def dehydrate(self, bundle):
            # If they're requesting their own record, add in their email address.
            if bundle.request.user.pk == bundle.obj.pk:
                # Note that there isn't an ``email`` field on the ``Resource``.
                # By this time, it doesn't matter, as the built data will no
                # longer be checked against the fields on the ``Resource``.
                bundle.data['email'] = bundle.obj.email

            return bundle

This method should return a `bundle', whether it modifies the existing
one or creates a whole new one. You can even remove any/all data from
the `bundle.data' if you wish.


File: django-tastypie.info,  Node: The Hydrate Cycle<2>,  Prev: The Dehydrate Cycle<2>,  Up: Advanced Data Preparation<2>

16.6.2 The Hydrate Cycle
------------------------

Tastypie uses a "hydrate" cycle to take serializated data from the
client and turn it into something the data model can use. This is the
reverse process from the `dehydrate' cycle. In fact, by default,
Tastypie's serialized data should be "round-trip-able", meaning the
data that comes out should be able to be fed back in & result in the
same original data model. This usually means taking a dictionary of
simple data types & turning it into a complex data object.

  Broadly speaking, this takes the recently-deserialized `bundle.data'
dictionary & builds `bundle.obj' (but does *NOT* save it).

  The cycle looks like:

   * Put the data from the client into a `Bundle' instance, which is
     then passed through the various methods.

   * If the `hydrate' method is present on the `Resource', it is called
     & given the entire `bundle'.

   * Then run through all fields on the `Resource', look for a
     `hydrate_<fieldname>' method on the `Resource'. If it's present,
     call it with the `bundle'.

   * Finally after all other processing is done, while processing each
     field, let each field perform its own `hydrate' method on the
     `bundle'.

  The goal of this cycle is to populate the `bundle.obj' data model
with data suitable for saving/persistence. Again, with the exception of
the `alter_*' methods (as hooks to manipulate the overall structure),
this cycle controls how the data from the client is interpreted &
placed on the data model.

* Menu:

* hydrate: hydrate<3>.
* hydrate_FOO: hydrate_FOO<2>.
* Per-field hydrate: Per-field hydrate<2>.


File: django-tastypie.info,  Node: hydrate<3>,  Next: hydrate_FOO<2>,  Up: The Hydrate Cycle<2>

16.6.2.1 `hydrate'
..................

The `hydrate' method allows you to make initial changes to the
`bundle.obj'.  This includes things like prepopulating fields you don't
expose over the API, recalculating related data or mangling data.

  Example:

    class MyResource(ModelResource):
        # The ``title`` field is already added to the class by ``ModelResource``
        # and populated off ``Note.title``. We'll use that title to build a
        # ``Note.slug`` as well.

        class Meta:
            queryset = Note.objects.all()

        def hydrate(self, bundle):
            # Don't change existing slugs.
            # In reality, this would be better implemented at the ``Note.save``
            # level, but is for demonstration.
            if not bundle.obj.pk:
                bundle.obj.slug = slugify(bundle.data['title'])

            return bundle

This method should return a `bundle', whether it modifies the existing
one or creates a whole new one. You can even remove any/all data from
the `bundle.obj' if you wish.


File: django-tastypie.info,  Node: hydrate_FOO<2>,  Next: Per-field hydrate<2>,  Prev: hydrate<3>,  Up: The Hydrate Cycle<2>

16.6.2.2 `hydrate_FOO'
......................

Data from the client may not map directly onto the data model or might
need augmentation. This hook lets you take that data & convert it.

     Note: The `FOO' here is not literal. Instead, it is a placeholder
     that should be replaced with the fieldname in question.

  A simple example:

    class MyResource(ModelResource):
        # The ``title`` field is already added to the class by ``ModelResource``
        # and populated off ``Note.title``. But we want lowercase titles...

        class Meta:
            queryset = Note.objects.all()

        def hydrate_title(self, bundle):
            bundle.data['title'] = bundle.data['title'].lower()
            return bundle

The return value is the `bundle'.


File: django-tastypie.info,  Node: Per-field hydrate<2>,  Prev: hydrate_FOO<2>,  Up: The Hydrate Cycle<2>

16.6.2.3 Per-field `hydrate'
............................

Each field (even custom `ApiField' subclasses) has its own `hydrate'
method. If it knows how to access data (say, given the `attribute'
kwarg), it will attempt to take data from the `bundle.data' & assign it
on the data model.

  The return value is put in the `bundle.obj' attribute for that
fieldname.


File: django-tastypie.info,  Node: Reverse "Relationships"<2>,  Next: Resource Options AKA Meta<2>,  Prev: Advanced Data Preparation<2>,  Up: Resources<2>

16.7 Reverse "Relationships"
============================

Unlike Django's ORM, Tastypie does not automatically create reverse
relations.  This is because there is substantial technical complexity
involved, as well as perhaps unintentionally exposing related data in
an incorrect way to the end user of the API.

  However, it is still possible to create reverse relations. Instead of
handing the `ToOneField' or `ToManyField' a class, pass them a string
that represents the full path to the desired class. Implementing a
reverse relationship looks like so:

    # myapp/api/resources.py
    from tastypie import fields
    from tastypie.resources import ModelResource
    from myapp.models import Note, Comment


    class NoteResource(ModelResource):
        comments = fields.ToManyField('myapp.api.resources.CommentResource', 'comments')

        class Meta:
            queryset = Note.objects.all()


    class CommentResource(ModelResource):
        note = fields.ToOneField(NoteResource, 'notes')

        class Meta:
            queryset = Comment.objects.all()


     Warning: Unlike Django, you can't use just the class name (i.e.
     `'CommentResource''), even if it's in the same module. Tastypie
     (intentionally) lacks a construct like the `AppCache' which makes
     that sort of thing work in Django. Sorry.

  Tastypie also supports self-referential relations. If you assume we
added the appropriate self-referential `ForeignKey' to the `Note'
model, implementing a similar relation in Tastypie would look like:

    # myapp/api/resources.py
    from tastypie import fields
    from tastypie.resources import ModelResource
    from myapp.models import Note


    class NoteResource(ModelResource):
        sub_notes = fields.ToManyField('self', 'notes')

        class Meta:
            queryset = Note.objects.all()



File: django-tastypie.info,  Node: Resource Options AKA Meta<2>,  Next: Basic Filtering<2>,  Prev: Reverse "Relationships"<2>,  Up: Resources<2>

16.8 Resource Options (AKA `Meta')
==================================

The inner `Meta' class allows for class-level configuration of how the
`Resource' should behave. The following options are available:

* Menu:

* serializer: serializer<2>.
* authentication: authentication<2>.
* authorization: authorization<2>.
* validation: validation<2>.
* paginator_class: paginator_class<2>.
* cache: cache<2>.
* throttle: throttle<2>.
* allowed_methods: allowed_methods<2>.
* list_allowed_methods: list_allowed_methods<2>.
* detail_allowed_methods: detail_allowed_methods<2>.
* limit: limit<2>.
* max_limit: max_limit<2>.
* api_name: api_name<2>.
* resource_name: resource_name<2>.
* default_format: default_format<2>.
* filtering: filtering<2>.
* ordering: ordering<2>.
* object_class: object_class<2>.
* queryset: queryset<2>.
* fields: fields<2>.
* excludes: excludes<2>.
* include_resource_uri: include_resource_uri<2>.
* include_absolute_url: include_absolute_url<2>.
* always_return_data: always_return_data<2>.
* collection_name: collection_name<2>.
* detail_uri_name: detail_uri_name<2>.


File: django-tastypie.info,  Node: serializer<2>,  Next: authentication<2>,  Up: Resource Options AKA Meta<2>

16.8.1 `serializer'
-------------------

     Controls which serializer class the `Resource' should use. Default
     is `tastypie.serializers.Serializer()'.


File: django-tastypie.info,  Node: authentication<2>,  Next: authorization<2>,  Prev: serializer<2>,  Up: Resource Options AKA Meta<2>

16.8.2 `authentication'
-----------------------

     Controls which authentication class the `Resource' should use.
     Default is `tastypie.authentication.Authentication()'.


File: django-tastypie.info,  Node: authorization<2>,  Next: validation<2>,  Prev: authentication<2>,  Up: Resource Options AKA Meta<2>

16.8.3 `authorization'
----------------------

     Controls which authorization class the `Resource' should use.
     Default is `tastypie.authorization.ReadOnlyAuthorization()'.


File: django-tastypie.info,  Node: validation<2>,  Next: paginator_class<2>,  Prev: authorization<2>,  Up: Resource Options AKA Meta<2>

16.8.4 `validation'
-------------------

     Controls which validation class the `Resource' should use. Default
     is `tastypie.validation.Validation()'.


File: django-tastypie.info,  Node: paginator_class<2>,  Next: cache<2>,  Prev: validation<2>,  Up: Resource Options AKA Meta<2>

16.8.5 `paginator_class'
------------------------

     Controls which paginator class the `Resource' should use. Default
     is `tastypie.paginator.Paginator'.

     Note: This is different than the other options in that you supply
     a class rather than an instance. This is done because the
     Paginator has some per-request initialization options.


File: django-tastypie.info,  Node: cache<2>,  Next: throttle<2>,  Prev: paginator_class<2>,  Up: Resource Options AKA Meta<2>

16.8.6 `cache'
--------------

     Controls which cache class the `Resource' should use. Default is
     `tastypie.cache.NoCache()'.


File: django-tastypie.info,  Node: throttle<2>,  Next: allowed_methods<2>,  Prev: cache<2>,  Up: Resource Options AKA Meta<2>

16.8.7 `throttle'
-----------------

     Controls which throttle class the `Resource' should use. Default is
     `tastypie.throttle.BaseThrottle()'.


File: django-tastypie.info,  Node: allowed_methods<2>,  Next: list_allowed_methods<2>,  Prev: throttle<2>,  Up: Resource Options AKA Meta<2>

16.8.8 `allowed_methods'
------------------------

     Controls what list & detail REST methods the `Resource' should
     respond to.  Default is `None', which means delegate to the more
     specific `list_allowed_methods' & `detail_allowed_methods' options.

     You may specify a list like `['get', 'post', 'put', 'delete',
     'patch']' as a shortcut to prevent having to specify the other
     options.


File: django-tastypie.info,  Node: list_allowed_methods<2>,  Next: detail_allowed_methods<2>,  Prev: allowed_methods<2>,  Up: Resource Options AKA Meta<2>

16.8.9 `list_allowed_methods'
-----------------------------

     Controls what list REST methods the `Resource' should respond to.
     Default is `['get', 'post', 'put', 'delete', 'patch']'.


File: django-tastypie.info,  Node: detail_allowed_methods<2>,  Next: limit<2>,  Prev: list_allowed_methods<2>,  Up: Resource Options AKA Meta<2>

16.8.10 `detail_allowed_methods'
--------------------------------

     Controls what detail REST methods the `Resource' should respond
     to. Default is `['get', 'post', 'put', 'delete', 'patch']'.


File: django-tastypie.info,  Node: limit<2>,  Next: max_limit<2>,  Prev: detail_allowed_methods<2>,  Up: Resource Options AKA Meta<2>

16.8.11 `limit'
---------------

     Controls how many results the `Resource' will show at a time.
     Default is either the `API_LIMIT_PER_PAGE' setting (if provided)
     or `20' if not specified.


File: django-tastypie.info,  Node: max_limit<2>,  Next: api_name<2>,  Prev: limit<2>,  Up: Resource Options AKA Meta<2>

16.8.12 `max_limit'
-------------------

     Controls the maximum number of results the `Resource' will show at
     a time.  If the user-specified `limit' is higher than this, it
     will be capped to this limit. Set to `0' or `None' to allow
     unlimited results.


File: django-tastypie.info,  Node: api_name<2>,  Next: resource_name<2>,  Prev: max_limit<2>,  Up: Resource Options AKA Meta<2>

16.8.13 `api_name'
------------------

     An override for the `Resource' to use when generating resource
     URLs.  Default is `None'.


File: django-tastypie.info,  Node: resource_name<2>,  Next: default_format<2>,  Prev: api_name<2>,  Up: Resource Options AKA Meta<2>

16.8.14 `resource_name'
-----------------------

     An override for the `Resource' to use when generating resource
     URLs.  Default is `None'.

     If not provided, the `Resource' or `ModelResource' will attempt to
     name itself. This means a lowercase version of the classname
     preceding the word `Resource' if present (i.e.
     `SampleContentResource' would become `samplecontent').


File: django-tastypie.info,  Node: default_format<2>,  Next: filtering<2>,  Prev: resource_name<2>,  Up: Resource Options AKA Meta<2>

16.8.15 `default_format'
------------------------

     Specifies the default serialization format the `Resource' should
     use if one is not requested (usually by the `Accept' header or
     `format' GET parameter). Default is `application/json'.


File: django-tastypie.info,  Node: filtering<2>,  Next: ordering<2>,  Prev: default_format<2>,  Up: Resource Options AKA Meta<2>

16.8.16 `filtering'
-------------------

     Provides a list of fields that the `Resource' will accept client
     filtering on. Default is `{}'.

     Keys should be the fieldnames as strings while values should be a
     list of accepted filter types.


File: django-tastypie.info,  Node: ordering<2>,  Next: object_class<2>,  Prev: filtering<2>,  Up: Resource Options AKA Meta<2>

16.8.17 `ordering'
------------------

     Specifies the what fields the `Resource' should should allow
     ordering on.  Default is `[]'.

     Values should be the fieldnames as strings. When provided to the
     `Resource' by the `order_by' GET parameter, you can specify either
     the `fieldname' (ascending order) or `-fieldname' (descending
     order).


File: django-tastypie.info,  Node: object_class<2>,  Next: queryset<2>,  Prev: ordering<2>,  Up: Resource Options AKA Meta<2>

16.8.18 `object_class'
----------------------

     Provides the `Resource' with the object that serves as the data
     source.  Default is `None'.

     In the case of `ModelResource', this is automatically populated by
     the `queryset' option and is the model class.


File: django-tastypie.info,  Node: queryset<2>,  Next: fields<2>,  Prev: object_class<2>,  Up: Resource Options AKA Meta<2>

16.8.19 `queryset'
------------------

     Provides the `Resource' with the set of Django models to respond
     with.  Default is `None'.

     Unused by `Resource' but present for consistency.

     Warning: If you place any callables in this, they'll only be
     evaluated once (when the `Meta' class is instantiated). This
     especially affects things that are date/time related. Please see
     the :ref:cookbook for a way around this.


File: django-tastypie.info,  Node: fields<2>,  Next: excludes<2>,  Prev: queryset<2>,  Up: Resource Options AKA Meta<2>

16.8.20 `fields'
----------------

     Controls what introspected fields the `Resource' should include.
     A whitelist of fields. Default is `[]'.


File: django-tastypie.info,  Node: excludes<2>,  Next: include_resource_uri<2>,  Prev: fields<2>,  Up: Resource Options AKA Meta<2>

16.8.21 `excludes'
------------------

     Controls what introspected fields the `Resource' should _NOT_
     include.  A blacklist of fields. Default is `[]'.


File: django-tastypie.info,  Node: include_resource_uri<2>,  Next: include_absolute_url<2>,  Prev: excludes<2>,  Up: Resource Options AKA Meta<2>

16.8.22 `include_resource_uri'
------------------------------

     Specifies if the `Resource' should include an extra field that
     displays the detail URL (within the api) for that resource.
     Default is `True'.


File: django-tastypie.info,  Node: include_absolute_url<2>,  Next: always_return_data<2>,  Prev: include_resource_uri<2>,  Up: Resource Options AKA Meta<2>

16.8.23 `include_absolute_url'
------------------------------

     Specifies if the `Resource' should include an extra field that
     displays the `get_absolute_url' for that object (on the site
     proper). Default is `False'.


File: django-tastypie.info,  Node: always_return_data<2>,  Next: collection_name<2>,  Prev: include_absolute_url<2>,  Up: Resource Options AKA Meta<2>

16.8.24 `always_return_data'
----------------------------

     Specifies all HTTP methods (except `DELETE') should return a
     serialized form of the data. Default is `False'.

     If `False', `HttpNoContent' (204) is returned on `POST/PUT' with
     an empty body & a `Location' header of where to request the full
     resource.

     If `True', `HttpAccepted' (202) is returned on `POST/PUT' with a
     body containing all the data in a serialized form.


File: django-tastypie.info,  Node: collection_name<2>,  Next: detail_uri_name<2>,  Prev: always_return_data<2>,  Up: Resource Options AKA Meta<2>

16.8.25 `collection_name'
-------------------------

     Specifies the collection of objects returned in the `GET' list
     will be named. Default is `objects'.


File: django-tastypie.info,  Node: detail_uri_name<2>,  Prev: collection_name<2>,  Up: Resource Options AKA Meta<2>

16.8.26 `detail_uri_name'
-------------------------

     Specifies the name for the regex group that matches on detail
     views. Defaults to `pk'.


File: django-tastypie.info,  Node: Basic Filtering<2>,  Next: Advanced Filtering<2>,  Prev: Resource Options AKA Meta<2>,  Up: Resources<2>

16.9 Basic Filtering
====================

`ModelResource' provides a basic Django ORM filter interface. Simply
list the resource fields which you'd like to filter on and the allowed
expression in a `filtering' property of your resource's Meta class:

    from tastypie.constants import ALL, ALL_WITH_RELATIONS

    class MyResource(ModelResource):
        class Meta:
            filtering = {
                "slug": ('exact', 'startswith',),
                "title": ALL,
            }

Valid filtering values are: Django ORM filters (e.g. `startswith',
`exact', `lte', etc. or the `ALL' or `ALL_WITH_RELATIONS' constants
defined in `tastypie.constants'.

  These filters will be extracted from URL query strings using the same
double-underscore syntax as the Django ORM:

    /api/v1/myresource/?slug=myslug
    /api/v1/myresource/?slug__startswith=test



File: django-tastypie.info,  Node: Advanced Filtering<2>,  Next: Using PUT/DELETE/PATCH In Unsupported Places<2>,  Prev: Basic Filtering<2>,  Up: Resources<2>

16.10 Advanced Filtering
========================

If you need to filter things other than ORM resources or wish to apply
additional constraints (e.g. text filtering using `django-haystack
<http://haystacksearch.org>' rather than simple database queries) your
`Resource' may define a custom `build_filters()' method which allows
you to filter the queryset before processing a request:

    from haystack.query import SearchQuerySet

    class MyResource(Resource):
        def build_filters(self, filters=None):
            if filters is None:
                filters = {}

            orm_filters = super(MyResource, self).build_filters(filters)

            if "q" in filters:
                sqs = SearchQuerySet().auto_query(filters['q'])

                orm_filters["pk__in"] = [i.pk for i in sqs]

            return orm_filters



File: django-tastypie.info,  Node: Using PUT/DELETE/PATCH In Unsupported Places<2>,  Next: Resource Methods<2>,  Prev: Advanced Filtering<2>,  Up: Resources<2>

16.11 Using PUT/DELETE/PATCH In Unsupported Places
==================================================

Some places, like in certain browsers or hosts, don't allow the
`PUT/DELETE/PATCH' methods. In these environments, you can simulate
those kinds of requests by providing an `X-HTTP-Method-Override'
header. For example, to send a `PATCH' request over `POST', you'd send
a request like:

    curl --dump-header - -H "Content-Type: application/json" -H "X-HTTP-Method-Override: PATCH" -X POST --data '{"title": "I Visited Grandma Today"}' http://localhost:8000/api/v1/entry/1/



File: django-tastypie.info,  Node: Resource Methods<2>,  Next: ModelResource Methods<2>,  Prev: Using PUT/DELETE/PATCH In Unsupported Places<2>,  Up: Resources<2>

16.12 `Resource' Methods
========================

Handles the data, request dispatch and responding to requests.

  Serialization/deserialization is handled "at the edges" (i.e. at the
beginning/end of the request/response cycle) so that everything
internally is Python data structures.

  This class tries to be non-model specific, so it can be hooked up to
other data sources, such as search results, files, other data, etc.

* Menu:

* wrap_view: wrap_view<2>.
* base_urls: base_urls<2>.
* override_urls: override_urls<3>.
* prepend_urls: prepend_urls<3>.
* urls: urls<3>.
* determine_format: determine_format<2>.
* serialize: serialize<5>.
* deserialize: deserialize<5>.
* alter_list_data_to_serialize: alter_list_data_to_serialize<2>.
* alter_detail_data_to_serialize: alter_detail_data_to_serialize<2>.
* alter_deserialized_list_data: alter_deserialized_list_data<2>.
* alter_deserialized_detail_data: alter_deserialized_detail_data<2>.
* dispatch_list: dispatch_list<2>.
* dispatch_detail: dispatch_detail<2>.
* dispatch: dispatch<2>.
* remove_api_resource_names: remove_api_resource_names<2>.
* method_check: method_check<2>.
* is_authorized: is_authorized<2>.
* is_authenticated: is_authenticated<2>.
* throttle_check: throttle_check<2>.
* log_throttled_access: log_throttled_access<2>.
* build_bundle: build_bundle<2>.
* build_filters: build_filters<3>.
* apply_sorting: apply_sorting<3>.
* get_bundle_detail_data: get_bundle_detail_data<2>.
* get_resource_uri: get_resource_uri<3>.
* resource_uri_kwargs: resource_uri_kwargs<2>.
* detail_uri_kwargs: detail_uri_kwargs<2>.
* get_via_uri: get_via_uri<2>.
* full_dehydrate: full_dehydrate<2>.
* dehydrate: dehydrate<4>.
* full_hydrate: full_hydrate<2>.
* hydrate: hydrate<4>.
* hydrate_m2m: hydrate_m2m<2>.
* build_schema: build_schema<2>.
* dehydrate_resource_uri: dehydrate_resource_uri<2>.
* generate_cache_key: generate_cache_key<2>.
* get_object_list: get_object_list<3>.
* apply_authorization_limits: apply_authorization_limits<2>.
* can_create: can_create<2>.
* can_update: can_update<2>.
* can_delete: can_delete<2>.
* apply_filters: apply_filters<3>.
* obj_get_list: obj_get_list<3>.
* cached_obj_get_list: cached_obj_get_list<2>.
* obj_get: obj_get<3>.
* cached_obj_get: cached_obj_get<2>.
* obj_create: obj_create<3>.
* lookup_kwargs_with_identifiers: lookup_kwargs_with_identifiers<2>.
* obj_update: obj_update<3>.
* obj_delete_list: obj_delete_list<3>.
* obj_delete: obj_delete<3>.
* create_response: create_response<2>.
* is_valid: is_valid<2>.
* rollback: rollback<3>.
* get_list: get_list<2>.
* get_detail: get_detail<2>.
* put_list: put_list<2>.
* put_detail: put_detail<2>.
* post_list: post_list<2>.
* post_detail: post_detail<2>.
* delete_list: delete_list<2>.
* delete_detail: delete_detail<2>.
* patch_list: patch_list<2>.
* patch_detail: patch_detail<2>.
* get_schema: get_schema<2>.
* get_multiple: get_multiple<2>.


File: django-tastypie.info,  Node: wrap_view<2>,  Next: base_urls<2>,  Up: Resource Methods<2>

16.12.1 `wrap_view'
-------------------

 -- Method: Resource.wrap_view (self, view)

  Wraps methods so they can be called in a more functional way as well
as handling exceptions better.

  Note that if `BadRequest' or an exception with a `response' attr are
seen, there is special handling to either present a message back to the
user or return the response traveling with the exception.


File: django-tastypie.info,  Node: base_urls<2>,  Next: override_urls<3>,  Prev: wrap_view<2>,  Up: Resource Methods<2>

16.12.2 `base_urls'
-------------------

 -- Method: Resource.base_urls (self)

  The standard URLs this `Resource' should respond to. These include the
list, detail, schema & multiple endpoints by default.

  Should return a list of individual URLconf lines (*NOT* wrapped in
`patterns').


File: django-tastypie.info,  Node: override_urls<3>,  Next: prepend_urls<3>,  Prev: base_urls<2>,  Up: Resource Methods<2>

16.12.3 `override_urls'
-----------------------

 -- Method: Resource.override_urls (self)

  Deprecated. Will be removed by v1.0.0. Please use
`Resource.prepend_urls' instead.


File: django-tastypie.info,  Node: prepend_urls<3>,  Next: urls<3>,  Prev: override_urls<3>,  Up: Resource Methods<2>

16.12.4 `prepend_urls'
----------------------

 -- Method: Resource.prepend_urls (self)

  A hook for adding your own URLs or matching before the default URLs.
Useful for adding custom endpoints or overriding the built-in ones
(from `base_urls').

  Should return a list of individual URLconf lines (*NOT* wrapped in
`patterns').


File: django-tastypie.info,  Node: urls<3>,  Next: determine_format<2>,  Prev: prepend_urls<3>,  Up: Resource Methods<2>

16.12.5 `urls'
--------------

 -- Method: Resource.urls (self)

  _Property_

  The endpoints this `Resource' responds to. A combination of
`base_urls' & `override_urls'.

  Mostly a standard URLconf, this is suitable for either automatic use
when registered with an `Api' class or for including directly in a
URLconf should you choose to.


File: django-tastypie.info,  Node: determine_format<2>,  Next: serialize<5>,  Prev: urls<3>,  Up: Resource Methods<2>

16.12.6 `determine_format'
--------------------------

 -- Method: Resource.determine_format (self, request)

  Used to determine the desired format.

  Largely relies on `tastypie.utils.mime.determine_format' but here as
a point of extension.


File: django-tastypie.info,  Node: serialize<5>,  Next: deserialize<5>,  Prev: determine_format<2>,  Up: Resource Methods<2>

16.12.7 `serialize'
-------------------

 -- Method: Resource.serialize (self, request, data, format,
          options=None)

  Given a request, data and a desired format, produces a serialized
version suitable for transfer over the wire.

  Mostly a hook, this uses the `Serializer' from `Resource._meta'.


File: django-tastypie.info,  Node: deserialize<5>,  Next: alter_list_data_to_serialize<2>,  Prev: serialize<5>,  Up: Resource Methods<2>

16.12.8 `deserialize'
---------------------

 -- Method: Resource.deserialize (self, request, data,
          format='application/json')

  Given a request, data and a format, deserializes the given data.

  It relies on the request properly sending a `CONTENT_TYPE' header,
falling back to `application/json' if not provided.

  Mostly a hook, this uses the `Serializer' from `Resource._meta'.


File: django-tastypie.info,  Node: alter_list_data_to_serialize<2>,  Next: alter_detail_data_to_serialize<2>,  Prev: deserialize<5>,  Up: Resource Methods<2>

16.12.9 `alter_list_data_to_serialize'
--------------------------------------

 -- Method: Resource.alter_list_data_to_serialize (self, request, data)

  A hook to alter list data just before it gets serialized & sent to
the user.

  Useful for restructuring/renaming aspects of the what's going to be
sent.

  Should accommodate for a list of objects, generally also including
meta data.


File: django-tastypie.info,  Node: alter_detail_data_to_serialize<2>,  Next: alter_deserialized_list_data<2>,  Prev: alter_list_data_to_serialize<2>,  Up: Resource Methods<2>

16.12.10 `alter_detail_data_to_serialize'
-----------------------------------------

 -- Method: Resource.alter_detail_data_to_serialize (self, request,
          data)

  A hook to alter detail data just before it gets serialized & sent to
the user.

  Useful for restructuring/renaming aspects of the what's going to be
sent.

  Should accommodate for receiving a single bundle of data.


File: django-tastypie.info,  Node: alter_deserialized_list_data<2>,  Next: alter_deserialized_detail_data<2>,  Prev: alter_detail_data_to_serialize<2>,  Up: Resource Methods<2>

16.12.11 `alter_deserialized_list_data'
---------------------------------------

 -- Method: Resource.alter_deserialized_list_data (self, request, data)

  A hook to alter list data just after it has been received from the
user & gets deserialized.

  Useful for altering the user data before any hydration is applied.


File: django-tastypie.info,  Node: alter_deserialized_detail_data<2>,  Next: dispatch_list<2>,  Prev: alter_deserialized_list_data<2>,  Up: Resource Methods<2>

16.12.12 `alter_deserialized_detail_data'
-----------------------------------------

 -- Method: Resource.alter_deserialized_detail_data (self, request,
          data)

  A hook to alter detail data just after it has been received from the
user & gets deserialized.

  Useful for altering the user data before any hydration is applied.


File: django-tastypie.info,  Node: dispatch_list<2>,  Next: dispatch_detail<2>,  Prev: alter_deserialized_detail_data<2>,  Up: Resource Methods<2>

16.12.13 `dispatch_list'
------------------------

 -- Method: Resource.dispatch_list (self, request, **kwargs)

  A view for handling the various HTTP methods (GET/POST/PUT/DELETE)
over the entire list of resources.

  Relies on `Resource.dispatch' for the heavy-lifting.


File: django-tastypie.info,  Node: dispatch_detail<2>,  Next: dispatch<2>,  Prev: dispatch_list<2>,  Up: Resource Methods<2>

16.12.14 `dispatch_detail'
--------------------------

 -- Method: Resource.dispatch_detail (self, request, **kwargs)

  A view for handling the various HTTP methods (GET/POST/PUT/DELETE) on
a single resource.

  Relies on `Resource.dispatch' for the heavy-lifting.


File: django-tastypie.info,  Node: dispatch<2>,  Next: remove_api_resource_names<2>,  Prev: dispatch_detail<2>,  Up: Resource Methods<2>

16.12.15 `dispatch'
-------------------

 -- Method: Resource.dispatch (self, request_type, request, **kwargs)

  Handles the common operations (allowed HTTP method, authentication,
throttling, method lookup) surrounding most CRUD interactions.


File: django-tastypie.info,  Node: remove_api_resource_names<2>,  Next: method_check<2>,  Prev: dispatch<2>,  Up: Resource Methods<2>

16.12.16 `remove_api_resource_names'
------------------------------------

 -- Method: Resource.remove_api_resource_names (self, url_dict)

  Given a dictionary of regex matches from a URLconf, removes
`api_name' and/or `resource_name' if found.

  This is useful for converting URLconf matches into something suitable
for data lookup. For example:

    Model.objects.filter(**self.remove_api_resource_names(matches))



File: django-tastypie.info,  Node: method_check<2>,  Next: is_authorized<2>,  Prev: remove_api_resource_names<2>,  Up: Resource Methods<2>

16.12.17 `method_check'
-----------------------

 -- Method: Resource.method_check (self, request, allowed=None)

  Ensures that the HTTP method used on the request is allowed to be
handled by the resource.

  Takes an `allowed' parameter, which should be a list of lowercase
HTTP methods to check against. Usually, this looks like:

    # The most generic lookup.
    self.method_check(request, self._meta.allowed_methods)

    # A lookup against what's allowed for list-type methods.
    self.method_check(request, self._meta.list_allowed_methods)

    # A useful check when creating a new endpoint that only handles
    # GET.
    self.method_check(request, ['get'])



File: django-tastypie.info,  Node: is_authorized<2>,  Next: is_authenticated<2>,  Prev: method_check<2>,  Up: Resource Methods<2>

16.12.18 `is_authorized'
------------------------

 -- Method: Resource.is_authorized (self, request, object=None)

  Handles checking of permissions to see if the user has authorization
to GET, POST, PUT, or DELETE this resource.  If `object' is provided,
the authorization backend can apply additional row-level permissions
checking.


File: django-tastypie.info,  Node: is_authenticated<2>,  Next: throttle_check<2>,  Prev: is_authorized<2>,  Up: Resource Methods<2>

16.12.19 `is_authenticated'
---------------------------

 -- Method: Resource.is_authenticated (self, request)

  Handles checking if the user is authenticated and dealing with
unauthenticated users.

  Mostly a hook, this uses class assigned to `authentication' from
`Resource._meta'.


File: django-tastypie.info,  Node: throttle_check<2>,  Next: log_throttled_access<2>,  Prev: is_authenticated<2>,  Up: Resource Methods<2>

16.12.20 `throttle_check'
-------------------------

 -- Method: Resource.throttle_check (self, request)

  Handles checking if the user should be throttled.

  Mostly a hook, this uses class assigned to `throttle' from
`Resource._meta'.


File: django-tastypie.info,  Node: log_throttled_access<2>,  Next: build_bundle<2>,  Prev: throttle_check<2>,  Up: Resource Methods<2>

16.12.21 `log_throttled_access'
-------------------------------

 -- Method: Resource.log_throttled_access (self, request)

  Handles the recording of the user's access for throttling purposes.

  Mostly a hook, this uses class assigned to `throttle' from
`Resource._meta'.


File: django-tastypie.info,  Node: build_bundle<2>,  Next: build_filters<3>,  Prev: log_throttled_access<2>,  Up: Resource Methods<2>

16.12.22 `build_bundle'
-----------------------

 -- Method: Resource.build_bundle (self, obj=None, data=None,
          request=None)

  Given either an object, a data dictionary or both, builds a `Bundle'
for use throughout the `dehydrate/hydrate' cycle.

  If no object is provided, an empty object from
`Resource._meta.object_class' is created so that attempts to access
`bundle.obj' do not fail.


File: django-tastypie.info,  Node: build_filters<3>,  Next: apply_sorting<3>,  Prev: build_bundle<2>,  Up: Resource Methods<2>

16.12.23 `build_filters'
------------------------

 -- Method: Resource.build_filters (self, filters=None)

  Allows for the filtering of applicable objects.

  _This needs to be implemented at the user level._

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: apply_sorting<3>,  Next: get_bundle_detail_data<2>,  Prev: build_filters<3>,  Up: Resource Methods<2>

16.12.24 `apply_sorting'
------------------------

 -- Method: Resource.apply_sorting (self, obj_list, options=None)

  Allows for the sorting of objects being returned.

  _This needs to be implemented at the user level._

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: get_bundle_detail_data<2>,  Next: get_resource_uri<3>,  Prev: apply_sorting<3>,  Up: Resource Methods<2>

16.12.25 `get_bundle_detail_data'
---------------------------------

 -- Method: Resource.get_bundle_detail_data (self, bundle)

  Convenience method to return the `detail_uri_name' attribute off
`bundle.obj'.

  Usually just accesses `bundle.obj.pk' by default.


File: django-tastypie.info,  Node: get_resource_uri<3>,  Next: resource_uri_kwargs<2>,  Prev: get_bundle_detail_data<2>,  Up: Resource Methods<2>

16.12.26 `get_resource_uri'
---------------------------

 -- Method: Resource.get_resource_uri (self, bundle_or_obj=None,
          url_name='api_dispatch_list')

  Handles generating a resource URI.

  If the `bundle_or_obj' argument is not provided, it builds the URI
for the list endpoint.

  If the `bundle_or_obj' argument is provided, it builds the URI for
the detail endpoint.

  Return the generated URI. If that URI can not be reversed (not found
in the URLconf), it will return an empty string.


File: django-tastypie.info,  Node: resource_uri_kwargs<2>,  Next: detail_uri_kwargs<2>,  Prev: get_resource_uri<3>,  Up: Resource Methods<2>

16.12.27 `resource_uri_kwargs'
------------------------------

 -- Method: Resource.resource_uri_kwargs (self, bundle_or_obj=None)

  Handles generating a resource URI.

  If the `bundle_or_obj' argument is not provided, it builds the URI
for the list endpoint.

  If the `bundle_or_obj' argument is provided, it builds the URI for
the detail endpoint.

  Return the generated URI. If that URI can not be reversed (not found
in the URLconf), it will return `None'.


File: django-tastypie.info,  Node: detail_uri_kwargs<2>,  Next: get_via_uri<2>,  Prev: resource_uri_kwargs<2>,  Up: Resource Methods<2>

16.12.28 `detail_uri_kwargs'
----------------------------

 -- Method: Resource.detail_uri_kwargs (self, bundle_or_obj)

  This needs to be implemented at the user level.

  Given a `Bundle' or an object, it returns the extra kwargs needed to
generate a detail URI.

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: get_via_uri<2>,  Next: full_dehydrate<2>,  Prev: detail_uri_kwargs<2>,  Up: Resource Methods<2>

16.12.29 `get_via_uri'
----------------------

 -- Method: Resource.get_via_uri (self, uri, request=None)

  This pulls apart the salient bits of the URI and populates the
resource via a `obj_get'.

  Optionally accepts a `request'.

  If you need custom behavior based on other portions of the URI,
simply override this method.


File: django-tastypie.info,  Node: full_dehydrate<2>,  Next: dehydrate<4>,  Prev: get_via_uri<2>,  Up: Resource Methods<2>

16.12.30 `full_dehydrate'
-------------------------

 -- Method: Resource.full_dehydrate (self, bundle)

  Given a bundle with an object instance, extract the information from
it to populate the resource.


File: django-tastypie.info,  Node: dehydrate<4>,  Next: full_hydrate<2>,  Prev: full_dehydrate<2>,  Up: Resource Methods<2>

16.12.31 `dehydrate'
--------------------

 -- Method: Resource.dehydrate (self, bundle)

  A hook to allow a final manipulation of data once all fields/methods
have built out the dehydrated data.

  Useful if you need to access more than one dehydrated field or want
to annotate on additional data.

  Must return the modified bundle.


File: django-tastypie.info,  Node: full_hydrate<2>,  Next: hydrate<4>,  Prev: dehydrate<4>,  Up: Resource Methods<2>

16.12.32 `full_hydrate'
-----------------------

 -- Method: Resource.full_hydrate (self, bundle)

  Given a populated bundle, distill it and turn it back into a
full-fledged object instance.


File: django-tastypie.info,  Node: hydrate<4>,  Next: hydrate_m2m<2>,  Prev: full_hydrate<2>,  Up: Resource Methods<2>

16.12.33 `hydrate'
------------------

 -- Method: Resource.hydrate (self, bundle)

  A hook to allow a final manipulation of data once all fields/methods
have built out the hydrated data.

  Useful if you need to access more than one hydrated field or want to
annotate on additional data.

  Must return the modified bundle.


File: django-tastypie.info,  Node: hydrate_m2m<2>,  Next: build_schema<2>,  Prev: hydrate<4>,  Up: Resource Methods<2>

16.12.34 `hydrate_m2m'
----------------------

 -- Method: Resource.hydrate_m2m (self, bundle)

  Populate the ManyToMany data on the instance.


File: django-tastypie.info,  Node: build_schema<2>,  Next: dehydrate_resource_uri<2>,  Prev: hydrate_m2m<2>,  Up: Resource Methods<2>

16.12.35 `build_schema'
-----------------------

 -- Method: Resource.build_schema (self)

  Returns a dictionary of all the fields on the resource and some
properties about those fields.

  Used by the `schema/' endpoint to describe what will be available.


File: django-tastypie.info,  Node: dehydrate_resource_uri<2>,  Next: generate_cache_key<2>,  Prev: build_schema<2>,  Up: Resource Methods<2>

16.12.36 `dehydrate_resource_uri'
---------------------------------

 -- Method: Resource.dehydrate_resource_uri (self, bundle)

  For the automatically included `resource_uri' field, dehydrate the
URI for the given bundle.

  Returns empty string if no URI can be generated.


File: django-tastypie.info,  Node: generate_cache_key<2>,  Next: get_object_list<3>,  Prev: dehydrate_resource_uri<2>,  Up: Resource Methods<2>

16.12.37 `generate_cache_key'
-----------------------------

 -- Method: Resource.generate_cache_key (self, *args, **kwargs)

  Creates a unique-enough cache key.

  This is based off the current api_name/resource_name/args/kwargs.


File: django-tastypie.info,  Node: get_object_list<3>,  Next: apply_authorization_limits<2>,  Prev: generate_cache_key<2>,  Up: Resource Methods<2>

16.12.38 `get_object_list'
--------------------------

 -- Method: Resource.get_object_list (self, request)

  A hook to allow making returning the list of available objects.

  _This needs to be implemented at the user level._

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: apply_authorization_limits<2>,  Next: can_create<2>,  Prev: get_object_list<3>,  Up: Resource Methods<2>

16.12.39 `apply_authorization_limits'
-------------------------------------

 -- Method: Resource.apply_authorization_limits (self, request,
          object_list)

  Allows the `Authorization' class to further limit the object list.
Also a hook to customize per `Resource'.

  Calls `Authorization.apply_limits' if available.


File: django-tastypie.info,  Node: can_create<2>,  Next: can_update<2>,  Prev: apply_authorization_limits<2>,  Up: Resource Methods<2>

16.12.40 `can_create'
---------------------

 -- Method: Resource.can_create (self)

  Checks to ensure `post' is within `allowed_methods'.


File: django-tastypie.info,  Node: can_update<2>,  Next: can_delete<2>,  Prev: can_create<2>,  Up: Resource Methods<2>

16.12.41 `can_update'
---------------------

 -- Method: Resource.can_update (self)

  Checks to ensure `put' is within `allowed_methods'.

  Used when hydrating related data.


File: django-tastypie.info,  Node: can_delete<2>,  Next: apply_filters<3>,  Prev: can_update<2>,  Up: Resource Methods<2>

16.12.42 `can_delete'
---------------------

 -- Method: Resource.can_delete (self)

  Checks to ensure `delete' is within `allowed_methods'.


File: django-tastypie.info,  Node: apply_filters<3>,  Next: obj_get_list<3>,  Prev: can_delete<2>,  Up: Resource Methods<2>

16.12.43 `apply_filters'
------------------------

 -- Method: Resource.apply_filters (self, request, applicable_filters)

  A hook to alter how the filters are applied to the object list.

  This needs to be implemented at the user level.

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: obj_get_list<3>,  Next: cached_obj_get_list<2>,  Prev: apply_filters<3>,  Up: Resource Methods<2>

16.12.44 `obj_get_list'
-----------------------

 -- Method: Resource.obj_get_list (self, request=None, **kwargs)

  Fetches the list of objects available on the resource.

  _This needs to be implemented at the user level._

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: cached_obj_get_list<2>,  Next: obj_get<3>,  Prev: obj_get_list<3>,  Up: Resource Methods<2>

16.12.45 `cached_obj_get_list'
------------------------------

 -- Method: Resource.cached_obj_get_list (self, request=None, **kwargs)

  A version of `obj_get_list' that uses the cache as a means to get
commonly-accessed data faster.


File: django-tastypie.info,  Node: obj_get<3>,  Next: cached_obj_get<2>,  Prev: cached_obj_get_list<2>,  Up: Resource Methods<2>

16.12.46 `obj_get'
------------------

 -- Method: Resource.obj_get (self, request=None, **kwargs)

  Fetches an individual object on the resource.

  _This needs to be implemented at the user level._ If the object can
not be found, this should raise a `NotFound' exception.

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: cached_obj_get<2>,  Next: obj_create<3>,  Prev: obj_get<3>,  Up: Resource Methods<2>

16.12.47 `cached_obj_get'
-------------------------

 -- Method: Resource.cached_obj_get (self, request=None, **kwargs)

  A version of `obj_get' that uses the cache as a means to get
commonly-accessed data faster.


File: django-tastypie.info,  Node: obj_create<3>,  Next: lookup_kwargs_with_identifiers<2>,  Prev: cached_obj_get<2>,  Up: Resource Methods<2>

16.12.48 `obj_create'
---------------------

 -- Method: Resource.obj_create (self, bundle, request=None, **kwargs)

  Creates a new object based on the provided data.

  _This needs to be implemented at the user level._

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: lookup_kwargs_with_identifiers<2>,  Next: obj_update<3>,  Prev: obj_create<3>,  Up: Resource Methods<2>

16.12.49 `lookup_kwargs_with_identifiers'
-----------------------------------------

 -- Method: Resource.lookup_kwargs_with_identifiers (self, bundle,
          kwargs)

  Kwargs here represent uri identifiers. Ex:
/repos/<user_id>/<repo_name>/ We need to turn those identifiers into
Python objects for generating lookup parameters that can find them in
the DB.


File: django-tastypie.info,  Node: obj_update<3>,  Next: obj_delete_list<3>,  Prev: lookup_kwargs_with_identifiers<2>,  Up: Resource Methods<2>

16.12.50 `obj_update'
---------------------

 -- Method: Resource.obj_update (self, bundle, request=None, **kwargs)

  Updates an existing object (or creates a new object) based on the
provided data.

  _This needs to be implemented at the user level._

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: obj_delete_list<3>,  Next: obj_delete<3>,  Prev: obj_update<3>,  Up: Resource Methods<2>

16.12.51 `obj_delete_list'
--------------------------

 -- Method: Resource.obj_delete_list (self, request=None, **kwargs)

  Deletes an entire list of objects.

  _This needs to be implemented at the user level._

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: obj_delete<3>,  Next: create_response<2>,  Prev: obj_delete_list<3>,  Up: Resource Methods<2>

16.12.52 `obj_delete'
---------------------

 -- Method: Resource.obj_delete (self, request=None, **kwargs)

  Deletes a single object.

  _This needs to be implemented at the user level._

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: create_response<2>,  Next: is_valid<2>,  Prev: obj_delete<3>,  Up: Resource Methods<2>

16.12.53 `create_response'
--------------------------

 -- Method: Resource.create_response (self, request, data,
          response_class=HttpResponse, **response_kwargs)

  Extracts the common "which-format/serialize/return-response" cycle.

  Mostly a useful shortcut/hook.


File: django-tastypie.info,  Node: is_valid<2>,  Next: rollback<3>,  Prev: create_response<2>,  Up: Resource Methods<2>

16.12.54 `is_valid'
-------------------

 -- Method: Resource.is_valid (self, bundle, request=None)

  Handles checking if the data provided by the user is valid.

  Mostly a hook, this uses class assigned to `validation' from
`Resource._meta'.

  If validation fails, an error is raised with the error messages
serialized inside it.


File: django-tastypie.info,  Node: rollback<3>,  Next: get_list<2>,  Prev: is_valid<2>,  Up: Resource Methods<2>

16.12.55 `rollback'
-------------------

 -- Method: Resource.rollback (self, bundles)

  Given the list of bundles, delete all objects pertaining to those
bundles.

  This needs to be implemented at the user level. No exceptions should
be raised if possible.

  `ModelResource' includes a full working version specific to Django's
`Models'.


File: django-tastypie.info,  Node: get_list<2>,  Next: get_detail<2>,  Prev: rollback<3>,  Up: Resource Methods<2>

16.12.56 `get_list'
-------------------

 -- Method: Resource.get_list (self, request, **kwargs)

  Returns a serialized list of resources.

  Calls `obj_get_list' to provide the data, then handles that result
set and serializes it.

  Should return a HttpResponse (200 OK).


File: django-tastypie.info,  Node: get_detail<2>,  Next: put_list<2>,  Prev: get_list<2>,  Up: Resource Methods<2>

16.12.57 `get_detail'
---------------------

 -- Method: Resource.get_detail (self, request, **kwargs)

  Returns a single serialized resource.

  Calls `cached_obj_get/obj_get' to provide the data, then handles that
result set and serializes it.

  Should return a HttpResponse (200 OK).


File: django-tastypie.info,  Node: put_list<2>,  Next: put_detail<2>,  Prev: get_detail<2>,  Up: Resource Methods<2>

16.12.58 `put_list'
-------------------

 -- Method: Resource.put_list (self, request, **kwargs)

  Replaces a collection of resources with another collection.

  Calls `delete_list' to clear out the collection then `obj_create'
with the provided the data to create the new collection.

  Return `HttpNoContent' (204 No Content) if `Meta.always_return_data =
False' (default).

  Return `HttpAccepted' (202 Accepted) if `Meta.always_return_data =
True'.


File: django-tastypie.info,  Node: put_detail<2>,  Next: post_list<2>,  Prev: put_list<2>,  Up: Resource Methods<2>

16.12.59 `put_detail'
---------------------

 -- Method: Resource.put_detail (self, request, **kwargs)

  Either updates an existing resource or creates a new one with the
provided data.

  Calls `obj_update' with the provided data first, but falls back to
`obj_create' if the object does not already exist.

  If a new resource is created, return `HttpCreated' (201 Created).  If
`Meta.always_return_data = True', there will be a populated body of
serialized data.

  If an existing resource is modified and `Meta.always_return_data =
False' (default), return `HttpNoContent' (204 No Content).  If an
existing resource is modified and `Meta.always_return_data = True',
return `HttpAccepted' (202 Accepted).


File: django-tastypie.info,  Node: post_list<2>,  Next: post_detail<2>,  Prev: put_detail<2>,  Up: Resource Methods<2>

16.12.60 `post_list'
--------------------

 -- Method: Resource.post_list (self, request, **kwargs)

  Creates a new resource/object with the provided data.

  Calls `obj_create' with the provided data and returns a response with
the new resource's location.

  If a new resource is created, return `HttpCreated' (201 Created).  If
`Meta.always_return_data = True', there will be a populated body of
serialized data.


File: django-tastypie.info,  Node: post_detail<2>,  Next: delete_list<2>,  Prev: post_list<2>,  Up: Resource Methods<2>

16.12.61 `post_detail'
----------------------

 -- Method: Resource.post_detail (self, request, **kwargs)

  Creates a new subcollection of the resource under a resource.

  This is not implemented by default because most people's data models
aren't self-referential.

  If a new resource is created, return `HttpCreated' (201 Created).


File: django-tastypie.info,  Node: delete_list<2>,  Next: delete_detail<2>,  Prev: post_detail<2>,  Up: Resource Methods<2>

16.12.62 `delete_list'
----------------------

 -- Method: Resource.delete_list (self, request, **kwargs)

  Destroys a collection of resources/objects.

  Calls `obj_delete_list'.

  If the resources are deleted, return `HttpNoContent' (204 No Content).


File: django-tastypie.info,  Node: delete_detail<2>,  Next: patch_list<2>,  Prev: delete_list<2>,  Up: Resource Methods<2>

16.12.63 `delete_detail'
------------------------

 -- Method: Resource.delete_detail (self, request, **kwargs)

  Destroys a single resource/object.

  Calls `obj_delete'.

  If the resource is deleted, return `HttpNoContent' (204 No Content).
If the resource did not exist, return `HttpNotFound' (404 Not Found).


File: django-tastypie.info,  Node: patch_list<2>,  Next: patch_detail<2>,  Prev: delete_detail<2>,  Up: Resource Methods<2>

16.12.64 `patch_list'
---------------------

 -- Method: Resource.patch_list (self, request, **kwargs)

  Updates a collection in-place.

  The exact behavior of `PATCH' to a list resource is still the matter
of some debate in REST circles, and the `PATCH' RFC isn't standard. So
the behavior this method implements (described below) is something of a
stab in the dark. It's mostly cribbed from GData, with a smattering of
ActiveResource-isms and maybe even an original idea or two.

  The `PATCH' format is one that's similar to the response returned from
a `GET' on a list resource:

    {
      "objects": [{object}, {object}, ...],
      "deleted_objects": ["URI", "URI", "URI", ...],
    }

For each object in `objects':

        * If the dict does not have a `resource_uri' key then the item
          is considered "new" and is handled like a `POST' to the
          resource list.

        * If the dict has a `resource_uri' key and the `resource_uri'
          refers to an existing resource then the item is a update;
          it's treated like a `PATCH' to the corresponding resource
          detail.

        * If the dict has a `resource_uri' but the resource _doesn't_
          exist, then this is considered to be a create-via-`PUT'.

  Each entry in `deleted_objects' referes to a resource URI of an
existing resource to be deleted; each is handled like a `DELETE' to the
relevent resource.

  In any case:

        * If there's a resource URI it _must_ refer to a resource of
          this type. It's an error to include a URI of a different
          resource.

        * `PATCH' is all or nothing. If a single sub-operation fails,
          the entire request will fail and all resources will be rolled
          back.

        * For `PATCH' to work, you *must* have `put' in your *note
          detail_allowed_methods: be. setting.

        * To delete objects via `deleted_objects' in a `PATCH' request
          you *must* have `delete' in your *note
          detail_allowed_methods: be. setting.


File: django-tastypie.info,  Node: patch_detail<2>,  Next: get_schema<2>,  Prev: patch_list<2>,  Up: Resource Methods<2>

16.12.65 `patch_detail'
-----------------------

 -- Method: Resource.patch_detail (self, request, **kwargs)

  Updates a resource in-place.

  Calls `obj_update'.

  If the resource is updated, return `HttpAccepted' (202 Accepted).  If
the resource did not exist, return `HttpNotFound' (404 Not Found).


File: django-tastypie.info,  Node: get_schema<2>,  Next: get_multiple<2>,  Prev: patch_detail<2>,  Up: Resource Methods<2>

16.12.66 `get_schema'
---------------------

 -- Method: Resource.get_schema (self, request, **kwargs)

  Returns a serialized form of the schema of the resource.

  Calls `build_schema' to generate the data. This method only responds
to HTTP GET.

  Should return a HttpResponse (200 OK).


File: django-tastypie.info,  Node: get_multiple<2>,  Prev: get_schema<2>,  Up: Resource Methods<2>

16.12.67 `get_multiple'
-----------------------

 -- Method: Resource.get_multiple (self, request, **kwargs)

  Returns a serialized list of resources based on the identifiers from
the URL.

  Calls `obj_get' to fetch only the objects requested. This method only
responds to HTTP GET.

  Should return a HttpResponse (200 OK).


File: django-tastypie.info,  Node: ModelResource Methods<2>,  Prev: Resource Methods<2>,  Up: Resources<2>

16.13 `ModelResource' Methods
=============================

A subclass of `Resource' designed to work with Django's `Models'.

  This class will introspect a given `Model' and build a field list
based on the fields found on the model (excluding relational fields).

  Given that it is aware of Django's ORM, it also handles the CRUD data
operations of the resource.

* Menu:

* should_skip_field: should_skip_field<2>.
* api_field_from_django_field: api_field_from_django_field<2>.
* get_fields: get_fields<2>.
* check_filtering: check_filtering<2>.
* build_filters: build_filters<4>.
* apply_sorting: apply_sorting<4>.
* apply_filters: apply_filters<4>.
* get_object_list: get_object_list<4>.
* obj_get_list: obj_get_list<4>.
* obj_get: obj_get<4>.
* obj_create: obj_create<4>.
* obj_update: obj_update<4>.
* obj_delete_list: obj_delete_list<4>.
* obj_delete: obj_delete<4>.
* rollback: rollback<4>.
* save_related: save_related<2>.
* save_m2m: save_m2m<2>.
* get_resource_uri: get_resource_uri<4>.


File: django-tastypie.info,  Node: should_skip_field<2>,  Next: api_field_from_django_field<2>,  Up: ModelResource Methods<2>

16.13.1 `should_skip_field'
---------------------------

 -- Method: ModelResource.should_skip_field (cls, field)

  _Class method_

  Given a Django model field, return if it should be included in the
contributed ApiFields.


File: django-tastypie.info,  Node: api_field_from_django_field<2>,  Next: get_fields<2>,  Prev: should_skip_field<2>,  Up: ModelResource Methods<2>

16.13.2 `api_field_from_django_field'
-------------------------------------

 -- Method: ModelResource.api_field_from_django_field (cls, f,
          default=CharField)

  _Class method_

  Returns the field type that would likely be associated with each
Django type.


File: django-tastypie.info,  Node: get_fields<2>,  Next: check_filtering<2>,  Prev: api_field_from_django_field<2>,  Up: ModelResource Methods<2>

16.13.3 `get_fields'
--------------------

 -- Method: ModelResource.get_fields (cls, fields=None, excludes=None)

  _Class method_

  Given any explicit fields to include and fields to exclude, add
additional fields based on the associated model.


File: django-tastypie.info,  Node: check_filtering<2>,  Next: build_filters<4>,  Prev: get_fields<2>,  Up: ModelResource Methods<2>

16.13.4 `check_filtering'
-------------------------

 -- Method: ModelResource.check_filtering (self, field_name,
          filter_type='exact', filter_bits=None)

  Given a field name, a optional filter type and an optional list of
additional relations, determine if a field can be filtered on.

  If a filter does not meet the needed conditions, it should raise an
`InvalidFilterError'.

  If the filter meets the conditions, a list of attribute names (not
field names) will be returned.


File: django-tastypie.info,  Node: build_filters<4>,  Next: apply_sorting<4>,  Prev: check_filtering<2>,  Up: ModelResource Methods<2>

16.13.5 `build_filters'
-----------------------

 -- Method: ModelResource.build_filters (self, filters=None)

  Given a dictionary of filters, create the necessary ORM-level filters.

  Keys should be resource fields, *NOT* model fields.

  Valid values are either a list of Django filter types (i.e.
`['startswith', 'exact', 'lte']'), the `ALL' constant or the
`ALL_WITH_RELATIONS' constant.

  At the declarative level:

    filtering = {
        'resource_field_name': ['exact', 'startswith', 'endswith', 'contains'],
        'resource_field_name_2': ['exact', 'gt', 'gte', 'lt', 'lte', 'range'],
        'resource_field_name_3': ALL,
        'resource_field_name_4': ALL_WITH_RELATIONS,
        ...
    }

Accepts the filters as a dict. `None' by default, meaning no filters.


File: django-tastypie.info,  Node: apply_sorting<4>,  Next: apply_filters<4>,  Prev: build_filters<4>,  Up: ModelResource Methods<2>

16.13.6 `apply_sorting'
-----------------------

 -- Method: ModelResource.apply_sorting (self, obj_list, options=None)

  Given a dictionary of options, apply some ORM-level sorting to the
provided `QuerySet'.

  Looks for the `order_by' key and handles either ascending (just the
field name) or descending (the field name with a `-' in front).

  The field name should be the resource field, *NOT* model field.


File: django-tastypie.info,  Node: apply_filters<4>,  Next: get_object_list<4>,  Prev: apply_sorting<4>,  Up: ModelResource Methods<2>

16.13.7 `apply_filters'
-----------------------

 -- Method: ModelResource.apply_filters (self, request,
          applicable_filters)

  An ORM-specific implementation of `apply_filters'.

  The default simply applies the `applicable_filters' as `**kwargs',
but should make it possible to do more advanced things.


File: django-tastypie.info,  Node: get_object_list<4>,  Next: obj_get_list<4>,  Prev: apply_filters<4>,  Up: ModelResource Methods<2>

16.13.8 `get_object_list'
-------------------------

 -- Method: ModelResource.get_object_list (self, request)

  A ORM-specific implementation of `get_object_list'.

  Returns a `QuerySet' that may have been limited by other overrides.


File: django-tastypie.info,  Node: obj_get_list<4>,  Next: obj_get<4>,  Prev: get_object_list<4>,  Up: ModelResource Methods<2>

16.13.9 `obj_get_list'
----------------------

 -- Method: ModelResource.obj_get_list (self, filters=None, **kwargs)

  A ORM-specific implementation of `obj_get_list'.

  Takes an optional `filters' dictionary, which can be used to narrow
the query.


File: django-tastypie.info,  Node: obj_get<4>,  Next: obj_create<4>,  Prev: obj_get_list<4>,  Up: ModelResource Methods<2>

16.13.10 `obj_get'
------------------

 -- Method: ModelResource.obj_get (self, **kwargs)

  A ORM-specific implementation of `obj_get'.

  Takes optional `kwargs', which are used to narrow the query to find
the instance.


File: django-tastypie.info,  Node: obj_create<4>,  Next: obj_update<4>,  Prev: obj_get<4>,  Up: ModelResource Methods<2>

16.13.11 `obj_create'
---------------------

 -- Method: ModelResource.obj_create (self, bundle, **kwargs)

  A ORM-specific implementation of `obj_create'.


File: django-tastypie.info,  Node: obj_update<4>,  Next: obj_delete_list<4>,  Prev: obj_create<4>,  Up: ModelResource Methods<2>

16.13.12 `obj_update'
---------------------

 -- Method: ModelResource.obj_update (self, bundle, **kwargs)

  A ORM-specific implementation of `obj_update'.


File: django-tastypie.info,  Node: obj_delete_list<4>,  Next: obj_delete<4>,  Prev: obj_update<4>,  Up: ModelResource Methods<2>

16.13.13 `obj_delete_list'
--------------------------

 -- Method: ModelResource.obj_delete_list (self, **kwargs)

  A ORM-specific implementation of `obj_delete_list'.

  Takes optional `kwargs', which can be used to narrow the query.


File: django-tastypie.info,  Node: obj_delete<4>,  Next: rollback<4>,  Prev: obj_delete_list<4>,  Up: ModelResource Methods<2>

16.13.14 `obj_delete'
---------------------

 -- Method: ModelResource.obj_delete (self, **kwargs)

  A ORM-specific implementation of `obj_delete'.

  Takes optional `kwargs', which are used to narrow the query to find
the instance.


File: django-tastypie.info,  Node: rollback<4>,  Next: save_related<2>,  Prev: obj_delete<4>,  Up: ModelResource Methods<2>

16.13.15 `rollback'
-------------------

 -- Method: ModelResource.rollback (self, bundles)

  A ORM-specific implementation of `rollback'.

  Given the list of bundles, delete all models pertaining to those
bundles.


File: django-tastypie.info,  Node: save_related<2>,  Next: save_m2m<2>,  Prev: rollback<4>,  Up: ModelResource Methods<2>

16.13.16 `save_related'
-----------------------

 -- Method: ModelResource.save_related (self, bundle)

  Handles the saving of related non-M2M data.

  Calling assigning `child.parent = parent' & then calling `Child.save'
isn't good enough to make sure the `parent' is saved.

  To get around this, we go through all our related fields & call
`save' on them if they have related, non-M2M data.  M2M data is handled
by the `ModelResource.save_m2m' method.


File: django-tastypie.info,  Node: save_m2m<2>,  Next: get_resource_uri<4>,  Prev: save_related<2>,  Up: ModelResource Methods<2>

16.13.17 `save_m2m'
-------------------

 -- Method: ModelResource.save_m2m (self, bundle)

  Handles the saving of related M2M data.

  Due to the way Django works, the M2M data must be handled after the
main instance, which is why this isn't a part of the main `save' bits.

  Currently slightly inefficient in that it will clear out the whole
relation and recreate the related data as needed.


File: django-tastypie.info,  Node: get_resource_uri<4>,  Prev: save_m2m<2>,  Up: ModelResource Methods<2>

16.13.18 `get_resource_uri'
---------------------------

 -- Method: ModelResource.get_resource_uri (self, bundle_or_obj)

  Handles generating a resource URI for a single resource.

  Uses the model's `pk' in order to create the URI.


File: django-tastypie.info,  Node: Bundles<2>,  Next: Api<2>,  Prev: Resources<2>,  Up: Top

17 Bundles
**********

* Menu:

* What Are Bundles?: What Are Bundles?<2>.
* Attributes: Attributes<2>.


File: django-tastypie.info,  Node: What Are Bundles?<2>,  Next: Attributes<2>,  Up: Bundles<2>

17.1 What Are Bundles?
======================

Bundles are a small abstraction that allow Tastypie to pass data between
resources. This allows us not to depend on passing `request' to every
single method (especially in places where this would be overkill). It
also allows resources to work with data coming into the application
paired together with an unsaved instance of the object in question.
Finally, it aids in keeping Tastypie more thread-safe.

  Think of it as package of user data & an object instance (either of
which are optionally present).


File: django-tastypie.info,  Node: Attributes<2>,  Prev: What Are Bundles?<2>,  Up: Bundles<2>

17.2 Attributes
===============

All data within a bundle can be optional, especially depending on how
it's being used. If you write custom code using `Bundle', make sure
appropriate guards are in place.

* Menu:

* obj: obj<2>.
* data: data<2>.
* request: request<2>.
* related_obj: related_obj<2>.
* related_name: related_name<3>.


File: django-tastypie.info,  Node: obj<2>,  Next: data<2>,  Up: Attributes<2>

17.2.1 `obj'
------------

Either a Python object or `None'.

  Usually a Django model, though it may/may not have been saved already.


File: django-tastypie.info,  Node: data<2>,  Next: request<2>,  Prev: obj<2>,  Up: Attributes<2>

17.2.2 `data'
-------------

Always a plain Python dictionary of data. If not provided, it will be
empty.


File: django-tastypie.info,  Node: request<2>,  Next: related_obj<2>,  Prev: data<2>,  Up: Attributes<2>

17.2.3 `request'
----------------

Either the Django `request' that's part of the issued request or an
empty `HttpRequest' if it wasn't provided.


File: django-tastypie.info,  Node: related_obj<2>,  Next: related_name<3>,  Prev: request<2>,  Up: Attributes<2>

17.2.4 `related_obj'
--------------------

Either another "parent" Python object or `None'.

  Useful when handling one-to-many relations. Used in conjunction with
`related_name'.


File: django-tastypie.info,  Node: related_name<3>,  Prev: related_obj<2>,  Up: Attributes<2>

17.2.5 `related_name'
---------------------

Either a Python string name of an attribute or `None'.

  Useful when handling one-to-many relations. Used in conjunction with
`related_obj'.


File: django-tastypie.info,  Node: Api<2>,  Next: Resource Fields<2>,  Prev: Bundles<2>,  Up: Top

18 Api
******

In terms of a REST-style architecture, the "api" is a collection of
resources.  In Tastypie, the `Api' gathers together the `Resources' &
provides a nice way to use them as a set. It handles many of the
URLconf details for you, provides a helpful "top-level" view to show
what endpoints are available & some extra URL resolution juice.

* Menu:

* Quick Start: Quick Start<6>.
* Api Methods: Api Methods<2>.


File: django-tastypie.info,  Node: Quick Start<6>,  Next: Api Methods<2>,  Up: Api<2>

18.1 Quick Start
================

A sample api definition might look something like (usually located in a
URLconf):

    from tastypie.api import Api
    from myapp.api.resources import UserResource, EntryResource

    v1_api = Api(api_name='v1')
    v1_api.register(UserResource())
    v1_api.register(EntryResource())

    # Standard bits...
    urlpatterns = patterns('',
        (r'^api/', include(v1_api.urls)),
    )



File: django-tastypie.info,  Node: Api Methods<2>,  Prev: Quick Start<6>,  Up: Api<2>

18.2 `Api' Methods
==================

Implements a registry to tie together the various resources that make up
an API.

  Especially useful for navigation, HATEOAS and for providing multiple
versions of your API.

  Optionally supplying `api_name' allows you to name the API. Generally,
this is done with version numbers (i.e. `v1', `v2', etc.) but can be
named any string.

* Menu:

* register: register<2>.
* unregister: unregister<2>.
* canonical_resource_for: canonical_resource_for<2>.
* urls: urls<4>.
* top_level: top_level<2>.


File: django-tastypie.info,  Node: register<2>,  Next: unregister<2>,  Up: Api Methods<2>

18.2.1 `register'
-----------------

 -- Method: Api.register(self, resource, canonical=True):

  Registers an instance of a `Resource' subclass with the API.

  Optionally accept a `canonical' argument, which indicates that the
resource being registered is the canonical variant. Defaults to `True'.


File: django-tastypie.info,  Node: unregister<2>,  Next: canonical_resource_for<2>,  Prev: register<2>,  Up: Api Methods<2>

18.2.2 `unregister'
-------------------

 -- Method: Api.unregister(self, resource_name):

  If present, unregisters a resource from the API.


File: django-tastypie.info,  Node: canonical_resource_for<2>,  Next: urls<4>,  Prev: unregister<2>,  Up: Api Methods<2>

18.2.3 `canonical_resource_for'
-------------------------------

 -- Method: Api.canonical_resource_for(self, resource_name):

  Returns the canonical resource for a given `resource_name'.

* Menu:

* override_urls: override_urls<4>.
* prepend_urls: prepend_urls<4>.


File: django-tastypie.info,  Node: override_urls<4>,  Next: prepend_urls<4>,  Up: canonical_resource_for<2>

18.2.3.1 `override_urls'
........................

 -- Method: Api.override_urls(self):

  Deprecated. Will be removed by v1.0.0. Please use `Api.prepend_urls'
instead.


File: django-tastypie.info,  Node: prepend_urls<4>,  Prev: override_urls<4>,  Up: canonical_resource_for<2>

18.2.3.2 `prepend_urls'
.......................

 -- Method: Api.prepend_urls(self):

  A hook for adding your own URLs or matching before the default URLs.
Useful for adding custom endpoints or overriding the built-in ones.

  Should return a list of individual URLconf lines (*NOT* wrapped in
`patterns').


File: django-tastypie.info,  Node: urls<4>,  Next: top_level<2>,  Prev: canonical_resource_for<2>,  Up: Api Methods<2>

18.2.4 `urls'
-------------

 -- Method: Api.urls(self):

  _Property_

  Provides URLconf details for the `Api' and all registered `Resources'
beneath it.


File: django-tastypie.info,  Node: top_level<2>,  Prev: urls<4>,  Up: Api Methods<2>

18.2.5 `top_level'
------------------

 -- Method: Api.top_level(self, request, api_name=None):

  A view that returns a serialized list of all resources registers to
the `Api'. Useful for discovery.


File: django-tastypie.info,  Node: Resource Fields<2>,  Next: Caching<2>,  Prev: Api<2>,  Up: Top

19 Resource Fields
******************

When designing an API, an important component is defining the
representation of the data you're presenting. Like Django models, you
can control the representation of a `Resource' using fields. There are
a variety of fields for various types of data.

* Menu:

* Quick Start: Quick Start<7>.
* Standard Data Fields: Standard Data Fields<2>.
* Relationship Fields: Relationship Fields<2>.


File: django-tastypie.info,  Node: Quick Start<7>,  Next: Standard Data Fields<2>,  Up: Resource Fields<2>

19.1 Quick Start
================

For the impatient:

    from tastypie import fields, utils
    from tastypie.resources import Resource
    from myapp.api.resources import ProfileResource, NoteResource


    class PersonResource(Resource):
        name = fields.CharField(attribute='name')
        age = fields.IntegerField(attribute='years_old', null=True)
        created = fields.DateTimeField(readonly=True, help_text='When the person was created', default=utils.now)
        is_active = fields.BooleanField(default=True)
        profile = fields.ToOneField(ProfileResource, 'profile')
        notes = fields.ToManyField(NoteResource, 'notes', full=True)



File: django-tastypie.info,  Node: Standard Data Fields<2>,  Next: Relationship Fields<2>,  Prev: Quick Start<7>,  Up: Resource Fields<2>

19.2 Standard Data Fields
=========================

All standard data fields have a common base class `ApiField' which
handles the basic implementation details.

     Note: You should not use the `ApiField' class directly. Please use
     one of the subclasses that is more correct for your data.

* Menu:

* Common Field Options: Common Field Options<3>.
* Field Types: Field Types<3>.
* BooleanField: BooleanField<2>.
* CharField: CharField<2>.
* DateField: DateField<2>.
* DateTimeField: DateTimeField<2>.
* DecimalField: DecimalField<2>.
* DictField: DictField<2>.
* FileField: FileField<2>.
* FloatField: FloatField<2>.
* IntegerField: IntegerField<2>.
* ListField: ListField<2>.
* TimeField: TimeField<2>.

Common Field Options

* attribute: attribute<2>.
* default: default<2>.
* null: null<2>.
* blank: blank<2>.
* readonly: readonly<2>.
* unique: unique<2>.
* help_text: help_text<2>.


File: django-tastypie.info,  Node: Common Field Options<3>,  Next: Field Types<3>,  Up: Standard Data Fields<2>

19.2.1 Common Field Options
---------------------------

All `ApiField' objects accept the following options.

* Menu:

* attribute: attribute<2>.
* default: default<2>.
* null: null<2>.
* blank: blank<2>.
* readonly: readonly<2>.
* unique: unique<2>.
* help_text: help_text<2>.


File: django-tastypie.info,  Node: attribute<2>,  Next: default<2>,  Up: Common Field Options<3>

19.2.1.1 `attribute'
....................

 -- Attribute: ApiField.attribute

  A string naming an instance attribute of the object wrapped by the
Resource. The attribute will be accessed during the `dehydrate' or or
written during the `hydrate'.

  Defaults to `None', meaning data will be manually accessed.


File: django-tastypie.info,  Node: default<2>,  Next: null<2>,  Prev: attribute<2>,  Up: Common Field Options<3>

19.2.1.2 `default'
..................

 -- Attribute: ApiField.default

  Provides default data when the object being `dehydrated'/`hydrated'
has no data on the field.

  Defaults to `tastypie.fields.NOT_PROVIDED'.


File: django-tastypie.info,  Node: null<2>,  Next: blank<2>,  Prev: default<2>,  Up: Common Field Options<3>

19.2.1.3 `null'
...............

 -- Attribute: ApiField.null

  Indicates whether or not a `None' is allowable data on the field.
Defaults to `False'.


File: django-tastypie.info,  Node: blank<2>,  Next: readonly<2>,  Prev: null<2>,  Up: Common Field Options<3>

19.2.1.4 `blank'
................

 -- Attribute: ApiField.blank

  Indicates whether or not data may be omitted on the field. Defaults
to `False'.

  This is useful for allowing the user to omit data that you can
populate based on the request, such as the `user' or `site' to
associate a record with.


File: django-tastypie.info,  Node: readonly<2>,  Next: unique<2>,  Prev: blank<2>,  Up: Common Field Options<3>

19.2.1.5 `readonly'
...................

 -- Attribute: ApiField.readonly

  Indicates whether the field is used during the `hydrate' or not.
Defaults to `False'.


File: django-tastypie.info,  Node: unique<2>,  Next: help_text<2>,  Prev: readonly<2>,  Up: Common Field Options<3>

19.2.1.6 `unique'
.................

 -- Attribute: ApiField.unique

  Indicates whether the field is a unique identifier for the object.


File: django-tastypie.info,  Node: help_text<2>,  Prev: unique<2>,  Up: Common Field Options<3>

19.2.1.7 `help_text'
....................

 -- Attribute: ApiField.help_text

  A human-readable description of the field exposed at the schema level.
Defaults to the per-Field definition.


File: django-tastypie.info,  Node: Field Types<3>,  Next: BooleanField<2>,  Prev: Common Field Options<3>,  Up: Standard Data Fields<2>

19.2.2 Field Types
------------------


File: django-tastypie.info,  Node: BooleanField<2>,  Next: CharField<2>,  Prev: Field Types<3>,  Up: Standard Data Fields<2>

19.2.3 `BooleanField'
---------------------

A boolean field.

  Covers both `models.BooleanField' and `models.NullBooleanField'.


File: django-tastypie.info,  Node: CharField<2>,  Next: DateField<2>,  Prev: BooleanField<2>,  Up: Standard Data Fields<2>

19.2.4 `CharField'
------------------

A text field of arbitrary length.

  Covers both `models.CharField' and `models.TextField'.


File: django-tastypie.info,  Node: DateField<2>,  Next: DateTimeField<2>,  Prev: CharField<2>,  Up: Standard Data Fields<2>

19.2.5 `DateField'
------------------

A date field.


File: django-tastypie.info,  Node: DateTimeField<2>,  Next: DecimalField<2>,  Prev: DateField<2>,  Up: Standard Data Fields<2>

19.2.6 `DateTimeField'
----------------------

A datetime field.


File: django-tastypie.info,  Node: DecimalField<2>,  Next: DictField<2>,  Prev: DateTimeField<2>,  Up: Standard Data Fields<2>

19.2.7 `DecimalField'
---------------------

A decimal field.


File: django-tastypie.info,  Node: DictField<2>,  Next: FileField<2>,  Prev: DecimalField<2>,  Up: Standard Data Fields<2>

19.2.8 `DictField'
------------------

A dictionary field.


File: django-tastypie.info,  Node: FileField<2>,  Next: FloatField<2>,  Prev: DictField<2>,  Up: Standard Data Fields<2>

19.2.9 `FileField'
------------------

A file-related field.

  Covers both `models.FileField' and `models.ImageField'.


File: django-tastypie.info,  Node: FloatField<2>,  Next: IntegerField<2>,  Prev: FileField<2>,  Up: Standard Data Fields<2>

19.2.10 `FloatField'
--------------------

A floating point field.


File: django-tastypie.info,  Node: IntegerField<2>,  Next: ListField<2>,  Prev: FloatField<2>,  Up: Standard Data Fields<2>

19.2.11 `IntegerField'
----------------------

An integer field.

  Covers `models.IntegerField', `models.PositiveIntegerField',
`models.PositiveSmallIntegerField' and `models.SmallIntegerField'.


File: django-tastypie.info,  Node: ListField<2>,  Next: TimeField<2>,  Prev: IntegerField<2>,  Up: Standard Data Fields<2>

19.2.12 `ListField'
-------------------

A list field.


File: django-tastypie.info,  Node: TimeField<2>,  Prev: ListField<2>,  Up: Standard Data Fields<2>

19.2.13 `TimeField'
-------------------

A time field.


File: django-tastypie.info,  Node: Relationship Fields<2>,  Prev: Standard Data Fields<2>,  Up: Resource Fields<2>

19.3 Relationship Fields
========================

Provides access to data that is related within the database.

  The `RelatedField' base class is not intended for direct use but
provides functionality that `ToOneField' and `ToManyField' build upon.

  The contents of this field actually point to another `Resource',
rather than the related object. This allows the field to represent its
data in different ways.

  The abstractions based around this are "leaky" in that, unlike the
other fields provided by `tastypie', these fields don't handle
arbitrary objects very well. The subclasses use Django's ORM layer to
make things go, though there is no ORM-specific code at this level.

* Menu:

* Common Field Options: Common Field Options<4>.
* Field Types: Field Types<4>.

Common Field Options

* to: to<2>.
* full: full<2>.
* related_name: related_name<4>.

Field Types

* ToOneField: ToOneField<2>.
* OneToOneField: OneToOneField<2>.
* ForeignKey: ForeignKey<2>.
* ToManyField: ToManyField<2>.
* ManyToManyField: ManyToManyField<2>.
* OneToManyField: OneToManyField<2>.


File: django-tastypie.info,  Node: Common Field Options<4>,  Next: Field Types<4>,  Up: Relationship Fields<2>

19.3.1 Common Field Options
---------------------------

In addition to the common attributes for all `ApiField', relationship
fields accept the following.

* Menu:

* to: to<2>.
* full: full<2>.
* related_name: related_name<4>.


File: django-tastypie.info,  Node: to<2>,  Next: full<2>,  Up: Common Field Options<4>

19.3.1.1 `to'
.............

 -- Attribute: RelatedField.to

  The `to' argument should point to a `Resource' class, NOT to a
`Model'.  Required.


File: django-tastypie.info,  Node: full<2>,  Next: related_name<4>,  Prev: to<2>,  Up: Common Field Options<4>

19.3.1.2 `full'
...............

 -- Attribute: RelatedField.full

  Indicates how the related `Resource' will appear post-`dehydrate'. If
`False', the related `Resource' will appear as a URL to the endpoint of
that resource. If `True', the result of the sub-resource's `dehydrate'
will be included in full.


File: django-tastypie.info,  Node: related_name<4>,  Prev: full<2>,  Up: Common Field Options<4>

19.3.1.3 `related_name'
.......................

 -- Attribute: RelatedField.related_name

  Used to help automatically populate reverse relations when creating
data.  Defaults to `None'.

  In order for this option to work correctly, there must be a field on
the other `Resource' with this as an `attribute/instance_name'. Usually
this just means adding a reflecting `ToOneField' pointing back.

  Example:

    class EntryResource(ModelResource):
        authors = fields.ToManyField('path.to.api.resources.AuthorResource', 'author_set', related_name='entry')

        class Meta:
            queryset = Entry.objects.all()
            resource_name = 'entry'

    class AuthorResource(ModelResource):
        entry = fields.ToOneField(EntryResource, 'entry')

        class Meta:
            queryset = Author.objects.all()
            resource_name = 'author'



File: django-tastypie.info,  Node: Field Types<4>,  Prev: Common Field Options<4>,  Up: Relationship Fields<2>

19.3.2 Field Types
------------------

* Menu:

* ToOneField: ToOneField<2>.
* OneToOneField: OneToOneField<2>.
* ForeignKey: ForeignKey<2>.
* ToManyField: ToManyField<2>.
* ManyToManyField: ManyToManyField<2>.
* OneToManyField: OneToManyField<2>.


File: django-tastypie.info,  Node: ToOneField<2>,  Next: OneToOneField<2>,  Up: Field Types<4>

19.3.2.1 `ToOneField'
.....................

Provides access to related data via foreign key.

  This subclass requires Django's ORM layer to work properly.


File: django-tastypie.info,  Node: OneToOneField<2>,  Next: ForeignKey<2>,  Prev: ToOneField<2>,  Up: Field Types<4>

19.3.2.2 `OneToOneField'
........................

An alias to `ToOneField' for those who prefer to mirror
`django.db.models'.


File: django-tastypie.info,  Node: ForeignKey<2>,  Next: ToManyField<2>,  Prev: OneToOneField<2>,  Up: Field Types<4>

19.3.2.3 `ForeignKey'
.....................

An alias to `ToOneField' for those who prefer to mirror
`django.db.models'.


File: django-tastypie.info,  Node: ToManyField<2>,  Next: ManyToManyField<2>,  Prev: ForeignKey<2>,  Up: Field Types<4>

19.3.2.4 `ToManyField'
......................

Provides access to related data via a join table.

  This subclass requires Django's ORM layer to work properly.

  This field also has special behavior when dealing with `attribute' in
that it can take a callable. For instance, if you need to filter the
reverse relation, you can do something like:

    subjects = fields.ToManyField(SubjectResource, attribute=lambda bundle: Subject.objects.filter(notes=bundle.obj, name__startswith='Personal'))

Note that the `hydrate' portions of this field are quite different than
any other field. `hydrate_m2m' actually handles the data and relations.
This is due to the way Django implements M2M relationships.


File: django-tastypie.info,  Node: ManyToManyField<2>,  Next: OneToManyField<2>,  Prev: ToManyField<2>,  Up: Field Types<4>

19.3.2.5 `ManyToManyField'
..........................

An alias to `ToManyField' for those who prefer to mirror
`django.db.models'.


File: django-tastypie.info,  Node: OneToManyField<2>,  Prev: ManyToManyField<2>,  Up: Field Types<4>

19.3.2.6 `OneToManyField'
.........................

An alias to `ToManyField' for those who prefer to mirror
`django.db.models'.


File: django-tastypie.info,  Node: Caching<2>,  Next: Validation<3>,  Prev: Resource Fields<2>,  Up: Top

20 Caching
**********

When adding an API to your site, it's important to understand that most
consumers of the API will not be people, but instead machines. This
means that the traditional "fetch-read-click" cycle is no longer
measured in minutes but in seconds or milliseconds.

  As such, caching is a very important part of the deployment of your
API.  Tastypie ships with two classes to make working with caching
easier. These caches store at the object level, reducing access time on
the database.

  However, it's worth noting that these do _NOT_ cache serialized
representations.  For heavy traffic, we'd encourage the use of a
caching proxy, especially Varnish(1), as it shines under this kind of
usage. It's far faster than Django views and already neatly handles
most situations.

  The first section below demonstrates how to cache at the Django
level, reducing the amount of work required to satisfy a request. In
many cases your API serves web browsers or is behind by a caching proxy
such as Varnish(2) and it is possible to set HTTP Cache-Control headers
to avoid issuing a request to your application at all. This is
discussed in the *note HTTP Cache-Control: 1c4. section below.

* Menu:

* Usage: Usage<9>.
* Caching Options: Caching Options<2>.
* Implementing Your Own Cache: Implementing Your Own Cache<2>.
* HTTP Cache-Control: HTTP Cache-Control<2>.
* HTTP Vary: HTTP Vary<2>.

  ---------- Footnotes ----------

  (1) http://www.varnish-cache.org/

  (2) http://www.varnish-cache.org/


File: django-tastypie.info,  Node: Usage<9>,  Next: Caching Options<2>,  Up: Caching<2>

20.1 Usage
==========

Using these classes is simple. Simply provide them (or your own class)
as a `Meta' option to the `Resource' in question. For example:

    from django.contrib.auth.models import User
    from tastypie.cache import SimpleCache
    from tastypie.resources import ModelResource


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']
            # Add it here.
            cache = SimpleCache(timeout=10)



File: django-tastypie.info,  Node: Caching Options<2>,  Next: Implementing Your Own Cache<2>,  Prev: Usage<9>,  Up: Caching<2>

20.2 Caching Options
====================

Tastypie ships with the following `Cache' classes:

* Menu:

* NoCache: NoCache<2>.
* SimpleCache: SimpleCache<2>.


File: django-tastypie.info,  Node: NoCache<2>,  Next: SimpleCache<2>,  Up: Caching Options<2>

20.2.1 `NoCache'
----------------

The no-op cache option, this does no caching but serves as an
api-compatible plug. Very useful for development.


File: django-tastypie.info,  Node: SimpleCache<2>,  Prev: NoCache<2>,  Up: Caching Options<2>

20.2.2 `SimpleCache'
--------------------

This option does basic object caching, attempting to find the object in
the cache & writing the object to the cache. It uses Django's current
`CACHE_BACKEND' to store cached data. The constructor receive a
`timeout' parameter to control per-resource the default timeout for the
cache.


File: django-tastypie.info,  Node: Implementing Your Own Cache<2>,  Next: HTTP Cache-Control<2>,  Prev: Caching Options<2>,  Up: Caching<2>

20.3 Implementing Your Own Cache
================================

Implementing your own `Cache' class is as simple as subclassing
`NoCache' and overriding the `get' & `set' methods. For example, a
json-backed cache might look like:

    import json
    from django.conf import settings
    from tastypie.cache import NoCache


    class JSONCache(NoCache):
        def _load(self):
            data_file = open(settings.TASTYPIE_JSON_CACHE, 'r')
            return json.load(data_file)

        def _save(self, data):
            data_file = open(settings.TASTYPIE_JSON_CACHE, 'w')
            return json.dump(data, data_file)

        def get(self, key):
            data = self._load()
            return data.get(key, None)

        def set(self, key, value, timeout=60):
            data = self._load()
            data[key] = value
            self._save(data)

Note that this is _NOT_ necessarily an optimal solution, but is simply
demonstrating how one might go about implementing your own `Cache'.


File: django-tastypie.info,  Node: HTTP Cache-Control<2>,  Next: HTTP Vary<2>,  Prev: Implementing Your Own Cache<2>,  Up: Caching<2>

20.4 HTTP Cache-Control
=======================

The HTTP protocol defines a `Cache-Control' header, which can be used
to tell clients and intermediaries who is allowed to cache a response
and for how long.  Mark Nottingham has a general caching
introduction(1) and the Django cache documentation(2) describes how to
set caching-related headers in your code. The range of possible options
is beyond the scope of this documentation, but it's important to know
that, by default, Tastypie will prevent responses from being cached to
ensure that clients always receive current information.

  To override the default `no-cache' response, your `Resource' should
ensure that your `cache' class implements `cache_control'. The default
`SimpleCache' does this by default. It uses the timeout passed to the
initialization as the `max-age' and `s-maxage'. By default, it does not
claim to know if the results should be public or privately cached but
this can be changed by passing either a `public=True' or a
`private=True' to the initialization of the `SimpleClass'.

  Behind the scenes, the return value from the `cache_control' method
is passed to the cache_control(3) helper provided by Django. If you
wish to add your own methods to it, you can do so by overloading the
`cache_control' method and modifying the dictionary it returns.:

    from tastypie.cache import SimpleCache

    class NoTransformCache(SimpleCache):

        def cache_control(self):
            control = super(NoTransformCache, self).cache_control()
            control.update({"no_transform": True})
            return control


  ---------- Footnotes ----------

  (1) http://www.mnot.net/cache_docs/

  (2)
https://docs.djangoproject.com/en/dev/topics/cache/#controlling-cache-using-other-headers

  (3)
https://docs.djangoproject.com/en/dev/topics/cache/?from=olddocs#controlling-cache-using-other-headers


File: django-tastypie.info,  Node: HTTP Vary<2>,  Prev: HTTP Cache-Control<2>,  Up: Caching<2>

20.5 HTTP Vary
==============

The HTTP protocol defines a `Vary' header, which can be used to tell
clients and intermediaries on what headers your response varies. This
allows clients to store a correct response for each type. By default,
Tastypie will send the `Vary: Accept' header so that a seperate
response is cached for each `Content-Type'. However, if you wish to
change this, simply pass a list to the `varies' kwarg of any `Cache'
class.

  It is important to note that if a list is passed, Tastypie not
automatically include the `Vary: Accept' and you should include it as a
member of your list.:

    class ExampleResource(Resource):
        class Meta:
            cache = SimpleCache(varies=["Accept", "Cookie"])



File: django-tastypie.info,  Node: Validation<3>,  Next: Authentication / Authorization<2>,  Prev: Caching<2>,  Up: Top

21 Validation
*************

Validation allows you to ensure that the data being submitted by the
user is appropriate for storage. This can range from simple type
checking on up to complex validation that compares different fields
together.

  If the data is valid, an empty dictionary is returned and processing
continues as normal. If the data is invalid, a dictionary of error
messages (keys being the field names, values being a list of error
messages). This will be immediately returned to the user, serialized in
the format they requested.

* Menu:

* Usage: Usage<10>.
* Validation Options: Validation Options<2>.
* Implementing Your Own Validation: Implementing Your Own Validation<2>.


File: django-tastypie.info,  Node: Usage<10>,  Next: Validation Options<2>,  Up: Validation<3>

21.1 Usage
==========

Using these classes is simple. Simply provide them (or your own class)
as a `Meta' option to the `Resource' in question. For example:

    from django.contrib.auth.models import User
    from tastypie.validation import Validation
    from tastypie.resources import ModelResource


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']
            # Add it here.
            validation = Validation()



File: django-tastypie.info,  Node: Validation Options<2>,  Next: Implementing Your Own Validation<2>,  Prev: Usage<10>,  Up: Validation<3>

21.2 Validation Options
=======================

Tastypie ships with the following `Validation' classes:

* Menu:

* Validation: Validation<4>.
* FormValidation: FormValidation<2>.
* CleanedDataFormValidation: CleanedDataFormValidation<2>.


File: django-tastypie.info,  Node: Validation<4>,  Next: FormValidation<2>,  Up: Validation Options<2>

21.2.1 `Validation'
-------------------

The no-op validation option, the data submitted is always considered to
be valid.

  This is the default class hooked up to `Resource/ModelResource'.


File: django-tastypie.info,  Node: FormValidation<2>,  Next: CleanedDataFormValidation<2>,  Prev: Validation<4>,  Up: Validation Options<2>

21.2.2 `FormValidation'
-----------------------

A more complex form of validation, this class accepts a `form_class'
argument to its constructor. You supply a Django `Form' (or
`ModelForm', though `save' will never get called) and Tastypie will
verify the `data' in the `Bundle' against the form.

  This class *DOES NOT* alter the data sent, only verifies it. If you
want to alter the data, please use the `CleanDataFormValidation' class
instead.

     Warning: Data in the bundle must line up with the fieldnames in
     the `Form'. If they do not, you'll need to either munge the data
     or change your form.

  Usage looks like:

    from django import forms

    class NoteForm(forms.Form):
        title = forms.CharField(max_length=100)
        slug = forms.CharField(max_length=50)
        content = forms.CharField(required=False, widget=forms.Textarea)
        is_active = forms.BooleanField()

    form = FormValidation(form_class=NoteForm)



File: django-tastypie.info,  Node: CleanedDataFormValidation<2>,  Prev: FormValidation<2>,  Up: Validation Options<2>

21.2.3 `CleanedDataFormValidation'
----------------------------------

Similar to the `FormValidation' class, this uses a Django `Form' to
handle validation. *However*, it will use the `form.cleaned_data' to
replace the `bundle' data sent by user! Usage is identical to
`FormValidation'.


File: django-tastypie.info,  Node: Implementing Your Own Validation<2>,  Prev: Validation Options<2>,  Up: Validation<3>

21.3 Implementing Your Own Validation
=====================================

Implementing your own `Validation' classes is a simple process. The
constructor can take whatever `**kwargs' it needs (if any). The only
other method to implement is the `is_valid' method:

    from tastypie.validation import Validation


    class AwesomeValidation(Validation):
        def is_valid(self, bundle, request=None):
            if not bundle.data:
                return {'__all__': 'Not quite what I had in mind.'}

            errors = {}

            for key, value in bundle.data.items():
                if not isinstance(value, basestring):
                    continue

                if not 'awesome' in value:
                    errors[key] = ['NOT ENOUGH AWESOME. NEEDS MORE.']

            return errors

Under this validation, every field that's a string is checked for the
word 'awesome'. If it's not in the string, it's an error.


File: django-tastypie.info,  Node: Authentication / Authorization<2>,  Next: Serialization<2>,  Prev: Validation<3>,  Up: Top

22 Authentication / Authorization
*********************************

Authentication & authorization make up the components needed to verify
who a certain user is and to validate their access to the API and what
they can do with it.

  Authentication answers the question "Who is this person?" This
usually involves requiring credentials, such as an API key or
username/password or oAuth tokens.

  Authorization answers the question "Is permission granted for this
user to take this action?" This usually involves checking permissions
such as Create/Read/Update/Delete access, or putting limits on what
data the user can access.

* Menu:

* Usage: Usage<11>.
* Authentication Options: Authentication Options<2>.
* Authorization Options: Authorization Options<2>.
* Implementing Your Own Authentication/Authorization: Implementing Your Own Authentication/Authorization<2>.


File: django-tastypie.info,  Node: Usage<11>,  Next: Authentication Options<2>,  Up: Authentication / Authorization<2>

22.1 Usage
==========

Using these classes is simple. Simply provide them (or your own class)
as a `Meta' option to the `Resource' in question. For example:

    from django.contrib.auth.models import User
    from tastypie.authentication import BasicAuthentication
    from tastypie.authorization import DjangoAuthorization
    from tastypie.resources import ModelResource


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']
            # Add it here.
            authentication = BasicAuthentication()
            authorization = DjangoAuthorization()



File: django-tastypie.info,  Node: Authentication Options<2>,  Next: Authorization Options<2>,  Prev: Usage<11>,  Up: Authentication / Authorization<2>

22.2 Authentication Options
===========================

Tastypie ships with the following `Authentication' classes:

* Menu:

* Authentication: Authentication<2>.
* BasicAuthentication: BasicAuthentication<2>.
* ApiKeyAuthentication: ApiKeyAuthentication<2>.
* SessionAuthentication: SessionAuthentication<2>.
* DigestAuthentication: DigestAuthentication<2>.
* OAuthAuthentication: OAuthAuthentication<2>.
* MultiAuthentication: MultiAuthentication<2>.


File: django-tastypie.info,  Node: Authentication<2>,  Next: BasicAuthentication<2>,  Up: Authentication Options<2>

22.2.1 `Authentication'
-----------------------

The no-op authentication option, the client is always allowed through.
Very useful for development and read-only APIs.


File: django-tastypie.info,  Node: BasicAuthentication<2>,  Next: ApiKeyAuthentication<2>,  Prev: Authentication<2>,  Up: Authentication Options<2>

22.2.2 `BasicAuthentication'
----------------------------

This authentication scheme uses HTTP Basic Auth to check a user's
credentials.  The username is their `django.contrib.auth.models.User'
username (assuming it is present) and their password should also
correspond to that entry.

     Warning: If you're using Apache & `mod_wsgi', you will need to
     enable `WSGIPassAuthorization On'. See this post(1) for details.

  ---------- Footnotes ----------

  (1) http://www.nerdydork.com/basic-authentication-on-mod_wsgi.html


File: django-tastypie.info,  Node: ApiKeyAuthentication<2>,  Next: SessionAuthentication<2>,  Prev: BasicAuthentication<2>,  Up: Authentication Options<2>

22.2.3 `ApiKeyAuthentication'
-----------------------------

As an alternative to requiring sensitive data like a password, the
`ApiKeyAuthentication' allows you to collect just username & a
machine-generated api key. Tastypie ships with a special `Model' just
for this purpose, so you'll need to ensure `tastypie' is in
`INSTALLED_APPS'.

  To use this mechanism, the end user can either specify an
`Authorization' header or pass the `username/api_key' combination as
`GET/POST' parameters.  Examples:

    # As a header
    # Format is ``Authorization: ApiKey <username>:<api_key>
    Authorization: ApiKey daniel:204db7bcfafb2deb7506b89eb3b9b715b09905c8

    # As GET params
    http://127.0.0.1:8000/api/v1/entries/?username=daniel&api_key=204db7bcfafb2deb7506b89eb3b9b715b09905c8

Tastypie includes a signal function you can use to auto-create `ApiKey'
objects. Hooking it up looks like:

    from django.contrib.auth.models import User
    from django.db import models
    from tastypie.models import create_api_key

    models.signals.post_save.connect(create_api_key, sender=User)


     Warning: If you're using Apache & `mod_wsgi', you will need to
     enable `WSGIPassAuthorization On', otherwise `mod_wsgi' strips out
     the `Authorization' header. See this post(1) for details (even
     though it only mentions Basic auth).

  ---------- Footnotes ----------

  (1) http://www.nerdydork.com/basic-authentication-on-mod_wsgi.html


File: django-tastypie.info,  Node: SessionAuthentication<2>,  Next: DigestAuthentication<2>,  Prev: ApiKeyAuthentication<2>,  Up: Authentication Options<2>

22.2.4 `SessionAuthentication'
------------------------------

This authentication scheme uses the built-in Django sessions to check if
a user is logged. This is typically useful when used by Javascript on
the same site as the API is hosted on.

  It requires that the user has logged in & has an active session. They
also must have a valid CSRF token.


File: django-tastypie.info,  Node: DigestAuthentication<2>,  Next: OAuthAuthentication<2>,  Prev: SessionAuthentication<2>,  Up: Authentication Options<2>

22.2.5 `DigestAuthentication'
-----------------------------

This authentication scheme uses HTTP Digest Auth to check a user's
credentials. The username is their `django.contrib.auth.models.User'
username (assuming it is present) and their password should be their
machine-generated api key. As with ApiKeyAuthentication, `tastypie'
should be included in `INSTALLED_APPS'.

     Warning: If you're using Apache & `mod_wsgi', you will need to
     enable `WSGIPassAuthorization On'. See this post(1) for details
     (even though it only mentions Basic auth).

  ---------- Footnotes ----------

  (1) http://www.nerdydork.com/basic-authentication-on-mod_wsgi.html


File: django-tastypie.info,  Node: OAuthAuthentication<2>,  Next: MultiAuthentication<2>,  Prev: DigestAuthentication<2>,  Up: Authentication Options<2>

22.2.6 `OAuthAuthentication'
----------------------------

Handles OAuth, which checks a user's credentials against a separate
service.  Currently verifies against OAuth 1.0a services.

  This does _NOT_ provide OAuth authentication in your API, strictly
consumption.

     Warning: If you're used to in-browser OAuth flow (click a "Sign
     In" button, get redirected, login on remote service, get
     redirected back), this isn't the same. Most prominently, expecting
     that would cause API clients to have to use tools like
     mechanize(1) to fill in forms, which would be difficult.

     This authentication expects that you're already followed some sort
     of OAuth flow & that the credentials (Nonce/token/etc) are simply
     being passed to it.  It merely checks that the credentials are
     valid. No requests are made to remote services as part of this
     authentication class.

  ---------- Footnotes ----------

  (1) http://pypi.python.org/pypi/mechanize/


File: django-tastypie.info,  Node: MultiAuthentication<2>,  Prev: OAuthAuthentication<2>,  Up: Authentication Options<2>

22.2.7 `MultiAuthentication'
----------------------------

This authentication class actually wraps any number of other
authentication classes, attempting each until successfully
authenticating. For example:

    from django.contrib.auth.models import User
    from tastypie.authentication import BasicAuthentication, ApiKeyAuthentication, MultiAuthentication
    from tastypie.authorization import DjangoAuthorization
    from tastypie.resources import ModelResource

    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']

            authentication = MultiAuthentication(BasicAuthentication(), ApiKeyAuthentication())
            authorization = DjangoAuthorization()

In the case of an authentication returning a customized
HttpUnauthorized, MultiAuthentication defaults to the first returned
one. Authentication schemes that need to control the response, such as
the included BasicAuthentication and DigestAuthentication, should be
placed first.


File: django-tastypie.info,  Node: Authorization Options<2>,  Next: Implementing Your Own Authentication/Authorization<2>,  Prev: Authentication Options<2>,  Up: Authentication / Authorization<2>

22.3 Authorization Options
==========================

Tastypie ships with the following `Authorization' classes:

* Menu:

* Authorization: Authorization<2>.
* ReadOnlyAuthorization: ReadOnlyAuthorization<2>.
* DjangoAuthorization: DjangoAuthorization<2>.


File: django-tastypie.info,  Node: Authorization<2>,  Next: ReadOnlyAuthorization<2>,  Up: Authorization Options<2>

22.3.1 `Authorization'
----------------------

The no-op authorization option, no permissions checks are performed.

     Warning: This is a potentially dangerous option, as it means _ANY_
     recognized user can modify _ANY_ data they encounter in the API.
     Be careful who you trust.


File: django-tastypie.info,  Node: ReadOnlyAuthorization<2>,  Next: DjangoAuthorization<2>,  Prev: Authorization<2>,  Up: Authorization Options<2>

22.3.2 `ReadOnlyAuthorization'
------------------------------

This authorization class only permits reading data, regardless of what
the `Resource' might think is allowed. This is the default
`Authorization' class and the safe option.


File: django-tastypie.info,  Node: DjangoAuthorization<2>,  Prev: ReadOnlyAuthorization<2>,  Up: Authorization Options<2>

22.3.3 `DjangoAuthorization'
----------------------------

The most advanced form of authorization, this checks the permission a
user has granted to them (via `django.contrib.auth.models.Permission').
In conjunction with the admin, this is a very effective means of
control.


File: django-tastypie.info,  Node: Implementing Your Own Authentication/Authorization<2>,  Prev: Authorization Options<2>,  Up: Authentication / Authorization<2>

22.4 Implementing Your Own Authentication/Authorization
=======================================================

Implementing your own `Authentication/Authorization' classes is a simple
process. `Authentication' has two methods to override (one of which is
optional but recommended to be customized) and `Authorization' has just
one required method and one optional method:

    from tastypie.authentication import Authentication
    from tastypie.authorization import Authorization


    class SillyAuthentication(Authentication):
        def is_authenticated(self, request, **kwargs):
            if 'daniel' in request.user.username:
              return True

            return False

        # Optional but recommended
        def get_identifier(self, request):
            return request.user.username

    class SillyAuthorization(Authorization):
        def is_authorized(self, request, object=None):
            if request.user.date_joined.year == 2010:
                return True
            else:
                return False

        # Optional but useful for advanced limiting, such as per user.
        def apply_limits(self, request, object_list):
            if request and hasattr(request, 'user'):
                return object_list.filter(author__username=request.user.username)

            return object_list.none()

Under this scheme, only users with 'daniel' in their username will be
allowed in, and only those who joined the site in 2010 will be allowed
to affect data.

  If the optional `apply_limits' method is included, each user that
fits the above criteria will only be able to access their own records.


File: django-tastypie.info,  Node: Serialization<2>,  Next: Throttling<2>,  Prev: Authentication / Authorization<2>,  Up: Top

23 Serialization
****************

Serialization can be one of the most contentious areas of an API.
Everyone has their own requirements, their own preferred output format
& the desire to have control over what is returned.

  As a result, Tastypie ships with a serializer that tries to meet the
basic needs of most use cases, and the flexibility to go outside of
that when you need to.

  The default `Serializer' supports the following formats:

   * json

   * jsonp

   * xml

   * yaml

   * html

   * plist (see <http://explorapp.com/biplist/>)

* Menu:

* Usage: Usage<12>.
* Implementing Your Own Serializer: Implementing Your Own Serializer<2>.
* Serializer Methods: Serializer Methods<2>.


File: django-tastypie.info,  Node: Usage<12>,  Next: Implementing Your Own Serializer<2>,  Up: Serialization<2>

23.1 Usage
==========

Using this class is simple. It is the default option on all `Resource'
classes unless otherwise specified. The following code is a no-op, but
demonstrate how you could use your own serializer:

    from django.contrib.auth.models import User
    from tastypie.resources import ModelResource
    from tastypie.serializers import Serializer


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']
            # Add it here.
            serializer = Serializer()

Not everyone wants to install or support all the serialization options.
To that end, you can limit the ones available by passing a `formats='
kwarg.  For example, to provide only JSON & binary plist serialization:

    from django.contrib.auth.models import User
    from tastypie.resources import ModelResource
    from tastypie.serializers import Serializer


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']
            serializer = Serializer(formats=['json', 'plist'])



File: django-tastypie.info,  Node: Implementing Your Own Serializer<2>,  Next: Serializer Methods<2>,  Prev: Usage<12>,  Up: Serialization<2>

23.2 Implementing Your Own Serializer
=====================================

There are several different use cases here. We'll cover simple examples
of wanting a tweaked format & adding a different format.

  To tweak a format, simply override it's `to_<format>' &
`from_<format>' methods. So adding the server time to all output might
look like so:

    import time
    from django.utils import simplejson
    from django.core.serializers import json
    from tastypie.serializers import Serializer

    class CustomJSONSerializer(Serializer):
        def to_json(self, data, options=None):
            options = options or {}

            data = self.to_simple(data, options)

            # Add in the current time.
            data['requested_time'] = time.time()

            return simplejson.dumps(data, cls=json.DjangoJSONEncoder, sort_keys=True)

        def from_json(self, content):
            data = simplejson.loads(content)

            if 'requested_time' in data:
                # Log the request here...
                pass

            return data

In the case of adding a different format, let's say you want to add a
CSV output option to the existing set. Your `Serializer' subclass might
look like:

    import csv
    import StringIO
    from tastypie.serializers import Serializer


    class CSVSerializer(Serializer):
        formats = ['json', 'jsonp', 'xml', 'yaml', 'html', 'plist', 'csv']
        content_types = {
            'json': 'application/json',
            'jsonp': 'text/javascript',
            'xml': 'application/xml',
            'yaml': 'text/yaml',
            'html': 'text/html',
            'plist': 'application/x-plist',
            'csv': 'text/csv',
        }

        def to_csv(self, data, options=None):
            options = options or {}
            data = self.to_simple(data, options)
            raw_data = StringIO.StringIO()
            # Untested, so this might not work exactly right.
            for item in data:
                writer = csv.DictWriter(raw_data, item.keys(), extrasaction='ignore')
                writer.write(item)
            return raw_data

        def from_csv(self, content):
            raw_data = StringIO.StringIO(content)
            data = []
            # Untested, so this might not work exactly right.
            for item in csv.DictReader(raw_data):
                data.append(item)
            return data



File: django-tastypie.info,  Node: Serializer Methods<2>,  Prev: Implementing Your Own Serializer<2>,  Up: Serialization<2>

23.3 `Serializer' Methods
=========================

A swappable class for serialization.

  This handles most types of data as well as the following output
formats:

    * json
    * jsonp
    * xml
    * yaml
    * html
    * plist

It was designed to make changing behavior easy, either by overridding
the various format methods (i.e. `to_json'), by changing the
`formats/content_types' options or by altering the other hook methods.

* Menu:

* get_mime_for_format: get_mime_for_format<2>.
* format_datetime: format_datetime<2>.
* format_date: format_date<2>.
* format_time: format_time<2>.
* serialize: serialize<6>.
* deserialize: deserialize<6>.
* to_simple: to_simple<2>.
* to_etree: to_etree<2>.
* from_etree: from_etree<2>.
* to_json: to_json<2>.
* from_json: from_json<2>.
* to_jsonp: to_jsonp<2>.
* to_xml: to_xml<2>.
* from_xml: from_xml<2>.
* to_yaml: to_yaml<2>.
* from_yaml: from_yaml<2>.
* to_plist: to_plist<2>.
* from_plist: from_plist<2>.
* to_html: to_html<2>.
* from_html: from_html<2>.


File: django-tastypie.info,  Node: get_mime_for_format<2>,  Next: format_datetime<2>,  Up: Serializer Methods<2>

23.3.1 `get_mime_for_format'
----------------------------

 -- Method: Serializer.get_mime_for_format(self, format):

  Given a format, attempts to determine the correct MIME type.

  If not available on the current `Serializer', returns
`application/json' by default.


File: django-tastypie.info,  Node: format_datetime<2>,  Next: format_date<2>,  Prev: get_mime_for_format<2>,  Up: Serializer Methods<2>

23.3.2 `format_datetime'
------------------------

 -- Method: Serializer.format_datetime(data):

  A hook to control how datetimes are formatted.

  Can be overridden at the `Serializer' level (`datetime_formatting')
or globally (via `settings.TASTYPIE_DATETIME_FORMATTING').

  Default is `iso-8601', which looks like "2010-12-16T03:02:14".


File: django-tastypie.info,  Node: format_date<2>,  Next: format_time<2>,  Prev: format_datetime<2>,  Up: Serializer Methods<2>

23.3.3 `format_date'
--------------------

 -- Method: Serializer.format_date(data):

  A hook to control how dates are formatted.

  Can be overridden at the `Serializer' level (`datetime_formatting')
or globally (via `settings.TASTYPIE_DATETIME_FORMATTING').

  Default is `iso-8601', which looks like "2010-12-16".


File: django-tastypie.info,  Node: format_time<2>,  Next: serialize<6>,  Prev: format_date<2>,  Up: Serializer Methods<2>

23.3.4 `format_time'
--------------------

 -- Method: Serializer.format_time(data):

  A hook to control how times are formatted.

  Can be overridden at the `Serializer' level (`datetime_formatting')
or globally (via `settings.TASTYPIE_DATETIME_FORMATTING').

  Default is `iso-8601', which looks like "03:02:14".


File: django-tastypie.info,  Node: serialize<6>,  Next: deserialize<6>,  Prev: format_time<2>,  Up: Serializer Methods<2>

23.3.5 `serialize'
------------------

 -- Method: Serializer.serialize(self, bundle,
          format='application/json', options={}):

  Given some data and a format, calls the correct method to serialize
the data and returns the result.


File: django-tastypie.info,  Node: deserialize<6>,  Next: to_simple<2>,  Prev: serialize<6>,  Up: Serializer Methods<2>

23.3.6 `deserialize'
--------------------

 -- Method: Serializer.deserialize(self, content,
          format='application/json'):

  Given some data and a format, calls the correct method to deserialize
the data and returns the result.


File: django-tastypie.info,  Node: to_simple<2>,  Next: to_etree<2>,  Prev: deserialize<6>,  Up: Serializer Methods<2>

23.3.7 `to_simple'
------------------

 -- Method: Serializer.to_simple(self, data, options):

  For a piece of data, attempts to recognize it and provide a simplified
form of something complex.

  This brings complex Python data structures down to native types of the
serialization format(s).


File: django-tastypie.info,  Node: to_etree<2>,  Next: from_etree<2>,  Prev: to_simple<2>,  Up: Serializer Methods<2>

23.3.8 `to_etree'
-----------------

 -- Method: Serializer.to_etree(self, data, options=None, name=None,
          depth=0):

  Given some data, converts that data to an `etree.Element' suitable
for use in the XML output.


File: django-tastypie.info,  Node: from_etree<2>,  Next: to_json<2>,  Prev: to_etree<2>,  Up: Serializer Methods<2>

23.3.9 `from_etree'
-------------------

 -- Method: Serializer.from_etree(self, data):

  Not the smartest deserializer on the planet. At the request level, it
first tries to output the deserialized subelement called "object" or
"objects" and falls back to deserializing based on hinted types in the
XML element attribute "type".


File: django-tastypie.info,  Node: to_json<2>,  Next: from_json<2>,  Prev: from_etree<2>,  Up: Serializer Methods<2>

23.3.10 `to_json'
-----------------

 -- Method: Serializer.to_json(self, data, options=None):

  Given some Python data, produces JSON output.


File: django-tastypie.info,  Node: from_json<2>,  Next: to_jsonp<2>,  Prev: to_json<2>,  Up: Serializer Methods<2>

23.3.11 `from_json'
-------------------

 -- Method: Serializer.from_json(self, content):

  Given some JSON data, returns a Python dictionary of the decoded data.


File: django-tastypie.info,  Node: to_jsonp<2>,  Next: to_xml<2>,  Prev: from_json<2>,  Up: Serializer Methods<2>

23.3.12 `to_jsonp'
------------------

 -- Method: Serializer.to_jsonp(self, data, options=None):

  Given some Python data, produces JSON output wrapped in the provided
callback.


File: django-tastypie.info,  Node: to_xml<2>,  Next: from_xml<2>,  Prev: to_jsonp<2>,  Up: Serializer Methods<2>

23.3.13 `to_xml'
----------------

 -- Method: Serializer.to_xml(self, data, options=None):

  Given some Python data, produces XML output.


File: django-tastypie.info,  Node: from_xml<2>,  Next: to_yaml<2>,  Prev: to_xml<2>,  Up: Serializer Methods<2>

23.3.14 `from_xml'
------------------

 -- Method: Serializer.from_xml(self, content):

  Given some XML data, returns a Python dictionary of the decoded data.


File: django-tastypie.info,  Node: to_yaml<2>,  Next: from_yaml<2>,  Prev: from_xml<2>,  Up: Serializer Methods<2>

23.3.15 `to_yaml'
-----------------

 -- Method: Serializer.to_yaml(self, data, options=None):

  Given some Python data, produces YAML output.


File: django-tastypie.info,  Node: from_yaml<2>,  Next: to_plist<2>,  Prev: to_yaml<2>,  Up: Serializer Methods<2>

23.3.16 `from_yaml'
-------------------

 -- Method: Serializer.from_yaml(self, content):

  Given some YAML data, returns a Python dictionary of the decoded data.


File: django-tastypie.info,  Node: to_plist<2>,  Next: from_plist<2>,  Prev: from_yaml<2>,  Up: Serializer Methods<2>

23.3.17 `to_plist'
------------------

 -- Method: Serializer.to_plist(self, data, options=None):

  Given some Python data, produces binary plist output.


File: django-tastypie.info,  Node: from_plist<2>,  Next: to_html<2>,  Prev: to_plist<2>,  Up: Serializer Methods<2>

23.3.18 `from_plist'
--------------------

 -- Method: Serializer.from_plist(self, content):

  Given some binary plist data, returns a Python dictionary of the
decoded data.


File: django-tastypie.info,  Node: to_html<2>,  Next: from_html<2>,  Prev: from_plist<2>,  Up: Serializer Methods<2>

23.3.19 `to_html'
-----------------

 -- Method: Serializer.to_html(self, data, options=None):

  Reserved for future usage.

  The desire is to provide HTML output of a resource, making an API
available to a browser. This is on the TODO list but not currently
implemented.


File: django-tastypie.info,  Node: from_html<2>,  Prev: to_html<2>,  Up: Serializer Methods<2>

23.3.20 `from_html'
-------------------

 -- Method: Serializer.from_html(self, content):

  Reserved for future usage.

  The desire is to handle form-based (maybe Javascript?) input, making
an API available to a browser. This is on the TODO list but not
currently implemented.


File: django-tastypie.info,  Node: Throttling<2>,  Next: Paginator<2>,  Prev: Serialization<2>,  Up: Top

24 Throttling
*************

Sometimes, the client on the other end may request data too frequently
or you have a business use case that dictates that the client should be
limited to a certain number of requests per hour.

  For this, Tastypie includes throttling as a way to limit the number
of requests in a timeframe.

* Menu:

* Usage: Usage<13>.
* Throttle Options: Throttle Options<2>.
* Implementing Your Own Throttle: Implementing Your Own Throttle<2>.


File: django-tastypie.info,  Node: Usage<13>,  Next: Throttle Options<2>,  Up: Throttling<2>

24.1 Usage
==========

To specify a throttle, add the `Throttle' class to the `Meta' class on
the `Resource':

    from django.contrib.auth.models import User
    from tastypie.resources import ModelResource
    from tastypie.throttle import BaseThrottle


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']
            # Add it here.
            throttle = BaseThrottle(throttle_at=100)



File: django-tastypie.info,  Node: Throttle Options<2>,  Next: Implementing Your Own Throttle<2>,  Prev: Usage<13>,  Up: Throttling<2>

24.2 Throttle Options
=====================

Each of the `Throttle' classes accepts the following initialization
arguments:

   * `throttle_at' - the number of requests at which the user should be
     throttled. Default is 150 requests.

   * `timeframe' - the length of time (in seconds) in which the user
     make up to the `throttle_at' requests. Default is 3600 seconds ( 1
     hour).

   * `expiration' - the length of time to retain the times the user has
     accessed the api in the cache. Default is 604800 (1 week).

  Tastypie ships with the following `Throttle' classes:

* Menu:

* BaseThrottle: BaseThrottle<2>.
* CacheThrottle: CacheThrottle<2>.
* CacheDBThrottle: CacheDBThrottle<2>.


File: django-tastypie.info,  Node: BaseThrottle<2>,  Next: CacheThrottle<2>,  Up: Throttle Options<2>

24.2.1 `BaseThrottle'
---------------------

The no-op throttle option, this does no throttling but implements much
of the common logic and serves as an api-compatible plug. Very useful
for development.


File: django-tastypie.info,  Node: CacheThrottle<2>,  Next: CacheDBThrottle<2>,  Prev: BaseThrottle<2>,  Up: Throttle Options<2>

24.2.2 `CacheThrottle'
----------------------

This uses just the cache to manage throttling. Fast but prone to cache
misses and/or cache restarts.


File: django-tastypie.info,  Node: CacheDBThrottle<2>,  Prev: CacheThrottle<2>,  Up: Throttle Options<2>

24.2.3 `CacheDBThrottle'
------------------------

A write-through option that uses the cache first & foremost, but also
writes through to the database to persist access times. Useful for
logging client accesses & with RAM-only caches.


File: django-tastypie.info,  Node: Implementing Your Own Throttle<2>,  Prev: Throttle Options<2>,  Up: Throttling<2>

24.3 Implementing Your Own Throttle
===================================

Writing a `Throttle' class is not quite as simple as the other
components.  There are two important methods, `should_be_throttled' &
`accessed'. The `should_be_throttled' method dictates whether or not
the client should be throttled. The `accessed' method allows for the
recording of the hit to the API.

  An example of a subclass might be:

    import random
    from tastypie.throttle import BaseThrottle


    class RandomThrottle(BaseThrottle):
        def should_be_throttled(self, identifier, **kwargs):
            if random.randint(0, 10) % 2 == 0:
              return True

            return False

        def accessed(self, identifier, **kwargs):
            pass

This throttle class would pick a random number between 0 & 10. If the
number is even, their request is allowed through; otherwise, their
request is throttled & rejected.


File: django-tastypie.info,  Node: Paginator<2>,  Next: GeoDjango<2>,  Prev: Throttling<2>,  Up: Top

25 Paginator
************

Similar to Django's `Paginator', Tastypie includes a `Paginator' object
which limits result sets down to sane amounts for passing to the client.

  This is used in place of Django's `Paginator' due to the way
pagination works. `limit' & `offset' (tastypie) are used in place of
`page' (Django) so none of the page-related calculations are necessary.

  This implementation also provides additional details like the
`total_count' of resources seen and convenience links to the
`previous'/`next' pages of data as available.

* Menu:

* Usage: Usage<14>.
* Implementing Your Own Paginator: Implementing Your Own Paginator<2>.


File: django-tastypie.info,  Node: Usage<14>,  Next: Implementing Your Own Paginator<2>,  Up: Paginator<2>

25.1 Usage
==========

Using this class is simple, but slightly different than the other
classes used by Tastypie. Like the others, you provide the `Paginator'
(or your own subclass) as a `Meta' option to the `Resource' in
question. *Unlike* the others, you provide the class, _NOT_ an
instance. For example:

    from django.contrib.auth.models import User
    from tastypie.paginator import Paginator
    from tastypie.resources import ModelResource


    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()
            resource_name = 'auth/user'
            excludes = ['email', 'password', 'is_superuser']
            # Add it here.
            paginator_class = Paginator



File: django-tastypie.info,  Node: Implementing Your Own Paginator<2>,  Prev: Usage<14>,  Up: Paginator<2>

25.2 Implementing Your Own Paginator
====================================

Adding other features to a paginator usually consists of overriding one
of the built-in methods. For instance, adding a page number to the
output might look like:

    from tastypie.paginator import Paginator


    class PageNumberPaginator(Paginator):
        def page(self):
            output = super(PageNumberPaginator, self).page()
            output['page_number'] = int(self.offset / self.limit) + 1
            return output

Another common request is to alter the structure Tastypie uses in the
list view. Here's an example of renaming:

    from tastypie.paginator import Paginator


    class BlogEntryPaginator(Paginator):
        def page(self):
            output = super(BlogEntryPaginator, self).page()

            # First keep a reference.
            output['pagination'] = output['meta']
            output['entries'] = output['objects']

            # Now nuke the original keys.
            del output['meta']
            del output['objects']

            return output



File: django-tastypie.info,  Node: GeoDjango<2>,  Next: ContentTypes and GenericForeignKeys<2>,  Prev: Paginator<2>,  Up: Top

26 GeoDjango
************

Tastypie features support for GeoDjango!  Resources return and accept
GeoJSON(1) (or similarly-formatted analogs for other formats) and all
spatial lookup(2) filters are supported.  Distance lookups are not yet
supported.

* Menu:

* Usage: Usage<15>.

Usage

* Filtering: Filtering<2>.

  ---------- Footnotes ----------

  (1) http://geojson.org/geojson-spec.html

  (2)
https://docs.djangoproject.com/en/1.3/ref/contrib/gis/geoquerysets/#spatial-lookups


File: django-tastypie.info,  Node: Usage<15>,  Up: GeoDjango<2>

26.1 Usage
==========

Here's an example geographic model for leaving notes in polygonal
regions:

    from django.contrib.gis import models

    class GeoNote(models.Model):
        content = models.TextField()
        polys = models.MultiPolygonField(null=True, blank=True)

        objects = models.GeoManager()

To define a resource that takes advantage of the geospatial features,
we use `tastypie.contrib.gis.resources.ModelResource':

    from tastypie.contrib.gis.resources import ModelResource

    class GeoNoteResource(ModelResource):
        class Meta:
            resource_name = 'geonotes'
            queryset = GeoNote.objects.all()

            filtering = {
                'polys': ALL,
            }

Now when we do a `GET' on our GeoNoteResource we get back GeoJSON in
our response:

    {
        "content": "My note content",
        "id": "1",
        "polys": {
            "coordinates": [[[
                [-122.511067, 37.771276], [-122.510037, 37.766390999999999],
                [-122.510037, 37.763812999999999], [-122.456822, 37.765847999999998],
                [-122.45296, 37.766458999999998], [-122.454848, 37.773989999999998],
                [-122.475362, 37.773040000000002], [-122.511067, 37.771276]
            ]]],
            "type": "MultiPolygon"
        },
        "resource_uri": "/api/v1/geonotes/1/"
    }

When updating or creating new resources, simply provide GeoJSON or the
GeoJSON analog for your perferred format.

* Menu:

* Filtering: Filtering<2>.


File: django-tastypie.info,  Node: Filtering<2>,  Up: Usage<15>

26.1.1 Filtering
----------------

We can filter using any standard GeoDjango spatial lookup(1) filter.
Simply provide a GeoJSON (or the analog) as a `GET' parameter value.

  Let's find all of our `GeoNote' resources that contain a point inside
of Golden Gate Park(2):

    /api/v1/geonotes/?polys__contains={"type": "Point", "coordinates": [-122.475233, 37.768617]}

Returns:

    {
        "meta": {
            "limit": 20, "next": null, "offset": 0, "previous": null, "total_count": 1},
        "objects": [
            {
                "content": "My note content",
                "id": "1",
                "polys": {
                    "coordinates": [[[
                        [-122.511067, 37.771276], [-122.510037, 37.766390999999999],
                        [-122.510037, 37.763812999999999], [-122.456822, 37.765847999999998],
                        [-122.45296, 37.766458999999998], [-122.454848, 37.773989999999998],
                        [-122.475362, 37.773040000000002], [-122.511067, 37.771276]
                    ]]],
                    "type": "MultiPolygon"
                },
                "resource_uri": "/api/geonotes/1/"
            }
        ]
    }

We get back the `GeoNote' resource defining Golden Gate Park.  Awesome!

  ---------- Footnotes ----------

  (1)
https://docs.djangoproject.com/en/1.3/ref/contrib/gis/geoquerysets/#spatial-lookups

  (2) https://sf.localwiki.org/Golden_Gate_Park


File: django-tastypie.info,  Node: ContentTypes and GenericForeignKeys<2>,  Next: Tastypie Cookbook<2>,  Prev: GeoDjango<2>,  Up: Top

27 ContentTypes and GenericForeignKeys
**************************************

Content Types(1) and GenericForeignKeys are for relationships where the
model on one end is not defined by the model's schema.

  If you're using GenericForeignKeys in django, you can use a
GenericForeignKeyField in Tastypie.

* Menu:

* Usage: Usage<16>.

  ---------- Footnotes ----------

  (1) https://docs.djangoproject.com/en/dev/ref/contrib/contenttypes/


File: django-tastypie.info,  Node: Usage<16>,  Up: ContentTypes and GenericForeignKeys<2>

27.1 Usage
==========

Here's an example model with a GenericForeignKey taken from the Django
docs:

    from django.db import models
    from django.contrib.contenttypes.models import ContentType
    from django.contrib.contenttypes import generic

    class TaggedItem(models.Model):
        tag = models.SlugField()
        content_type = models.ForeignKey(ContentType)
        object_id = models.PositiveIntegerField()
        content_object = generic.GenericForeignKey('content_type', 'object_id')

        def __unicode__(self):
            return self.tag

A simple ModelResource for this model might look like this:

    from tastypie.contrib.contenttypes.fields import GenericForeignKeyField
    from tastypie.resources import ModelResource

    from .models import Note, Quote, TaggedItem


    class QuoteResource(ModelResource):

        class Meta:
            resource_name = 'quotes'
            queryset = Quote.objects.all()


    class NoteResource(ModelResource):

        class Meta:
            resource_name = 'notes'
            queryset = Note.objects.all()


    class TaggedItemResource(ModelResource):
        content_object = GenericForeignKeyField({
            Note: NoteResource,
            Quote: QuoteResource
        }, 'content_object')

        class Meta:
            resource_name = 'tagged_items'
            queryset = TaggedItem.objects.all()

Like ToOneField, you must add your GenericForeignKey attribute to your
ModelResource definition. It will not be added automatically like most
other field or attribute types. When you define it, you must also
define the other models and match them to their resources in a
dictionary, and pass that as the first argument, the second argument is
the name of the attribute on the model that holds the GenericForeignKey.


File: django-tastypie.info,  Node: Tastypie Cookbook<2>,  Next: Debugging Tastypie<2>,  Prev: ContentTypes and GenericForeignKeys<2>,  Up: Top

28 Tastypie Cookbook
********************

* Menu:

* Adding Custom Values: Adding Custom Values<2>.
* Per-Request Alterations To The Queryset: Per-Request Alterations To The Queryset<2>.
* Using Your Resource In Regular Views: Using Your Resource In Regular Views<2>.
* Using Non-PK Data For Your URLs: Using Non-PK Data For Your URLs<2>.
* Nested Resources: Nested Resources<2>.
* Adding Search Functionality: Adding Search Functionality<2>.
* Creating per-user resources: Creating per-user resources<2>.
* camelCase JSON Serialization: camelCase JSON Serialization<2>.
* Pretty-printed JSON Serialization: Pretty-printed JSON Serialization<2>.
* Determining format via URL: Determining format via URL<2>.
* Adding to the Django Admin: Adding to the Django Admin<2>.
* Using SessionAuthentication: Using SessionAuthentication<2>.


File: django-tastypie.info,  Node: Adding Custom Values<2>,  Next: Per-Request Alterations To The Queryset<2>,  Up: Tastypie Cookbook<2>

28.1 Adding Custom Values
=========================

You might encounter cases where you wish to include additional data in a
response which is not obtained from a field or method on your model.
You can easily extend the `dehydrate()' method to provide additional
values:

    class MyModelResource(Resource):
        class Meta:
            qs = MyModel.objects.all()

        def dehydrate(self, bundle):
            bundle.data['custom_field'] = "Whatever you want"
            return bundle



File: django-tastypie.info,  Node: Per-Request Alterations To The Queryset<2>,  Next: Using Your Resource In Regular Views<2>,  Prev: Adding Custom Values<2>,  Up: Tastypie Cookbook<2>

28.2 Per-Request Alterations To The Queryset
============================================

A common pattern is needing to limit a queryset by something that
changes per-request, for instance the date/time. You can accomplish
this by lightly modifying `get_object_list':

    from tastypie.utils import now

    class MyResource(ModelResource):
        class Meta:
            queryset = MyObject.objects.all()

        def get_object_list(self, request):
            return super(MyResource, self).get_object_list(request).filter(start_date__gte=now)



File: django-tastypie.info,  Node: Using Your Resource In Regular Views<2>,  Next: Using Non-PK Data For Your URLs<2>,  Prev: Per-Request Alterations To The Queryset<2>,  Up: Tastypie Cookbook<2>

28.3 Using Your `Resource' In Regular Views
===========================================

In addition to using your resource classes to power the API, you can
also use them to write other parts of your application, such as your
views. For instance, if you wanted to encode user information in the
page for some Javascript's use, you could do the following:

    # views.py
    from django.shortcuts import render_to_response
    from myapp.api.resources import UserResource


    def user_detail(request, username):
        ur = UserResource()
        user = ur.obj_get(username=username)

        # Other things get prepped to go into the context then...

        ur_bundle = ur.build_bundle(obj=user, request=request)
        return render_to_response('myapp/user_detail.html', {
            # Other things here.
            "user_json": ur.serialize(None, ur.full_dehydrate(ur_bundle), 'application/json'),
        })



File: django-tastypie.info,  Node: Using Non-PK Data For Your URLs<2>,  Next: Nested Resources<2>,  Prev: Using Your Resource In Regular Views<2>,  Up: Tastypie Cookbook<2>

28.4 Using Non-PK Data For Your URLs
====================================

By convention, `ModelResource's usually expose the detail endpoints
utilizing the primary key of the `Model' they represent. However, this
is not a strict requirement. Each URL can take other named URLconf
parameters that can be used for the lookup.

  For example, if you want to expose `User' resources by username, you
can do something like the following:

    # myapp/api/resources.py
    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()

        def prepend_urls(self):
            return [
                url(r"^(?P<resource_name>%s)/(?P<username>[\w\d_.-]+)/$" % self._meta.resource_name, self.wrap_view('dispatch_detail'), name="api_dispatch_detail"),
            ]

The added URLconf matches before the standard URLconf included by
default & matches on the username provided in the URL.


File: django-tastypie.info,  Node: Nested Resources<2>,  Next: Adding Search Functionality<2>,  Prev: Using Non-PK Data For Your URLs<2>,  Up: Tastypie Cookbook<2>

28.5 Nested Resources
=====================

You can also do "nested resources" (resources within another related
resource) by lightly overriding the `prepend_urls' method & adding on a
new method to handle the children:

    class ParentResource(ModelResource):
        children = fields.ToManyField(ChildResource, 'children')

        def prepend_urls(self):
            return [
                url(r"^(?P<resource_name>%s)/(?P<pk>\w[\w/-]*)/children%s$" % (self._meta.resource_name, trailing_slash()), self.wrap_view('get_children'), name="api_get_children"),
            ]

        def get_children(self, request, **kwargs):
            try:
                obj = self.cached_obj_get(request=request, **self.remove_api_resource_names(kwargs))
            except ObjectDoesNotExist:
                return HttpGone()
            except MultipleObjectsReturned:
                return HttpMultipleChoices("More than one resource is found at this URI.")

            child_resource = ChildResource()
            return child_resource.get_detail(request, parent_id=obj.pk)

Another alternative approach is to override the `dispatch' method:

    # myapp/api/resources.py
    class EntryResource(ModelResource):
        user = fields.ForeignKey(UserResource, 'user')

        class Meta:
            queryset = Entry.objects.all()
            resource_name = 'entry'

        def dispatch(self, request_type, request, **kwargs):
            username = kwargs.pop('username')
            kwargs['user'] = get_object_or_404(User, username=username)
            return super(EntryResource, self).dispatch(request_type, request, **kwargs)

    # urls.py
    from django.conf.urls.defaults import *
    from myapp.api import EntryResource

    entry_resource = EntryResource()

    urlpatterns = patterns('',
        # The normal jazz here, then...
        (r'^api/(?P<username>\w+)/', include(entry_resource.urls)),
    )



File: django-tastypie.info,  Node: Adding Search Functionality<2>,  Next: Creating per-user resources<2>,  Prev: Nested Resources<2>,  Up: Tastypie Cookbook<2>

28.6 Adding Search Functionality
================================

Another common request is being able to integrate search functionality.
This approach uses Haystack(1), though you could hook it up to any
search technology.  We leave the CRUD methods of the resource alone,
choosing to add a new endpoint at `/api/v1/notes/search/':

    from django.conf.urls.defaults import *
    from django.core.paginator import Paginator, InvalidPage
    from django.http import Http404
    from haystack.query import SearchQuerySet
    from tastypie.resources import ModelResource
    from tastypie.utils import trailing_slash
    from notes.models import Note


    class NoteResource(ModelResource):
        class Meta:
            queryset = Note.objects.all()
            resource_name = 'notes'

        def prepend_urls(self):
            return [
                url(r"^(?P<resource_name>%s)/search%s$" % (self._meta.resource_name, trailing_slash()), self.wrap_view('get_search'), name="api_get_search"),
            ]

        def get_search(self, request, **kwargs):
            self.method_check(request, allowed=['get'])
            self.is_authenticated(request)
            self.throttle_check(request)

            # Do the query.
            sqs = SearchQuerySet().models(Note).load_all().auto_query(request.GET.get('q', ''))
            paginator = Paginator(sqs, 20)

            try:
                page = paginator.page(int(request.GET.get('page', 1)))
            except InvalidPage:
                raise Http404("Sorry, no results on that page.")

            objects = []

            for result in page.object_list:
                bundle = self.build_bundle(obj=result.object, request=request)
                bundle = self.full_dehydrate(bundle)
                objects.append(bundle)

            object_list = {
                'objects': objects,
            }

            self.log_throttled_access(request)
            return self.create_response(request, object_list)


  ---------- Footnotes ----------

  (1) http://haystacksearch.org/


File: django-tastypie.info,  Node: Creating per-user resources<2>,  Next: camelCase JSON Serialization<2>,  Prev: Adding Search Functionality<2>,  Up: Tastypie Cookbook<2>

28.7 Creating per-user resources
================================

One might want to create an API which will require every user to
authenticate and every user will be working only with objects
associated with them. Let's see how to implement it for two basic
operations: listing and creation of an object.

  For listing we want to list only objects for which 'user' field
matches 'request.user'. This could be done by applying a filter in the
`apply_authorization_limits' method of your resource.

  For creating we'd have to wrap `obj_create' method of
`ModelResource'. Then the resulting code will look something like:

    # myapp/api/resources.py
    class EnvironmentResource(ModelResource):
        class Meta:
            queryset = Environment.objects.all()
            resource_name = 'environment'
            list_allowed_methods = ['get', 'post']
            authentication = ApiKeyAuthentication()
            authorization = Authorization()

        def obj_create(self, bundle, request=None, **kwargs):
            return super(EnvironmentResource, self).obj_create(bundle, request, user=request.user)

        def apply_authorization_limits(self, request, object_list):
            return object_list.filter(user=request.user)



File: django-tastypie.info,  Node: camelCase JSON Serialization<2>,  Next: Pretty-printed JSON Serialization<2>,  Prev: Creating per-user resources<2>,  Up: Tastypie Cookbook<2>

28.8 camelCase JSON Serialization
=================================

The convention in the world of Javascript has standardized on camelCase,
where Tastypie uses underscore syntax, which can lead to "ugly" looking
code in Javascript. You can create a custom serializer that emits
values in camelCase instead:

    from tastypie.serializers import Serializer

    class CamelCaseJSONSerializer(Serializer):
        formats = ['json']
        content_types = {
            'json': 'application/json',
        }

        def to_json(self, data, options=None):
            # Changes underscore_separated names to camelCase names to go from python convention to javacsript convention
            data = self.to_simple(data, options)

            def underscoreToCamel(match):
                return match.group()[0] + match.group()[2].upper()

            def camelize(data):
                if isinstance(data, dict):
                    new_dict = {}
                    for key, value in data.items():
                        new_key = re.sub(r"[a-z]_[a-z]", underscoreToCamel, key)
                        new_dict[new_key] = camelize(value)
                    return new_dict
                if isinstance(data, (list, tuple)):
                    for i in range(len(data)):
                        data[i] = camelize(data[i])
                    return data
                return data

            camelized_data = camelize(data)

            return simplejson.dumps(camelized_data, sort_keys=True)

        def from_json(self, content):
            # Changes camelCase names to underscore_separated names to go from javascript convention to python convention
            data = simplejson.loads(content)

            def camelToUnderscore(match):
                return match.group()[0] + "_" + match.group()[1].lower()

            def underscorize(data):
                if isinstance(data, dict):
                    new_dict = {}
                    for key, value in data.items():
                        new_key = re.sub(r"[a-z][A-Z]", camelToUnderscore, key)
                        new_dict[new_key] = underscorize(value)
                    return new_dict
                if isinstance(data, (list, tuple)):
                    for i in range(len(data)):
                        data[i] = underscorize(data[i])
                    return data
                return data

        underscored_data = underscorize(data)

        return underscored_data



File: django-tastypie.info,  Node: Pretty-printed JSON Serialization<2>,  Next: Determining format via URL<2>,  Prev: camelCase JSON Serialization<2>,  Up: Tastypie Cookbook<2>

28.9 Pretty-printed JSON Serialization
======================================

By default, Tastypie outputs JSON with no indentation or newlines
(equivalent to calling `json.dumps()' with _indent_ set to `None'). You
can override this behavior in a custom serializer:

    from django.core.serializers import json
    from django.utils import simplejson
    from tastypie.serializers import Serializer

    class PrettyJSONSerializer(Serializer):
        json_indent = 2

        def to_json(self, data, options=None):
            options = options or {}
            data = self.to_simple(data, options)
            return simplejson.dumps(data, cls=json.DjangoJSONEncoder,
                    sort_keys=True, ensure_ascii=False, indent=self.json_indent)



File: django-tastypie.info,  Node: Determining format via URL<2>,  Next: Adding to the Django Admin<2>,  Prev: Pretty-printed JSON Serialization<2>,  Up: Tastypie Cookbook<2>

28.10 Determining format via URL
================================

Sometimes it's required to allow selecting the response format by
specifying it in the API URL, for example `/api/v1/users.json' instead
of `/api/v1/users/?format=json'. The following snippet allows that kind
of syntax additional to the default URL scheme:

    # myapp/api/resources.py
    class UserResource(ModelResource):
        class Meta:
            queryset = User.objects.all()

        def prepend_urls(self):
            """
            Returns a URL scheme based on the default scheme to specify
            the response format as a file extension, e.g. /api/v1/users.json
            """
            return [
                url(r"^(?P<resource_name>%s)\.(?P<format>\w+)$" % self._meta.resource_name, self.wrap_view('dispatch_list'), name="api_dispatch_list"),
                url(r"^(?P<resource_name>%s)/schema\.(?P<format>\w+)$" % self._meta.resource_name, self.wrap_view('get_schema'), name="api_get_schema"),
                url(r"^(?P<resource_name>%s)/set/(?P<pk_list>\w[\w/;-]*)\.(?P<format>\w+)$" % self._meta.resource_name, self.wrap_view('get_multiple'), name="api_get_multiple"),
                url(r"^(?P<resource_name>%s)/(?P<pk>\w[\w/-]*)\.(?P<format>\w+)$" % self._meta.resource_name, self.wrap_view('dispatch_detail'), name="api_dispatch_detail"),
            ]

        def determine_format(self, request):
            """
            Used to determine the desired format from the request.format
            attribute.
            """
            if (hasattr(request, 'format') and
                    request.format in self._meta.serializer.formats):
                return self._meta.serializer.get_mime_for_format(request.format)
            return super(UserResource, self).determine_format(request)

        def wrap_view(self, view):
            def wrapper(request, *args, **kwargs):
                request.format = kwargs.pop('format', None)
                wrapped_view = super(UserResource, self).wrap_view(view)
                return wrapped_view(request, *args, **kwargs)
            return wrapper



File: django-tastypie.info,  Node: Adding to the Django Admin<2>,  Next: Using SessionAuthentication<2>,  Prev: Determining format via URL<2>,  Up: Tastypie Cookbook<2>

28.11 Adding to the Django Admin
================================

If you're using the django admin and ApiKeyAuthentication, you may want
to see or edit ApiKeys next to users. To do this, you need to
unregister the built-in UserAdmin, alter the inlines, and re-register
it. This could go in any of your admin.py files. You may also want to
register ApiAccess and ApiKey models on their own.:

    from tastypie.admin import ApiKeyInline
    from tastypie.models import ApiAccess, ApiKey
    from django.contrib.auth.admin import UserAdmin
    from django.contrib.auth.models import User

    admin.site.register(ApiKey)
    admin.site.register(ApiAccess)

    class UserModelAdmin(UserAdmin):
        inlines = UserAdmin.inlines + [ApiKeyInline]

    admin.site.unregister(User)
    admin.site.register(User,UserModelAdmin)



File: django-tastypie.info,  Node: Using SessionAuthentication<2>,  Prev: Adding to the Django Admin<2>,  Up: Tastypie Cookbook<2>

28.12 Using `SessionAuthentication'
===================================

If your users are logged into the site & you want Javascript to be able
to access the API (assuming jQuery), the first thing to do is setup
`SessionAuthentication':

    from django.contrib.auth.models import User
    from tastypie.authentication import SessionAuthentication
    from tastypie.resources import ModelResource


    class UserResource(ModelResource):
        class Meta:
            resource_name = 'users'
            queryset = User.objects.all()
            authentication = SessionAuthentication()

Then you'd build a template like:

    <html>
        <head>
            <title></title>
            <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
            <script type="text/javascript">
                $(document).ready(function() {
                    // We use ``.ajax`` here due to the overrides.
                    $.ajax({
                        // Substitute in your API endpoint here.
                        url: '/api/v1/users/',
                        contentType: 'application/json',
                        // The ``X-CSRFToken`` evidently can't be set in the
                        // ``headers`` option, so force it here.
                        // This method requires jQuery 1.5+.
                        beforeSend: function(jqXHR, settings) {
                            // Pull the token out of the DOM.
                            jqXHR.setRequestHeader('X-CSRFToken', $('input[name=csrfmiddlewaretoken]').val());
                        },
                        success: function(data, textStatus, jqXHR) {
                            // Your processing of the data here.
                            console.log(data);
                        }
                    });
                });
            </script>
        </head>
        <body>
            <!-- Include the CSRF token in the body of the HTML -->
            {% csrf_token %}
        </body>
    </html>

There are other ways to make this function, with other libraries or
other techniques for supplying the token (see
<https://docs.djangoproject.com/en/dev/ref/contrib/csrf/#ajax> for an
alternative). This is simply a starting point for getting things
working.


File: django-tastypie.info,  Node: Debugging Tastypie<2>,  Next: Sites Using Tastypie<2>,  Prev: Tastypie Cookbook<2>,  Up: Top

29 Debugging Tastypie
*********************

There are some common problems people run into when using Tastypie for
the first time. Some of the common problems and things to try appear
below.

* Menu:

* "I'm getting XML output in my browser but I want JSON output!": "I'm getting XML output in my browser but I want JSON output!"<2>.
* "What's the format for a POST or PUT?": "What's the format for a POST or PUT?"<2>.
* "Why is my syncdb with superuser failing with a DatabaseError?": "Why is my syncdb with superuser failing with a DatabaseError?"<2>.


File: django-tastypie.info,  Node: "I'm getting XML output in my browser but I want JSON output!"<2>,  Next: "What's the format for a POST or PUT?"<2>,  Up: Debugging Tastypie<2>

29.1 "I'm getting XML output in my browser but I want JSON output!"
===================================================================

This is actually not a bug and JSON support is present in your
`Resource'.  This issue is that Tastypie respects the `Accept' header
your browser sends.  Most browsers send something like:

    Accept: application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5

Note that `application/xml' comes first, which is a format that Tastypie
handles by default, hence why you receive XML.

  If you use `curl' from the command line, you should receive JSON by
default:

    curl http://localhost:8000/api/v1/

If you want JSON in the browser, simply append `?format=json' to your
URL.  Tastypie always respects this override first, before it falls
back to the `Accept' header.


File: django-tastypie.info,  Node: "What's the format for a POST or PUT?"<2>,  Next: "Why is my syncdb with superuser failing with a DatabaseError?"<2>,  Prev: "I'm getting XML output in my browser but I want JSON output!"<2>,  Up: Debugging Tastypie<2>

29.2 "What's the format for a POST or PUT?"
===========================================

You can view full schema for your resource through *note Inspecting The
Resource's Schema: 1e.

  In general, Tastypie will accept resources in the same format as it
gives you.  This means that you can see what any POST or PUT should
look like by performing a GET of that resource.

  Creating a duplicate of an entry, using Python and Requests(1):

    import requests
    import json

    response = requests.get('http://localhost:8000/api/v1/entry/1/')
    event = json.loads(response.content)

    del event['id'] # We want the server to assign a new id

    response = requests.post('http://localhost:8000/api/v1/entry/',
                             data=json.dumps(event),
                             headers={'content-type': 'application/json'})

The new event should be almost identical, with the exception of readonly
fields. This method may fail if your model has a unique constraint, or
otherwise fails validation.

  This is less likely to happen on PUT, except for application logic
changes (e.g. a `last_update' field). The following two `curl' commands
replace and entry with an copy:

    curl -H 'Accept: application/json' 'http://localhost:8000/api/v1/entry/1/' | \
    curl -H 'Content-Type: application/json' -X PUT --data @- "http://localhost:8000/api/v1/entry/1/"

You can do this over an entire collection as well:

    curl -H 'Accept: application/json' 'http://localhost:8000/api/v1/entry/?limit=0' | \
    curl -H 'Content-Type: application/json' -X PUT --data @- "http://localhost:8000/api/v1/entry/"


  ---------- Footnotes ----------

  (1) http://python-requests.org


File: django-tastypie.info,  Node: "Why is my syncdb with superuser failing with a DatabaseError?"<2>,  Prev: "What's the format for a POST or PUT?"<2>,  Up: Debugging Tastypie<2>

29.3 "Why is my syncdb with superuser failing with a DatabaseError?"
====================================================================

More specifically, this specific `DatabaseError':

    django.db.utils.DatabaseError: no such table: tastypie_apikey

This is a side effect of the (disabled by default) `create_api_key'
signal as described in the *note Authentication / Authorization: 1d6.
section of the documentation when used in conjunction with South.

  To work around this issue, you can disable the `create_api_key' signal
until you have completed running `syncdb --migrate' for the first time.


File: django-tastypie.info,  Node: Sites Using Tastypie<2>,  Next: Contributing<2>,  Prev: Debugging Tastypie<2>,  Up: Top

30 Sites Using Tastypie
***********************

The following sites are a partial list of people using Tastypie. I'm
always interested in adding more sites, so please find me
(`daniellindsley') via IRC or start a mailing list thread.

* Menu:

* LJWorld Marketplace: LJWorld Marketplace<2>.
* Forkinit: Forkinit<2>.
* Read The Docs: Read The Docs<2>.
* Luzme: Luzme<2>.
* Politifact: Politifact<2>.
* Crate: Crate<2>.
* LocalWiki: LocalWiki<2>.
* I-Am-CC.org: I-Am-CC org<2>.


File: django-tastypie.info,  Node: LJWorld Marketplace<2>,  Next: Forkinit<2>,  Up: Sites Using Tastypie<2>

30.1 LJWorld Marketplace
========================

   * <http://www2.ljworld.com/marketplace/api/v1/?format=json>


File: django-tastypie.info,  Node: Forkinit<2>,  Next: Read The Docs<2>,  Prev: LJWorld Marketplace<2>,  Up: Sites Using Tastypie<2>

30.2 Forkinit
=============

Read-only API access to recipes.

   * <http://forkinit.com/>

   * <http://forkinit.com/api/v1/?format=json>


File: django-tastypie.info,  Node: Read The Docs<2>,  Next: Luzme<2>,  Prev: Forkinit<2>,  Up: Sites Using Tastypie<2>

30.3 Read The Docs
==================

A hosted documentation site, primarily for Python docs. General purpose
read-write access.

   * <http://readthedocs.org/>

   * <http://readthedocs.org/api/v1/?format=json>


File: django-tastypie.info,  Node: Luzme<2>,  Next: Politifact<2>,  Prev: Read The Docs<2>,  Up: Sites Using Tastypie<2>

30.4 Luzme
==========

An e-book search site that lets you fetch pricing information.

   * <http://luzme.com/>

   * <http://luzme.readthedocs.org/en/latest/>


File: django-tastypie.info,  Node: Politifact<2>,  Next: Crate<2>,  Prev: Luzme<2>,  Up: Sites Using Tastypie<2>

30.5 Politifact
===============

To power their mobile (iPhone/Android/Playbook) applications.

   * <http://www.politifact.com/mobile/>


File: django-tastypie.info,  Node: Crate<2>,  Next: LocalWiki<2>,  Prev: Politifact<2>,  Up: Sites Using Tastypie<2>

30.6 Crate
==========

Crate is a PyPI mirror/replacement. It's using Tastypie to provide a
convenient REST API.

   * <https://crate.io/api/v1/>


File: django-tastypie.info,  Node: LocalWiki<2>,  Next: I-Am-CC org<2>,  Prev: Crate<2>,  Up: Sites Using Tastypie<2>

30.7 LocalWiki
==============

LocalWiki(1) is a tool for collaborating in local, geographic
communities. It's using Tastypie to provide an geospatially-aware REST
API.

   * <http://localwiki.readthedocs.org/en/latest/api.html>

   * <http://localwiki.org/blog/2012/aug/31/localwiki-api-released/>

  ---------- Footnotes ----------

  (1) http://localwiki.org


File: django-tastypie.info,  Node: I-Am-CC org<2>,  Prev: LocalWiki<2>,  Up: Sites Using Tastypie<2>

30.8 I-Am-CC.org
================

I-Am-CC.org(1) is a tool for releasing Instagram photos under a
Creative Commons license.

   * <http://i-am-cc.org/api/?format=json>

  ---------- Footnotes ----------

  (1) http://i-am-cc.org


File: django-tastypie.info,  Node: Contributing<2>,  Next: Indices and tables,  Prev: Sites Using Tastypie<2>,  Up: Top

31 Contributing
***************

Tastypie is open-source and, as such, grows (or shrinks) & improves in
part due to the community. Below are some guidelines on how to help
with the project.

* Menu:

* Philosophy: Philosophy<2>.
* Guidelines For Reporting An Issue/Feature: Guidelines For Reporting An Issue/Feature<2>.
* Guidelines For Contributing Code: Guidelines For Contributing Code<2>.
* Guidelines For Core Contributors: Guidelines For Core Contributors<2>.


File: django-tastypie.info,  Node: Philosophy<2>,  Next: Guidelines For Reporting An Issue/Feature<2>,  Up: Contributing<2>

31.1 Philosophy
===============

   * Tastypie is BSD-licensed. All contributed code must be either

        * the original work of the author, contributed under the BSD,
          or...

        * work taken from another project released under a
          BSD-compatible license.

   * GPL'd (or similar) works are not eligible for inclusion.

   * Tastypie's git master branch should always be stable,
     production-ready & passing all tests.

   * Major releases (1.x.x) are commitments to backward-compatibility
     of the public APIs.  Any documented API should ideally not change
     between major releases.  The exclusion to this rule is in the
     event of either a security issue or to accommodate changes in
     Django itself.

   * Minor releases (x.3.x) are for the addition of substantial
     features or major bugfixes.

   * Patch releases (x.x.4) are for minor features or bugfixes.


File: django-tastypie.info,  Node: Guidelines For Reporting An Issue/Feature<2>,  Next: Guidelines For Contributing Code<2>,  Prev: Philosophy<2>,  Up: Contributing<2>

31.2 Guidelines For Reporting An Issue/Feature
==============================================

So you've found a bug or have a great idea for a feature. Here's the
steps you should take to help get it added/fixed in Tastypie:

   * First, check to see if there's an existing issue/pull request for
     the bug/feature. All issues are at
     <https://github.com/toastdriven/django-tastypie/issues> and pull
     reqs are at <https://github.com/toastdriven/django-tastypie/pulls>.

   * If there isn't one there, please file an issue. The ideal report
     includes:

        * A description of the problem/suggestion.

        * How to recreate the bug.

        * If relevant, including the versions of your:

             * Python interpreter

             * Django

             * Tastypie

             * Optionally of the other dependencies involved

        * Ideally, creating a pull request with a (failing) test case
          demonstrating what's wrong. This makes it easy for us to
          reproduce & fix the problem.  Instructions for running the
          tests are at *note Welcome to Tastypie!: 2.

  You might also hop into the IRC channel (`#tastypie' on
`irc.freenode.net') & raise your question there, as there may be
someone who can help you with a work-around.


File: django-tastypie.info,  Node: Guidelines For Contributing Code<2>,  Next: Guidelines For Core Contributors<2>,  Prev: Guidelines For Reporting An Issue/Feature<2>,  Up: Contributing<2>

31.3 Guidelines For Contributing Code
=====================================

If you're ready to take the plunge & contribute back some code/docs, the
process should look like:

   * Fork the project on GitHub into your own account.

   * Clone your copy of Tastypie.

   * Make a new branch in git & commit your changes there.

   * Push your new branch up to GitHub.

   * Again, ensure there isn't already an issue or pull request out
     there on it.  If there is & you feel you have a better fix, please
     take note of the issue number & mention it in your pull request.

   * Create a new pull request (based on your branch), including what
     the problem/feature is, versions of your software & referencing
     any related issues/pull requests.

  In order to be merged into Tastypie, contributions must have the
following:

   * A solid patch that:

        * is clear.

        * works across all supported versions of Python/Django.

        * follows the existing style of the code base (mostly PEP-8).

        * comments included as needed.

   * A test case that demonstrates the previous flaw that now passes
     with the included patch.

   * If it adds/changes a public API, it must also include documentation
     for those changes.

   * Must be appropriately licensed (see "Philosophy").

   * Adds yourself to the AUTHORS file.

  If your contribution lacks any of these things, they will have to be
added by a core contributor before being merged into Tastypie proper,
which may take substantial time for the all-volunteer team to get to.


File: django-tastypie.info,  Node: Guidelines For Core Contributors<2>,  Prev: Guidelines For Contributing Code<2>,  Up: Contributing<2>

31.4 Guidelines For Core Contributors
=====================================

If you've been granted the commit bit, here's how to shepherd the
changes in:

   * Any time you go to work on Tastypie, please use `git pull
     --rebase' to fetch the latest changes.

   * Any new features/bug fixes must meet the above guidelines for
     contributing code (solid patch/tests passing/docs included).

   * Commits are typically cherry-picked onto a branch off master.

        * This is done so as not to include extraneous commits, as some
          people submit pull reqs based on their git master that has
          other things applied to it.

   * A set of commits should be squashed down to a single commit.

        * `git merge --squash' is a good tool for performing this, as is
          `git rebase -i HEAD~N'.

        * This is done to prevent anyone using the git repo from
          accidently pulling work-in-progress commits.

   * Commit messages should use past tense, describe what changed &
     thank anyone involved. Examples:

         """Added a new way to do per-object authorization."""
         """Fixed a bug in ``Serializer.to_xml``. Thanks to joeschmoe for the report!"""
         """BACKWARD-INCOMPATIBLE: Altered the arguments passed to ``Bundle.__init__``.

         Further description appears here if the change warrants an explanation
         as to why it was done."""


   * For any patches applied from a contributor, please ensure their
     name appears in the AUTHORS file.

   * When closing issues or pull requests, please reference the SHA in
     the closing message (i.e. `Thanks! Fixed in SHA: 6b93f6'). GitHub
     will automatically link to it.


File: django-tastypie.info,  Node: Indices and tables,  Next: Python Module Index,  Prev: Contributing<2>,  Up: Top

Indices and tables
******************

   * _search_


File: django-tastypie.info,  Node: Python Module Index,  Next: Index,  Prev: Indices and tables,  Up: Top

Python Module Index
*******************

* Menu:

* tastypie.fields: 0.


File: django-tastypie.info,  Node: Index,  Prev: Python Module Index,  Up: Top

Index
*****

 [index ]
* Menu:

* __init__() (TestApiClient method) <1>: __init__<2>.           (line 6)
* __init__() (TestApiClient method):     __init__.              (line 6)
* alter_deserialized_detail_data() (Resource method) <1>: alter_deserialized_detail_data<2>.
                                                                (line 6)
* alter_deserialized_detail_data() (Resource method): alter_deserialized_detail_data.
                                                                (line 6)
* alter_deserialized_list_data() (Resource method) <1>: alter_deserialized_list_data<2>.
                                                                (line 6)
* alter_deserialized_list_data() (Resource method): alter_deserialized_list_data.
                                                                (line 6)
* alter_detail_data_to_serialize() (Resource method) <1>: alter_detail_data_to_serialize<2>.
                                                                (line 6)
* alter_detail_data_to_serialize() (Resource method): alter_detail_data_to_serialize.
                                                                (line 6)
* alter_list_data_to_serialize() (Resource method) <1>: alter_list_data_to_serialize<2>.
                                                                (line 6)
* alter_list_data_to_serialize() (Resource method): alter_list_data_to_serialize.
                                                                (line 6)
* api_field_from_django_field() (ModelResource method) <1>: api_field_from_django_field<2>.
                                                                (line 6)
* api_field_from_django_field() (ModelResource method): api_field_from_django_field.
                                                                (line 6)
* apply_authorization_limits() (Resource method) <1>: apply_authorization_limits<2>.
                                                                (line 6)
* apply_authorization_limits() (Resource method): apply_authorization_limits.
                                                                (line 6)
* apply_filters() (ModelResource method) <1>: apply_filters<4>. (line 6)
* apply_filters() (ModelResource method): apply_filters<2>.     (line 6)
* apply_filters() (Resource method) <1>: apply_filters<3>.      (line 6)
* apply_filters() (Resource method):     apply_filters.         (line 6)
* apply_sorting() (ModelResource method) <1>: apply_sorting<4>. (line 6)
* apply_sorting() (ModelResource method): apply_sorting<2>.     (line 6)
* apply_sorting() (Resource method) <1>: apply_sorting<3>.      (line 6)
* apply_sorting() (Resource method):     apply_sorting.         (line 6)
* assertHttpAccepted() (ResourceTestCase method) <1>: assertHttpAccepted<2>.
                                                                (line 6)
* assertHttpAccepted() (ResourceTestCase method): assertHttpAccepted.
                                                                (line 6)
* assertHttpApplicationError() (ResourceTestCase method) <1>: assertHttpApplicationError<2>.
                                                                (line 6)
* assertHttpApplicationError() (ResourceTestCase method): assertHttpApplicationError.
                                                                (line 6)
* assertHttpBadRequest() (ResourceTestCase method) <1>: assertHttpBadRequest<2>.
                                                                (line 6)
* assertHttpBadRequest() (ResourceTestCase method): assertHttpBadRequest.
                                                                (line 6)
* assertHttpConflict() (ResourceTestCase method) <1>: assertHttpConflict<2>.
                                                                (line 6)
* assertHttpConflict() (ResourceTestCase method): assertHttpConflict.
                                                                (line 6)
* assertHttpCreated() (ResourceTestCase method) <1>: assertHttpCreated<2>.
                                                                (line 6)
* assertHttpCreated() (ResourceTestCase method): assertHttpCreated.
                                                                (line 6)
* assertHttpForbidden() (ResourceTestCase method) <1>: assertHttpForbidden<2>.
                                                                (line 6)
* assertHttpForbidden() (ResourceTestCase method): assertHttpForbidden.
                                                                (line 6)
* assertHttpGone() (ResourceTestCase method) <1>: assertHttpGone<2>.
                                                                (line 6)
* assertHttpGone() (ResourceTestCase method): assertHttpGone.   (line 6)
* assertHttpMethodNotAllowed() (ResourceTestCase method) <1>: assertHttpMethodNotAllowed<2>.
                                                                (line 6)
* assertHttpMethodNotAllowed() (ResourceTestCase method): assertHttpMethodNotAllowed.
                                                                (line 6)
* assertHttpMultipleChoices() (ResourceTestCase method) <1>: assertHttpMultipleChoices<2>.
                                                                (line 6)
* assertHttpMultipleChoices() (ResourceTestCase method): assertHttpMultipleChoices.
                                                                (line 6)
* assertHttpNotFound() (ResourceTestCase method) <1>: assertHttpNotFound<2>.
                                                                (line 6)
* assertHttpNotFound() (ResourceTestCase method): assertHttpNotFound.
                                                                (line 6)
* assertHttpNotImplemented() (ResourceTestCase method) <1>: assertHttpNotImplemented<2>.
                                                                (line 6)
* assertHttpNotImplemented() (ResourceTestCase method): assertHttpNotImplemented.
                                                                (line 6)
* assertHttpNotModified() (ResourceTestCase method) <1>: assertHttpNotModified<2>.
                                                                (line 6)
* assertHttpNotModified() (ResourceTestCase method): assertHttpNotModified.
                                                                (line 6)
* assertHttpOK() (ResourceTestCase method) <1>: assertHttpOK<2>.
                                                                (line 6)
* assertHttpOK() (ResourceTestCase method): assertHttpOK.       (line 6)
* assertHttpSeeOther() (ResourceTestCase method) <1>: assertHttpSeeOther<2>.
                                                                (line 6)
* assertHttpSeeOther() (ResourceTestCase method): assertHttpSeeOther.
                                                                (line 6)
* assertHttpTooManyRequests() (ResourceTestCase method) <1>: assertHttpTooManyRequests<2>.
                                                                (line 6)
* assertHttpTooManyRequests() (ResourceTestCase method): assertHttpTooManyRequests.
                                                                (line 6)
* assertHttpUnauthorized() (ResourceTestCase method) <1>: assertHttpUnauthorized<2>.
                                                                (line 6)
* assertHttpUnauthorized() (ResourceTestCase method): assertHttpUnauthorized.
                                                                (line 6)
* assertKeys() (ResourceTestCase method) <1>: assertKeys<2>.    (line 6)
* assertKeys() (ResourceTestCase method): assertKeys.           (line 6)
* assertValidJSON() (ResourceTestCase method) <1>: assertValidJSON<2>.
                                                                (line 6)
* assertValidJSON() (ResourceTestCase method): assertValidJSON. (line 6)
* assertValidJSONResponse() (ResourceTestCase method) <1>: assertValidJSONResponse<2>.
                                                                (line 6)
* assertValidJSONResponse() (ResourceTestCase method): assertValidJSONResponse.
                                                                (line 6)
* assertValidPlist() (ResourceTestCase method) <1>: assertValidPlist<2>.
                                                                (line 6)
* assertValidPlist() (ResourceTestCase method): assertValidPlist.
                                                                (line 6)
* assertValidPlistResponse() (ResourceTestCase method) <1>: assertValidPlistResponse<2>.
                                                                (line 6)
* assertValidPlistResponse() (ResourceTestCase method): assertValidPlistResponse.
                                                                (line 6)
* assertValidXML() (ResourceTestCase method) <1>: assertValidXML<2>.
                                                                (line 6)
* assertValidXML() (ResourceTestCase method): assertValidXML.   (line 6)
* assertValidXMLResponse() (ResourceTestCase method) <1>: assertValidXMLResponse<2>.
                                                                (line 6)
* assertValidXMLResponse() (ResourceTestCase method): assertValidXMLResponse.
                                                                (line 6)
* assertValidYAML() (ResourceTestCase method) <1>: assertValidYAML<2>.
                                                                (line 6)
* assertValidYAML() (ResourceTestCase method): assertValidYAML. (line 6)
* assertValidYAMLResponse() (ResourceTestCase method) <1>: assertValidYAMLResponse<2>.
                                                                (line 6)
* assertValidYAMLResponse() (ResourceTestCase method): assertValidYAMLResponse.
                                                                (line 6)
* attribute (ApiField attribute) <1>:    attribute<2>.          (line 6)
* attribute (ApiField attribute):        attribute.             (line 6)
* base_urls() (Resource method) <1>:     base_urls<2>.          (line 6)
* base_urls() (Resource method):         base_urls.             (line 6)
* blank (ApiField attribute) <1>:        blank<2>.              (line 6)
* blank (ApiField attribute):            blank.                 (line 6)
* build_bundle() (Resource method) <1>:  build_bundle<2>.       (line 6)
* build_bundle() (Resource method):      build_bundle.          (line 6)
* build_filters() (ModelResource method) <1>: build_filters<4>. (line 6)
* build_filters() (ModelResource method): build_filters<2>.     (line 6)
* build_filters() (Resource method) <1>: build_filters<3>.      (line 6)
* build_filters() (Resource method):     build_filters.         (line 6)
* build_schema() (Resource method) <1>:  build_schema<2>.       (line 6)
* build_schema() (Resource method):      build_schema.          (line 6)
* cached_obj_get() (Resource method) <1>: cached_obj_get<2>.    (line 6)
* cached_obj_get() (Resource method):    cached_obj_get.        (line 6)
* cached_obj_get_list() (Resource method) <1>: cached_obj_get_list<2>.
                                                                (line 6)
* cached_obj_get_list() (Resource method): cached_obj_get_list. (line 6)
* can_create() (Resource method) <1>:    can_create<2>.         (line 6)
* can_create() (Resource method):        can_create.            (line 6)
* can_delete() (Resource method) <1>:    can_delete<2>.         (line 6)
* can_delete() (Resource method):        can_delete.            (line 6)
* can_update() (Resource method) <1>:    can_update<2>.         (line 6)
* can_update() (Resource method):        can_update.            (line 6)
* check_filtering() (ModelResource method) <1>: check_filtering<2>.
                                                                (line 6)
* check_filtering() (ModelResource method): check_filtering.    (line 6)
* create_apikey() (ResourceTestCase method) <1>: create_apikey<2>.
                                                                (line 6)
* create_apikey() (ResourceTestCase method): create_apikey.     (line 6)
* create_basic() (ResourceTestCase method) <1>: create_basic<2>.
                                                                (line 6)
* create_basic() (ResourceTestCase method): create_basic.       (line 6)
* create_digest() (ResourceTestCase method) <1>: create_digest<2>.
                                                                (line 6)
* create_digest() (ResourceTestCase method): create_digest.     (line 6)
* create_oauth() (ResourceTestCase method) <1>: create_oauth<2>.
                                                                (line 6)
* create_oauth() (ResourceTestCase method): create_oauth.       (line 6)
* create_response() (Resource method) <1>: create_response<2>.  (line 6)
* create_response() (Resource method):   create_response.       (line 6)
* default (ApiField attribute) <1>:      default<2>.            (line 6)
* default (ApiField attribute):          default.               (line 6)
* dehydrate() (Resource method) <1>:     dehydrate<4>.          (line 6)
* dehydrate() (Resource method):         dehydrate<2>.          (line 6)
* dehydrate_resource_uri() (Resource method) <1>: dehydrate_resource_uri<2>.
                                                                (line 6)
* dehydrate_resource_uri() (Resource method): dehydrate_resource_uri.
                                                                (line 6)
* delete() (TestApiClient method) <1>:   delete<2>.             (line 6)
* delete() (TestApiClient method):       delete.                (line 6)
* delete_detail() (Resource method) <1>: delete_detail<2>.      (line 6)
* delete_detail() (Resource method):     delete_detail.         (line 6)
* delete_list() (Resource method) <1>:   delete_list<2>.        (line 6)
* delete_list() (Resource method):       delete_list.           (line 6)
* deserialize() (Resource method) <1>:   deserialize<5>.        (line 6)
* deserialize() (Resource method):       deserialize<2>.        (line 6)
* deserialize() (ResourceTestCase method) <1>: deserialize<4>.  (line 6)
* deserialize() (ResourceTestCase method): deserialize.         (line 6)
* detail_uri_kwargs() (Resource method) <1>: detail_uri_kwargs<2>.
                                                                (line 6)
* detail_uri_kwargs() (Resource method): detail_uri_kwargs.     (line 6)
* determine_format() (Resource method) <1>: determine_format<2>.
                                                                (line 6)
* determine_format() (Resource method):  determine_format.      (line 6)
* dispatch() (Resource method) <1>:      dispatch<2>.           (line 6)
* dispatch() (Resource method):          dispatch.              (line 6)
* dispatch_detail() (Resource method) <1>: dispatch_detail<2>.  (line 6)
* dispatch_detail() (Resource method):   dispatch_detail.       (line 6)
* dispatch_list() (Resource method) <1>: dispatch_list<2>.      (line 6)
* dispatch_list() (Resource method):     dispatch_list.         (line 6)
* full (tastypie.fields.RelatedField attribute) <1>: full<2>.   (line 6)
* full (tastypie.fields.RelatedField attribute): full.          (line 6)
* full_dehydrate() (Resource method) <1>: full_dehydrate<2>.    (line 6)
* full_dehydrate() (Resource method):    full_dehydrate.        (line 6)
* full_hydrate() (Resource method) <1>:  full_hydrate<2>.       (line 6)
* full_hydrate() (Resource method):      full_hydrate.          (line 6)
* generate_cache_key() (Resource method) <1>: generate_cache_key<2>.
                                                                (line 6)
* generate_cache_key() (Resource method): generate_cache_key.   (line 6)
* get() (TestApiClient method) <1>:      get<2>.                (line 6)
* get() (TestApiClient method):          get.                   (line 6)
* get_bundle_detail_data() (Resource method) <1>: get_bundle_detail_data<2>.
                                                                (line 6)
* get_bundle_detail_data() (Resource method): get_bundle_detail_data.
                                                                (line 6)
* get_content_type() (TestApiClient method) <1>: get_content_type<2>.
                                                                (line 6)
* get_content_type() (TestApiClient method): get_content_type.  (line 6)
* get_credentials() (ResourceTestCase method) <1>: get_credentials<2>.
                                                                (line 6)
* get_credentials() (ResourceTestCase method): get_credentials. (line 6)
* get_detail() (Resource method) <1>:    get_detail<2>.         (line 6)
* get_detail() (Resource method):        get_detail.            (line 6)
* get_fields() (ModelResource method) <1>: get_fields<2>.       (line 6)
* get_fields() (ModelResource method):   get_fields.            (line 6)
* get_list() (Resource method) <1>:      get_list<2>.           (line 6)
* get_list() (Resource method):          get_list.              (line 6)
* get_multiple() (Resource method) <1>:  get_multiple<2>.       (line 6)
* get_multiple() (Resource method):      get_multiple.          (line 6)
* get_object_list() (ModelResource method) <1>: get_object_list<4>.
                                                                (line 6)
* get_object_list() (ModelResource method): get_object_list<2>. (line 6)
* get_object_list() (Resource method) <1>: get_object_list<3>.  (line 6)
* get_object_list() (Resource method):   get_object_list.       (line 6)
* get_resource_uri() (ModelResource method) <1>: get_resource_uri<4>.
                                                                (line 6)
* get_resource_uri() (ModelResource method): get_resource_uri<2>.
                                                                (line 6)
* get_resource_uri() (Resource method) <1>: get_resource_uri<3>.
                                                                (line 6)
* get_resource_uri() (Resource method):  get_resource_uri.      (line 6)
* get_schema() (Resource method) <1>:    get_schema<2>.         (line 6)
* get_schema() (Resource method):        get_schema.            (line 6)
* get_via_uri() (Resource method) <1>:   get_via_uri<2>.        (line 6)
* get_via_uri() (Resource method):       get_via_uri.           (line 6)
* help_text (ApiField attribute) <1>:    help_text<2>.          (line 6)
* help_text (ApiField attribute):        help_text.             (line 6)
* hydrate() (Resource method) <1>:       hydrate<4>.            (line 6)
* hydrate() (Resource method):           hydrate<2>.            (line 6)
* hydrate_m2m() (Resource method) <1>:   hydrate_m2m<2>.        (line 6)
* hydrate_m2m() (Resource method):       hydrate_m2m.           (line 6)
* is_authenticated() (Resource method) <1>: is_authenticated<2>.
                                                                (line 6)
* is_authenticated() (Resource method):  is_authenticated.      (line 6)
* is_authorized() (Resource method) <1>: is_authorized<2>.      (line 6)
* is_authorized() (Resource method):     is_authorized.         (line 6)
* is_valid() (Resource method) <1>:      is_valid<2>.           (line 6)
* is_valid() (Resource method):          is_valid.              (line 6)
* log_throttled_access() (Resource method) <1>: log_throttled_access<2>.
                                                                (line 6)
* log_throttled_access() (Resource method): log_throttled_access.
                                                                (line 6)
* lookup_kwargs_with_identifiers() (Resource method) <1>: lookup_kwargs_with_identifiers<2>.
                                                                (line 6)
* lookup_kwargs_with_identifiers() (Resource method): lookup_kwargs_with_identifiers.
                                                                (line 6)
* method_check() (Resource method) <1>:  method_check<2>.       (line 6)
* method_check() (Resource method):      method_check.          (line 6)
* null (ApiField attribute) <1>:         null<2>.               (line 6)
* null (ApiField attribute):             null.                  (line 6)
* obj_create() (ModelResource method) <1>: obj_create<4>.       (line 6)
* obj_create() (ModelResource method):   obj_create<2>.         (line 6)
* obj_create() (Resource method) <1>:    obj_create<3>.         (line 6)
* obj_create() (Resource method):        obj_create.            (line 6)
* obj_delete() (ModelResource method) <1>: obj_delete<4>.       (line 6)
* obj_delete() (ModelResource method):   obj_delete<2>.         (line 6)
* obj_delete() (Resource method) <1>:    obj_delete<3>.         (line 6)
* obj_delete() (Resource method):        obj_delete.            (line 6)
* obj_delete_list() (ModelResource method) <1>: obj_delete_list<4>.
                                                                (line 6)
* obj_delete_list() (ModelResource method): obj_delete_list<2>. (line 6)
* obj_delete_list() (Resource method) <1>: obj_delete_list<3>.  (line 6)
* obj_delete_list() (Resource method):   obj_delete_list.       (line 6)
* obj_get() (ModelResource method) <1>:  obj_get<4>.            (line 6)
* obj_get() (ModelResource method):      obj_get<2>.            (line 6)
* obj_get() (Resource method) <1>:       obj_get<3>.            (line 6)
* obj_get() (Resource method):           obj_get.               (line 6)
* obj_get_list() (ModelResource method) <1>: obj_get_list<4>.   (line 6)
* obj_get_list() (ModelResource method): obj_get_list<2>.       (line 6)
* obj_get_list() (Resource method) <1>:  obj_get_list<3>.       (line 6)
* obj_get_list() (Resource method):      obj_get_list.          (line 6)
* obj_update() (ModelResource method) <1>: obj_update<4>.       (line 6)
* obj_update() (ModelResource method):   obj_update<2>.         (line 6)
* obj_update() (Resource method) <1>:    obj_update<3>.         (line 6)
* obj_update() (Resource method):        obj_update.            (line 6)
* override_urls() (Resource method) <1>: override_urls<3>.      (line 6)
* override_urls() (Resource method):     override_urls.         (line 6)
* patch() (TestApiClient method) <1>:    patch<2>.              (line 6)
* patch() (TestApiClient method):        patch.                 (line 6)
* patch_detail() (Resource method) <1>:  patch_detail<2>.       (line 6)
* patch_detail() (Resource method):      patch_detail.          (line 6)
* patch_list() (Resource method) <1>:    patch_list<2>.         (line 6)
* patch_list() (Resource method):        patch_list.            (line 6)
* post() (TestApiClient method) <1>:     post<2>.               (line 6)
* post() (TestApiClient method):         post.                  (line 6)
* post_detail() (Resource method) <1>:   post_detail<2>.        (line 6)
* post_detail() (Resource method):       post_detail.           (line 6)
* post_list() (Resource method) <1>:     post_list<2>.          (line 6)
* post_list() (Resource method):         post_list.             (line 6)
* prepend_urls() (Resource method) <1>:  prepend_urls<3>.       (line 6)
* prepend_urls() (Resource method):      prepend_urls.          (line 6)
* put() (TestApiClient method) <1>:      put<2>.                (line 6)
* put() (TestApiClient method):          put.                   (line 6)
* put_detail() (Resource method) <1>:    put_detail<2>.         (line 6)
* put_detail() (Resource method):        put_detail.            (line 6)
* put_list() (Resource method) <1>:      put_list<2>.           (line 6)
* put_list() (Resource method):          put_list.              (line 6)
* readonly (ApiField attribute) <1>:     readonly<2>.           (line 6)
* readonly (ApiField attribute):         readonly.              (line 6)
* related_name (tastypie.fields.RelatedField attribute) <1>: related_name<4>.
                                                                (line 6)
* related_name (tastypie.fields.RelatedField attribute): related_name<2>.
                                                                (line 6)
* remove_api_resource_names() (Resource method) <1>: remove_api_resource_names<2>.
                                                                (line 6)
* remove_api_resource_names() (Resource method): remove_api_resource_names.
                                                                (line 6)
* resource_uri_kwargs() (Resource method) <1>: resource_uri_kwargs<2>.
                                                                (line 6)
* resource_uri_kwargs() (Resource method): resource_uri_kwargs. (line 6)
* rollback() (ModelResource method) <1>: rollback<4>.           (line 6)
* rollback() (ModelResource method):     rollback<2>.           (line 6)
* rollback() (Resource method) <1>:      rollback<3>.           (line 6)
* rollback() (Resource method):          rollback.              (line 6)
* save_m2m() (ModelResource method) <1>: save_m2m<2>.           (line 6)
* save_m2m() (ModelResource method):     save_m2m.              (line 6)
* save_related() (ModelResource method) <1>: save_related<2>.   (line 6)
* save_related() (ModelResource method): save_related.          (line 6)
* serialize() (Resource method) <1>:     serialize<5>.          (line 6)
* serialize() (Resource method):         serialize<2>.          (line 6)
* serialize() (ResourceTestCase method) <1>: serialize<4>.      (line 6)
* serialize() (ResourceTestCase method): serialize.             (line 6)
* should_skip_field() (ModelResource method) <1>: should_skip_field<2>.
                                                                (line 6)
* should_skip_field() (ModelResource method): should_skip_field.
                                                                (line 6)
* tastypie.fields (module) <1>:          Field Types<3>.        (line 6)
* tastypie.fields (module):              Field Types.           (line 6)
* throttle_check() (Resource method) <1>: throttle_check<2>.    (line 6)
* throttle_check() (Resource method):    throttle_check.        (line 6)
* to (tastypie.fields.RelatedField attribute) <1>: to<2>.       (line 6)
* to (tastypie.fields.RelatedField attribute): to.              (line 6)
* unique (ApiField attribute) <1>:       unique<2>.             (line 6)
* unique (ApiField attribute):           unique.                (line 6)
* urls() (Resource method) <1>:          urls<3>.               (line 6)
* urls() (Resource method):              urls.                  (line 6)
* wrap_view() (Resource method) <1>:     wrap_view<2>.          (line 6)
* wrap_view() (Resource method):         wrap_view.             (line 6)



Tag Table:
Node: Top421
Ref: toc doc693
Ref: 1693
Node: Welcome to Tastypie!26866
Ref: index doc26968
Ref: 226968
Ref: index table-of-contents26968
Ref: 326968
Ref: index welcome-to-tastypie26968
Ref: 426968
Node: Getting Started with Tastypie36763
Ref: tutorial ref-tutorial36891
Ref: 536891
Ref: tutorial doc36891
Ref: 636891
Ref: tutorial getting-started-with-tastypie36891
Ref: 736891
Ref: Getting Started with Tastypie-Footnote-138797
Node: Installation38836
Ref: tutorial installation38945
Ref: 838945
Ref: Installation-Footnote-140472
Ref: Installation-Footnote-240525
Ref: Installation-Footnote-340556
Node: Configuration40587
Ref: tutorial configuration40723
Ref: 940723
Ref: tutorial pypi40723
Ref: a40723
Node: Creating Resources41124
Ref: tutorial creating-resources41273
Ref: c41273
Node: Hooking Up The Resource s42550
Ref: tutorial hooking-up-the-resource-s42709
Ref: d42709
Node: Creating More Resources45980
Ref: tutorial creating-more-resources46138
Ref: e46138
Node: Adding To The Api47303
Ref: tutorial adding-to-the-api47460
Ref: f47460
Node: Limiting Data And Access49520
Ref: tutorial limiting-data-and-access49671
Ref: 1049671
Node: Beyond The Basics51069
Ref: tutorial beyond-the-basics51194
Ref: 1151194
Node: Interacting With The API51713
Ref: interacting ref-interacting51867
Ref: 1851867
Ref: interacting doc51867
Ref: 1951867
Ref: interacting interacting-with-the-api51867
Ref: 1a51867
Ref: Interacting With The API-Footnote-153878
Node: Front Matter53906
Ref: interacting front-matter54010
Ref: 1b54010
Node: Fetching Data54823
Ref: interacting fetching-data54948
Ref: 1c54948
Node: Api-Wide55370
Ref: interacting api-wide55478
Ref: 1d55478
Node: Inspecting The Resource's Schema56910
Ref: interacting schema-inspection57060
Ref: 1e57060
Ref: interacting inspecting-the-resource-s-schema57060
Ref: 1f57060
Node: Getting A Collection Of Resources59402
Ref: interacting getting-a-collection-of-resources59569
Ref: 2059569
Node: Getting A Detail Resource62949
Ref: interacting getting-a-detail-resource63115
Ref: 2163115
Node: Selecting A Subset Of Resources64464
Ref: interacting selecting-a-subset-of-resources64588
Ref: 2264588
Node: Sending Data66183
Ref: interacting sending-data66309
Ref: 2366309
Node: Creating A New Resource POST67330
Ref: interacting creating-a-new-resource-post67458
Ref: 2467458
Node: Updating An Existing Resource PUT70482
Ref: interacting updating-an-existing-resource-put70664
Ref: 2570664
Node: Partially Updating An Existing Resource PATCH71769
Ref: interacting partially-updating-an-existing-resource-patch71967
Ref: 2671967
Node: Updating A Whole Collection Of Resources PUT72612
Ref: interacting updating-a-whole-collection-of-resources-put72768
Ref: 2772768
Node: Deleting Data74064
Ref: interacting deleting-data74192
Ref: 2874192
Node: Deleting A Single Resource74484
Ref: interacting deleting-a-single-resource74618
Ref: 2974618
Node: Deleting A Whole Collection Of Resources75701
Ref: interacting deleting-a-whole-collection-of-resources75835
Ref: 2a75835
Node: Bulk Operations76742
Ref: interacting bulk-operations76869
Ref: 2b76869
Node: You Did It!77871
Ref: interacting you-did-it77976
Ref: 2d77976
Node: Tastypie Settings78408
Ref: settings tastypie-settings78573
Ref: 2e78573
Ref: settings ref-settings78573
Ref: 2f78573
Ref: settings doc78573
Ref: b78573
Node: API_LIMIT_PER_PAGE78834
Ref: settings api-limit-per-page78943
Ref: 3078943
Node: TASTYPIE_FULL_DEBUG79427
Ref: settings tastypie-full-debug79566
Ref: 3179566
Node: TASTYPIE_CANNED_ERROR80223
Ref: settings tastypie-canned-error80372
Ref: 3280372
Node: TASTYPIE_ALLOW_MISSING_SLASH80732
Ref: settings tastypie-allow-missing-slash80890
Ref: 3380890
Node: TASTYPIE_DATETIME_FORMATTING81265
Ref: settings tastypie-datetime-formatting81393
Ref: 3481393
Node: Using Tastypie With Non-ORM Data Sources81719
Ref: non_orm_data_sources using-tastypie-with-non-orm-data-sources81865
Ref: 3581865
Ref: non_orm_data_sources ref-non-orm-data-sources81865
Ref: 3681865
Ref: non_orm_data_sources doc81865
Ref: 3781865
Node: Approach82630
Ref: non_orm_data_sources approach82763
Ref: 3882763
Node: Using Riak for MessageResource83546
Ref: non_orm_data_sources using-riak-for-messageresource83679
Ref: 3983679
Ref: Using Riak for MessageResource-Footnote-187898
Node: Tools87953
Ref: tools ref-tools88089
Ref: 3a88089
Ref: tools tools88089
Ref: 3b88089
Ref: tools riak88089
Ref: 3c88089
Ref: tools doc88089
Ref: 3d88089
Node: Browser88433
Ref: tools browser88510
Ref: 3e88510
Node: JSONView88562
Ref: tools jsonview88623
Ref: 3f88623
Node: Extensions88956
Ref: tools extensions89048
Ref: 4089048
Node: Tastypie-msgpack89114
Ref: tools tastypie-msgpack89186
Ref: 4189186
Ref: Tastypie-msgpack-Footnote-189375
Node: Python89402
Ref: tools python89497
Ref: 4289497
Ref: tools msgpack89497
Ref: 4389497
Node: Slumber89580
Ref: tools slumber89653
Ref: 4489653
Node: drest89859
Ref: tools drest89950
Ref: 4589950
Node: json tool90146
Ref: tools json-tool90221
Ref: 4690221
Node: Javascript90662
Ref: tools javascript90738
Ref: 4790738
Node: backbone-tastypie90829
Ref: tools backbone-tastypie90930
Ref: 4890930
Node: backbone-relational91104
Ref: tools backbone-relational91205
Ref: 4991205
Node: Testing91406
Ref: testing testing91521
Ref: 4a91521
Ref: testing doc91521
Ref: 4b91521
Ref: testing ref-testing91521
Ref: 4c91521
Ref: Testing-Footnote-193315
Node: Example Usage93376
Ref: testing example-usage93442
Ref: 4d93442
Node: ResourceTestCase API Reference100754
Ref: testing resourcetestcase-api-reference100879
Ref: 4e100879
Node: get_credentials101829
Ref: testing get-credentials101941
Ref: 4f101941
Ref: testing ResourceTestCase get_credentials101994
Ref: 50101994
Node: create_basic102399
Ref: testing create-basic102533
Ref: 51102533
Ref: testing ResourceTestCase create_basic102580
Ref: 52102580
Node: create_apikey102728
Ref: testing create-apikey102860
Ref: 53102860
Ref: testing ResourceTestCase create_apikey102909
Ref: 54102909
Node: create_digest103069
Ref: testing create-digest103201
Ref: 55103201
Ref: testing ResourceTestCase create_digest103250
Ref: 56103250
Node: create_oauth103422
Ref: testing create-oauth103553
Ref: 57103553
Ref: testing ResourceTestCase create_oauth103600
Ref: 58103600
Node: assertHttpOK103729
Ref: testing asserthttpok103864
Ref: 59103864
Ref: testing ResourceTestCase assertHttpOK103911
Ref: 5a103911
Node: assertHttpCreated104016
Ref: testing asserthttpcreated104157
Ref: 5b104157
Ref: testing ResourceTestCase assertHttpCreated104214
Ref: 5c104214
Node: assertHttpAccepted104324
Ref: testing asserthttpaccepted104478
Ref: 5d104478
Ref: testing ResourceTestCase assertHttpAccepted104537
Ref: 5e104537
Node: assertHttpMultipleChoices104669
Ref: testing asserthttpmultiplechoices104824
Ref: 5f104824
Ref: testing ResourceTestCase assertHttpMultipleChoices104899
Ref: 60104899
Node: assertHttpSeeOther105017
Ref: testing asserthttpseeother105175
Ref: 61105175
Ref: testing ResourceTestCase assertHttpSeeOther105236
Ref: 62105236
Node: assertHttpNotModified105347
Ref: testing asserthttpnotmodified105500
Ref: 63105500
Ref: testing ResourceTestCase assertHttpNotModified105567
Ref: 64105567
Node: assertHttpBadRequest105681
Ref: testing asserthttpbadrequest105838
Ref: 65105838
Ref: testing ResourceTestCase assertHttpBadRequest105903
Ref: 66105903
Node: assertHttpUnauthorized106016
Ref: testing asserthttpunauthorized106171
Ref: 67106171
Ref: testing ResourceTestCase assertHttpUnauthorized106240
Ref: 68106240
Node: assertHttpForbidden106355
Ref: testing asserthttpforbidden106508
Ref: 69106508
Ref: testing ResourceTestCase assertHttpForbidden106571
Ref: 6a106571
Node: assertHttpNotFound106683
Ref: testing asserthttpnotfound106840
Ref: 6b106840
Ref: testing ResourceTestCase assertHttpNotFound106901
Ref: 6c106901
Node: assertHttpMethodNotAllowed107012
Ref: testing asserthttpmethodnotallowed107168
Ref: 6d107168
Ref: testing ResourceTestCase assertHttpMethodNotAllowed107245
Ref: 6e107245
Node: assertHttpConflict107364
Ref: testing asserthttpconflict107516
Ref: 6f107516
Ref: testing ResourceTestCase assertHttpConflict107577
Ref: 70107577
Node: assertHttpGone107688
Ref: testing asserthttpgone107839
Ref: 71107839
Ref: testing ResourceTestCase assertHttpGone107892
Ref: 72107892
Node: assertHttpTooManyRequests107999
Ref: testing asserthttptoomanyrequests108158
Ref: 73108158
Ref: testing ResourceTestCase assertHttpTooManyRequests108233
Ref: 74108233
Node: assertHttpApplicationError108351
Ref: testing asserthttpapplicationerror108520
Ref: 75108520
Ref: testing ResourceTestCase assertHttpApplicationError108597
Ref: 76108597
Node: assertHttpNotImplemented108716
Ref: testing asserthttpnotimplemented108875
Ref: 77108875
Ref: testing ResourceTestCase assertHttpNotImplemented108948
Ref: 78108948
Node: assertValidJSON109065
Ref: testing assertvalidjson109212
Ref: 79109212
Ref: testing ResourceTestCase assertValidJSON109267
Ref: 7a109267
Node: assertValidXML109424
Ref: testing assertvalidxml109562
Ref: 7b109562
Ref: testing ResourceTestCase assertValidXML109615
Ref: 7c109615
Node: assertValidYAML109770
Ref: testing assertvalidyaml109909
Ref: 7d109909
Ref: testing ResourceTestCase assertValidYAML109964
Ref: 7e109964
Node: assertValidPlist110121
Ref: testing assertvalidplist110269
Ref: 7f110269
Ref: testing ResourceTestCase assertValidPlist110326
Ref: 80110326
Node: assertValidJSONResponse110492
Ref: testing assertvalidjsonresponse110647
Ref: 81110647
Ref: testing ResourceTestCase assertValidJSONResponse110718
Ref: 82110718
Node: assertValidXMLResponse110976
Ref: testing assertvalidxmlresponse111138
Ref: 83111138
Ref: testing ResourceTestCase assertValidXMLResponse111207
Ref: 84111207
Node: assertValidYAMLResponse111462
Ref: testing assertvalidyamlresponse111625
Ref: 85111625
Ref: testing ResourceTestCase assertValidYAMLResponse111696
Ref: 86111696
Node: assertValidPlistResponse111947
Ref: testing assertvalidplistresponse112099
Ref: 87112099
Ref: testing ResourceTestCase assertValidPlistResponse112172
Ref: 88112172
Node: deserialize112447
Ref: testing deserialize112585
Ref: 89112585
Ref: testing ResourceTestCase deserialize112632
Ref: 8a112632
Node: serialize112927
Ref: testing serialize113051
Ref: 8b113051
Ref: testing ResourceTestCase serialize113094
Ref: 8c113094
Node: assertKeys113321
Ref: testing assertkeys113425
Ref: 8d113425
Ref: testing ResourceTestCase assertKeys113470
Ref: 8e113470
Node: TestApiClient API Reference113843
Ref: testing testapiclient-api-reference113968
Ref: 8f113968
Node: __init__114329
Ref: testing init114435
Ref: 90114435
Ref: testing TestApiClient __init__114476
Ref: 91114476
Node: get_content_type114677
Ref: testing get-content-type114795
Ref: 92114795
Ref: testing TestApiClient get_content_type114852
Ref: 93114852
Node: get115059
Ref: testing get115173
Ref: 94115173
Ref: testing TestApiClient get115204
Ref: 95115204
Node: post116081
Ref: testing post116182
Ref: 96116182
Ref: testing TestApiClient post116215
Ref: 97116215
Node: put117129
Ref: testing put117232
Ref: 98117232
Ref: testing TestApiClient put117263
Ref: 99117263
Node: patch118175
Ref: testing patch118280
Ref: 9a118280
Ref: testing TestApiClient patch118315
Ref: 9b118315
Node: delete119235
Ref: testing delete119328
Ref: 9c119328
Ref: testing TestApiClient delete119365
Ref: 9d119365
Node: Compatibility Notes120207
Ref: compatibility_notes ref-compatibility-notes120326
Ref: 9e120326
Ref: compatibility_notes doc120326
Ref: 9f120326
Ref: compatibility_notes compatibility-notes120326
Ref: a0120326
Node: ApiKey Database Index120645
Ref: compatibility_notes apikey-database-index120731
Ref: a1120731
Node: Resources121409
Ref: resources ref-resources121528
Ref: a2121528
Ref: resources doc121528
Ref: 15121528
Ref: resources resources121528
Ref: a3121528
Node: Quick Start122411
Ref: resources quick-start122502
Ref: a4122502
Node: Why Class-Based?123610
Ref: resources why-class-based123740
Ref: a5123740
Node: Why Resource vs ModelResource?124394
Ref: resources why-resource-vs-modelresource124552
Ref: a6124552
Node: Flow Through The Request/Response Cycle125032
Ref: resources flow-through-the-request-response-cycle125192
Ref: a7125192
Node: Why Resource URIs?128592
Ref: resources why-resource-uris128747
Ref: a8128747
Node: Advanced Data Preparation129682
Ref: resources advanced-data-preparation129821
Ref: a9129821
Node: The Dehydrate Cycle130334
Ref: resources the-dehydrate-cycle130450
Ref: aa130450
Node: Per-field dehydrate131873
Ref: resources per-field-dehydrate131979
Ref: ab131979
Node: dehydrate_FOO132340
Ref: resources dehydrate-foo132464
Ref: ac132464
Node: dehydrate134253
Ref: resources dehydrate134349
Ref: ad134349
Node: The Hydrate Cycle135889
Ref: resources the-hydrate-cycle136005
Ref: ae136005
Node: hydrate137587
Ref: resources hydrate137677
Ref: af137677
Node: hydrate_FOO138722
Ref: resources hydrate-foo138838
Ref: b0138838
Node: Per-field hydrate139601
Ref: resources per-field-hydrate139701
Ref: b1139701
Node: Reverse "Relationships"140063
Ref: resources reverse-relationships140209
Ref: b2140209
Node: Resource Options AKA Meta142052
Ref: resources resource-options-aka-meta142188
Ref: b3142188
Node: serializer142856
Ref: resources serializer142960
Ref: b4142960
Node: authentication143121
Ref: resources authentication143247
Ref: b5143247
Node: authorization143427
Ref: resources authorization143553
Ref: b6143553
Node: validation143736
Ref: resources validation143863
Ref: b7143863
Node: paginator_class144023
Ref: resources paginator-class144142
Ref: b8144142
Node: cache144502
Ref: resources cache144619
Ref: b9144619
Node: throttle144756
Ref: resources throttle144873
Ref: ba144873
Node: allowed_methods145027
Ref: resources allowed-methods145159
Ref: bb145159
Node: list_allowed_methods145574
Ref: resources list-allowed-methods145720
Ref: bc145720
Node: detail_allowed_methods145916
Ref: resources id1146052
Ref: bd146052
Ref: resources detail-allowed-methods146052
Ref: be146052
Node: limit146256
Ref: resources limit146381
Ref: bf146381
Node: max_limit146585
Ref: resources max-limit146696
Ref: c0146696
Node: api_name146969
Ref: resources api-name147088
Ref: c1147088
Node: resource_name147229
Ref: resources resource-name147353
Ref: c2147353
Node: default_format147755
Ref: resources default-format147880
Ref: c3147880
Node: filtering148133
Ref: resources filtering148253
Ref: c4148253
Node: ordering148511
Ref: resources ordering148629
Ref: c5148629
Node: object_class148996
Ref: resources object-class149113
Ref: c6149113
Node: queryset149389
Ref: resources queryset149504
Ref: c7149504
Node: fields149952
Ref: resources fields150063
Ref: c8150063
Node: excludes150216
Ref: resources excludes150339
Ref: c9150339
Node: include_resource_uri150503
Ref: resources include-resource-uri150640
Ref: ca150640
Node: include_absolute_url150863
Ref: resources include-absolute-url151010
Ref: cb151010
Node: always_return_data151244
Ref: resources always-return-data151386
Ref: cc151386
Node: collection_name151851
Ref: resources collection-name151988
Ref: cd151988
Node: detail_uri_name152154
Ref: resources detail-uri-name152264
Ref: ce152264
Node: Basic Filtering152417
Ref: resources basic-filtering152548
Ref: cf152548
Node: Advanced Filtering153410
Ref: resources advanced-filtering153560
Ref: d0153560
Node: Using PUT/DELETE/PATCH In Unsupported Places154400
Ref: resources using-put-delete-patch-in-unsupported-places154551
Ref: d1154551
Node: Resource Methods155131
Ref: resources resource-methods155285
Ref: d2155285
Node: wrap_view157042
Ref: resources wrap-view157131
Ref: d3157131
Ref: resources Resource wrap_view157174
Ref: d4157174
Node: base_urls157524
Ref: resources base-urls157635
Ref: d5157635
Ref: resources Resource base_urls157678
Ref: d6157678
Node: override_urls157928
Ref: resources override-urls158042
Ref: d7158042
Ref: resources Resource override_urls158093
Ref: d8158093
Node: prepend_urls158222
Ref: resources prepend-urls158331
Ref: d9158331
Ref: resources Resource prepend_urls158380
Ref: da158380
Node: urls158664
Ref: resources urls158776
Ref: db158776
Ref: resources Resource urls158809
Ref: dc158809
Node: determine_format159120
Ref: resources determine-format159232
Ref: dd159232
Ref: resources Resource determine_format159289
Ref: de159289
Node: serialize<2>159479
Ref: resources serialize159601
Ref: df159601
Ref: resources Resource serialize159644
Ref: e0159644
Node: deserialize<2>159912
Ref: resources deserialize160046
Ref: e1160046
Ref: resources Resource deserialize160093
Ref: e2160093
Node: alter_list_data_to_serialize160444
Ref: resources alter-list-data-to-serialize160596
Ref: e3160596
Ref: resources Resource alter_list_data_to_serialize160677
Ref: e4160677
Node: alter_detail_data_to_serialize160988
Ref: resources alter-detail-data-to-serialize161154
Ref: e5161154
Ref: resources Resource alter_detail_data_to_serialize161241
Ref: e6161241
Node: alter_deserialized_list_data161546
Ref: resources alter-deserialized-list-data161714
Ref: e7161714
Ref: resources Resource alter_deserialized_list_data161797
Ref: e8161797
Node: alter_deserialized_detail_data162036
Ref: resources alter-deserialized-detail-data162187
Ref: e9162187
Ref: resources Resource alter_deserialized_detail_data162274
Ref: ea162274
Node: dispatch_list162527
Ref: resources dispatch-list162665
Ref: eb162665
Ref: resources Resource dispatch_list162718
Ref: ec162718
Node: dispatch_detail162941
Ref: resources dispatch-detail163057
Ref: ed163057
Ref: resources Resource dispatch_detail163114
Ref: ee163114
Node: dispatch163326
Ref: resources dispatch163454
Ref: ef163454
Ref: resources Resource dispatch163497
Ref: f0163497
Node: remove_api_resource_names163702
Ref: resources remove-api-resource-names163827
Ref: f1163827
Ref: resources Resource remove_api_resource_names163904
Ref: f2163904
Node: method_check164249
Ref: resources method-check164379
Ref: f3164379
Ref: resources Resource method_check164430
Ref: f4164430
Node: is_authorized165053
Ref: resources is-authorized165174
Ref: f5165174
Ref: resources Resource is_authorized165227
Ref: f6165227
Node: is_authenticated165513
Ref: resources is-authenticated165636
Ref: f7165636
Ref: resources Resource is_authenticated165695
Ref: f8165695
Node: throttle_check165925
Ref: resources throttle-check166055
Ref: f9166055
Ref: resources Resource throttle_check166110
Ref: fa166110
Node: log_throttled_access166296
Ref: resources log-throttled-access166422
Ref: fb166422
Ref: resources Resource log_throttled_access166489
Ref: fc166489
Node: build_bundle166699
Ref: resources build-bundle166824
Ref: fd166824
Ref: resources Resource build_bundle166875
Ref: fe166875
Node: build_filters167228
Ref: resources build-filters167346
Ref: ff167346
Ref: resources Resource build_filters167399
Ref: 100167399
Node: apply_sorting167642
Ref: resources apply-sorting167770
Ref: 101167770
Ref: resources Resource apply_sorting167823
Ref: 102167823
Node: get_bundle_detail_data168078
Ref: resources get-bundle-detail-data168209
Ref: 103168209
Ref: resources Resource get_bundle_detail_data168280
Ref: 104168280
Node: get_resource_uri168475
Ref: resources get-resource-uri168612
Ref: 105168612
Ref: resources Resource get_resource_uri168671
Ref: 106168671
Node: resource_uri_kwargs169120
Ref: resources resource-uri-kwargs169252
Ref: 107169252
Ref: resources Resource resource_uri_kwargs169317
Ref: 108169317
Node: detail_uri_kwargs169720
Ref: resources detail-uri-kwargs169847
Ref: 109169847
Ref: resources Resource detail_uri_kwargs169908
Ref: 10a169908
Node: get_via_uri170198
Ref: resources get-via-uri170320
Ref: 10b170320
Ref: resources Resource get_via_uri170369
Ref: 10c170369
Node: full_dehydrate170652
Ref: resources full-dehydrate170769
Ref: 10d170769
Ref: resources Resource full_dehydrate170824
Ref: 10e170824
Node: dehydrate<2>170977
Ref: resources id2171095
Ref: 10f171095
Ref: resources Resource dehydrate171140
Ref: 110171140
Node: full_hydrate171434
Ref: resources full-hydrate171548
Ref: 111171548
Ref: resources Resource full_hydrate171599
Ref: 112171599
Node: hydrate<2>171743
Ref: resources id3171856
Ref: 113171856
Ref: resources Resource hydrate171897
Ref: 114171897
Node: hydrate_m2m172185
Ref: resources hydrate-m2m172298
Ref: 115172298
Ref: resources Resource hydrate_m2m172347
Ref: 116172347
Node: build_schema172445
Ref: resources build-schema172570
Ref: 117172570
Ref: resources Resource build_schema172621
Ref: 118172621
Node: dehydrate_resource_uri172831
Ref: resources dehydrate-resource-uri172963
Ref: 119172963
Ref: resources Resource dehydrate_resource_uri173034
Ref: 11a173034
Node: generate_cache_key173242
Ref: resources generate-cache-key173377
Ref: 11b173377
Ref: resources Resource generate_cache_key173440
Ref: 11c173440
Node: get_object_list173612
Ref: resources get-object-list173751
Ref: 11d173751
Ref: resources Resource get_object_list173808
Ref: 11e173808
Node: apply_authorization_limits174064
Ref: resources apply-authorization-limits174195
Ref: 11f174195
Ref: resources Resource apply_authorization_limits174274
Ref: 120174274
Node: can_create174525
Ref: resources can-create174651
Ref: 121174651
Ref: resources Resource can_create174698
Ref: 122174698
Node: can_update174794
Ref: resources can-update174904
Ref: 123174904
Ref: resources Resource can_update174951
Ref: 124174951
Node: can_delete175083
Ref: resources can-delete175196
Ref: 125175196
Ref: resources Resource can_delete175243
Ref: 126175243
Node: apply_filters175341
Ref: resources apply-filters175456
Ref: 127175456
Ref: resources Resource apply_filters175509
Ref: 128175509
Node: obj_get_list175781
Ref: resources obj-get-list175905
Ref: 129175905
Ref: resources Resource obj_get_list175956
Ref: 12a175956
Node: cached_obj_get_list176215
Ref: resources cached-obj-get-list176333
Ref: 12b176333
Ref: resources Resource cached_obj_get_list176398
Ref: 12c176398
Node: obj_get176571
Ref: resources obj-get176691
Ref: 12d176691
Ref: resources Resource obj_get176732
Ref: 12e176732
Node: cached_obj_get177051
Ref: resources cached-obj-get177162
Ref: 12f177162
Ref: resources Resource cached_obj_get177217
Ref: 130177217
Node: obj_create177380
Ref: resources obj-create177514
Ref: 131177514
Ref: resources Resource obj_create177561
Ref: 132177561
Node: lookup_kwargs_with_identifiers177820
Ref: resources lookup-kwargs-with-identifiers177950
Ref: 133177950
Ref: resources Resource lookup_kwargs_with_identifiers178037
Ref: 134178037
Node: obj_update178316
Ref: resources obj-update178451
Ref: 135178451
Ref: resources Resource obj_update178498
Ref: 136178498
Node: obj_delete_list178789
Ref: resources obj-delete-list178904
Ref: 137178904
Ref: resources Resource obj_delete_list178961
Ref: 138178961
Node: obj_delete179203
Ref: resources obj-delete179323
Ref: 139179323
Ref: resources Resource obj_delete179370
Ref: 13a179370
Node: create_response179597
Ref: resources create-response179710
Ref: 13b179710
Ref: resources Resource create_response179767
Ref: 13c179767
Node: is_valid179990
Ref: resources is-valid180101
Ref: 13d180101
Ref: resources Resource is_valid180144
Ref: 13e180144
Node: rollback180438
Ref: resources rollback180542
Ref: 13f180542
Ref: resources Resource rollback180585
Ref: 140180585
Node: get_list180887
Ref: resources get-list180993
Ref: 141180993
Ref: resources Resource get_list181036
Ref: 142181036
Node: get_detail181271
Ref: resources get-detail181377
Ref: 143181377
Ref: resources Resource get_detail181424
Ref: 144181424
Node: put_list181669
Ref: resources put-list181777
Ref: 145181777
Ref: resources Resource put_list181820
Ref: 146181820
Node: put_detail182234
Ref: resources put-detail182341
Ref: 147182341
Ref: resources Resource put_detail182388
Ref: 148182388
Node: post_list183052
Ref: resources post-list183162
Ref: 149183162
Ref: resources Resource post_list183207
Ref: 14a183207
Node: post_detail183582
Ref: resources post-detail183693
Ref: 14b183693
Ref: resources Resource post_detail183742
Ref: 14c183742
Node: delete_list184033
Ref: resources delete-list184148
Ref: 14d184148
Ref: resources Resource delete_list184197
Ref: 14e184197
Node: delete_detail184406
Ref: resources delete-detail184520
Ref: 14f184520
Ref: resources Resource delete_detail184573
Ref: 150184573
Node: patch_list184838
Ref: resources id4184953
Ref: 151184953
Ref: resources patch-list184953
Ref: 2c184953
Ref: resources Resource patch_list185000
Ref: 152185000
Node: patch_detail186981
Ref: resources patch-detail187093
Ref: 153187093
Ref: resources Resource patch_detail187144
Ref: 154187144
Node: get_schema187400
Ref: resources get-schema187514
Ref: 155187514
Ref: resources Resource get_schema187561
Ref: 156187561
Node: get_multiple187807
Ref: resources get-multiple187900
Ref: 157187900
Ref: resources Resource get_multiple187951
Ref: 158187951
Node: ModelResource Methods188230
Ref: resources modelresource-methods188331
Ref: 159188331
Node: should_skip_field189222
Ref: resources should-skip-field189342
Ref: 15a189342
Ref: resources ModelResource should_skip_field189401
Ref: 15b189401
Node: api_field_from_django_field189570
Ref: resources api-field-from-django-field189709
Ref: 15c189709
Ref: resources ModelResource api_field_from_django_field189788
Ref: 15d189788
Node: get_fields189980
Ref: resources get-fields190117
Ref: 15e190117
Ref: resources ModelResource get_fields190162
Ref: 15f190162
Node: check_filtering190368
Ref: resources check-filtering190494
Ref: 160190494
Ref: resources ModelResource check_filtering190549
Ref: 161190549
Node: build_filters<2>190987
Ref: resources id5191119
Ref: 162191119
Ref: resources ModelResource build_filters191170
Ref: 163191170
Node: apply_sorting<2>191903
Ref: resources id6192036
Ref: 164192036
Ref: resources ModelResource apply_sorting192087
Ref: 165192087
Node: apply_filters<2>192452
Ref: resources id7192587
Ref: 166192587
Ref: resources ModelResource apply_filters192638
Ref: 167192638
Node: get_object_list<2>192905
Ref: resources id8193039
Ref: 168193039
Ref: resources ModelResource get_object_list193094
Ref: 169193094
Node: obj_get_list<2>193279
Ref: resources id9193407
Ref: 16a193407
Ref: resources ModelResource obj_get_list193456
Ref: 16b193456
Node: obj_get<2>193661
Ref: resources id10193784
Ref: 16c193784
Ref: resources ModelResource obj_get193825
Ref: 16d193825
Node: obj_create<2>194009
Ref: resources id11194130
Ref: 16e194130
Ref: resources ModelResource obj_create194177
Ref: 16f194177
Node: obj_update<2>194290
Ref: resources id12194419
Ref: 170194419
Ref: resources ModelResource obj_update194466
Ref: 171194466
Node: obj_delete_list<2>194579
Ref: resources id13194708
Ref: 172194708
Ref: resources ModelResource obj_delete_list194765
Ref: 173194765
Node: obj_delete<2>194947
Ref: resources id14195074
Ref: 174195074
Ref: resources ModelResource obj_delete195121
Ref: 175195121
Node: rollback<2>195311
Ref: resources id15195432
Ref: 176195432
Ref: resources ModelResource rollback195475
Ref: 177195475
Node: save_related195652
Ref: resources save-related195768
Ref: 178195768
Ref: resources ModelResource save_related195819
Ref: 179195819
Node: save_m2m196227
Ref: resources save-m2m196351
Ref: 17a196351
Ref: resources ModelResource save_m2m196394
Ref: 17b196394
Node: get_resource_uri<2>196750
Ref: resources id16196853
Ref: 17c196853
Ref: resources ModelResource get_resource_uri196912
Ref: 17d196912
Node: Bundles197091
Ref: bundles bundles197194
Ref: 17e197194
Ref: bundles doc197194
Ref: 17f197194
Node: What Are Bundles?197266
Ref: bundles what-are-bundles197355
Ref: 180197355
Node: Attributes197911
Ref: bundles attributes198000
Ref: 181198000
Node: obj198279
Ref: bundles obj198351
Ref: 182198351
Node: data198489
Ref: bundles data198577
Ref: 183198577
Node: request198686
Ref: bundles request198782
Ref: 184198782
Node: related_obj198931
Ref: bundles related-obj199035
Ref: 185199035
Node: related_name199218
Ref: bundles related-name199306
Ref: 186199306
Node: Api199496
Ref: api api199605
Ref: 187199605
Ref: api doc199605
Ref: 188199605
Ref: api ref-api199605
Ref: 189199605
Node: Quick Start<2>200018
Ref: api quick-start200101
Ref: 18a200101
Node: Api Methods200531
Ref: api api-methods200614
Ref: 18b200614
Node: register201090
Ref: api register201174
Ref: 18c201174
Node: unregister201480
Ref: api unregister201595
Ref: 18d201595
Node: canonical_resource_for201742
Ref: api canonical-resource-for201856
Ref: 18e201856
Node: override_urls<2>202128
Ref: api override-urls202236
Ref: 18f202236
Node: prepend_urls<2>202406
Ref: api prepend-urls202514
Ref: 190202514
Node: urls<2>202823
Ref: api urls202936
Ref: 191202936
Node: top_level203097
Ref: api top-level203179
Ref: 192203179
Node: Resource Fields203384
Ref: fields resource-fields203493
Ref: 193203493
Ref: fields doc203493
Ref: 194203493
Ref: fields ref-fields203493
Ref: 195203493
Node: Quick Start<3>203877
Ref: fields quick-start203981
Ref: 196203981
Node: Standard Data Fields204648
Ref: fields standard-data-fields204780
Ref: 197204780
Node: Common Field Options205408
Ref: fields common-field-options205514
Ref: 198205514
Node: attribute205722
Ref: fields attribute205813
Ref: 199205813
Ref: fields ApiField attribute205856
Ref: 19a205856
Node: default206124
Ref: fields default206228
Ref: 19b206228
Ref: fields ApiField default206267
Ref: 19c206267
Node: null206444
Ref: fields null206544
Ref: 19d206544
Ref: fields ApiField null206577
Ref: 19e206577
Node: blank206697
Ref: fields blank206798
Ref: 19f206798
Ref: fields ApiField blank206833
Ref: 1a0206833
Node: readonly207101
Ref: fields readonly207204
Ref: 1a1207204
Ref: fields ApiField readonly207245
Ref: 1a2207245
Node: unique207368
Ref: fields unique207475
Ref: 1a3207475
Ref: fields ApiField unique207512
Ref: 1a4207512
Node: help_text207614
Ref: fields help-text207704
Ref: 1a5207704
Ref: fields ApiField help_text207747
Ref: 1a6207747
Node: Field Types207894
Ref: fields field-types208021
Ref: 1a7208021
Ref: fields module-tastypie fields208021
Ref: 0208021
Node: BooleanField208064
Ref: fields booleanfield208180
Ref: 1a8208180
Node: CharField208317
Ref: fields charfield208431
Ref: 1a9208431
Node: DateField208569
Ref: fields datefield208684
Ref: 1aa208684
Node: DateTimeField208744
Ref: fields datetimefield208862
Ref: 1ab208862
Node: DecimalField208934
Ref: fields decimalfield209052
Ref: 1ac209052
Node: DictField209121
Ref: fields dictfield209235
Ref: 1ad209235
Node: FileField209301
Ref: fields filefield209413
Ref: 1ae209413
Node: FloatField209540
Ref: fields floatfield209655
Ref: 1af209655
Node: IntegerField209727
Ref: fields integerfield209842
Ref: 1b0209842
Node: ListField210043
Ref: fields listfield210157
Ref: 1b1210157
Node: TimeField210217
Ref: fields timefield210310
Ref: 1b2210310
Node: Relationship Fields210370
Ref: fields relationship-fields210479
Ref: 1b3210479
Node: Common Field Options<2>211448
Ref: fields id1211559
Ref: 1b4211559
Node: to211779
Ref: fields to211863
Ref: 1b5211863
Ref: fields tastypie fields RelatedField to211892
Ref: 1b6211892
Node: full212010
Ref: fields full212118
Ref: 1b7212118
Ref: fields tastypie fields RelatedField full212151
Ref: 1b8212151
Node: related_name<2>212427
Ref: fields related-name212524
Ref: 1b9212524
Ref: fields tastypie fields RelatedField related_name212573
Ref: 1ba212573
Node: Field Types<2>213390
Ref: fields id2213501
Ref: 1bb213501
Node: ToOneField213657
Ref: fields toonefield213749
Ref: 1bc213749
Node: OneToOneField213907
Ref: fields onetoonefield214018
Ref: 1bd214018
Node: ForeignKey214146
Ref: fields foreignkey214258
Ref: 1be214258
Node: ToManyField214380
Ref: fields tomanyfield214494
Ref: 1bf214494
Node: ManyToManyField215195
Ref: fields manytomanyfield215313
Ref: 1c0215313
Node: OneToManyField215448
Ref: fields onetomanyfield215546
Ref: 1c1215546
Node: Caching215679
Ref: caching caching215795
Ref: 1c2215795
Ref: caching ref-caching215795
Ref: 1c3215795
Ref: caching doc215795
Ref: 13215795
Ref: Caching-Footnote-1217141
Ref: Caching-Footnote-2217178
Node: Usage217215
Ref: caching usage217297
Ref: 1c5217297
Node: Caching Options217876
Ref: caching caching-options217994
Ref: 1c6217994
Node: NoCache218131
Ref: caching nocache218219
Ref: 1c7218219
Node: SimpleCache218371
Ref: caching simplecache218459
Ref: 1c8218459
Node: Implementing Your Own Cache218792
Ref: caching implementing-your-own-cache218923
Ref: 1c9218923
Node: HTTP Cache-Control219936
Ref: caching id1220061
Ref: 1ca220061
Ref: caching http-cache-control220061
Ref: 1c4220061
Ref: HTTP Cache-Control-Footnote-1221699
Ref: HTTP Cache-Control-Footnote-2221738
Ref: HTTP Cache-Control-Footnote-3221835
Node: HTTP Vary221945
Ref: caching http-vary222034
Ref: 1cb222034
Ref: caching cache-control222034
Ref: 1cc222034
Node: Validation222767
Ref: validation validation222898
Ref: 1cd222898
Ref: validation doc222898
Ref: 1ce222898
Ref: validation ref-validation222898
Ref: 1cf222898
Node: Usage<2>223538
Ref: validation usage223629
Ref: 1d0223629
Node: Validation Options224206
Ref: validation validation-options224338
Ref: 1d1224338
Node: Validation<2>224536
Ref: validation id1224636
Ref: 1d2224636
Node: FormValidation224832
Ref: validation formvalidation224966
Ref: 1d3224966
Node: CleanedDataFormValidation225927
Ref: validation cleaneddataformvalidation226039
Ref: 1d4226039
Node: Implementing Your Own Validation226332
Ref: validation implementing-your-own-validation226447
Ref: 1d5226447
Node: Authentication / Authorization227389
Ref: authentication_authorization authentication-authorization227526
Ref: 1d6227526
Ref: authentication_authorization doc227526
Ref: 12227526
Ref: authentication_authorization id1227526
Ref: 1d7227526
Node: Usage<3>228297
Ref: authentication_authorization usage228412
Ref: 1d8228412
Node: Authentication Options229124
Ref: authentication_authorization authentication-options229269
Ref: 1d9229269
Node: Authentication229568
Ref: authentication_authorization authentication229678
Ref: 1da229678
Node: BasicAuthentication229851
Ref: authentication_authorization basicauthentication229990
Ref: 1db229990
Ref: BasicAuthentication-Footnote-1230455
Node: ApiKeyAuthentication230525
Ref: authentication_authorization apikeyauthentication230671
Ref: 1dc230671
Ref: authentication_authorization this-post230671
Ref: 1dd230671
Ref: ApiKeyAuthentication-Footnote-1232052
Node: SessionAuthentication232122
Ref: authentication_authorization id2232269
Ref: 1de232269
Ref: authentication_authorization sessionauthentication232269
Ref: 1df232269
Node: DigestAuthentication232627
Ref: authentication_authorization digestauthentication232773
Ref: 1e0232773
Ref: DigestAuthentication-Footnote-1233373
Node: OAuthAuthentication233443
Ref: authentication_authorization oauthauthentication233587
Ref: 1e1233587
Ref: authentication_authorization id3233587
Ref: 1e2233587
Ref: OAuthAuthentication-Footnote-1234528
Node: MultiAuthentication234574
Ref: authentication_authorization multiauthentication234689
Ref: 1e3234689
Ref: authentication_authorization mechanize234689
Ref: 1e4234689
Node: Authorization Options235792
Ref: authentication_authorization authorization-options235979
Ref: 1e5235979
Node: Authorization236176
Ref: authentication_authorization authorization236286
Ref: 1e6236286
Node: ReadOnlyAuthorization236581
Ref: authentication_authorization readonlyauthorization236719
Ref: 1e7236719
Node: DjangoAuthorization236960
Ref: authentication_authorization djangoauthorization237076
Ref: 1e8237076
Node: Implementing Your Own Authentication/Authorization237356
Ref: authentication_authorization implementing-your-own-authentication-authorization237512
Ref: 1e9237512
Node: Serialization239154
Ref: serialization serialization239291
Ref: 1ea239291
Ref: serialization doc239291
Ref: 16239291
Ref: serialization ref-serialization239291
Ref: 1eb239291
Node: Usage<4>239937
Ref: serialization usage240045
Ref: 1ec240045
Node: Implementing Your Own Serializer241310
Ref: serialization implementing-your-own-serializer241445
Ref: 1ed241445
Node: Serializer Methods243862
Ref: serialization serializer-methods243980
Ref: 1ee243980
Node: get_mime_for_format244751
Ref: serialization get-mime-for-format244858
Ref: 1ef244858
Node: format_datetime245132
Ref: serialization format-datetime245259
Ref: 1f0245259
Node: format_date245607
Ref: serialization format-date245726
Ref: 1f1245726
Node: format_time246049
Ref: serialization format-time246165
Ref: 1f2246165
Node: serialize<3>246486
Ref: serialization serialize246605
Ref: 1f3246605
Node: deserialize<3>246850
Ref: serialization deserialize246967
Ref: 1f4246967
Node: to_simple247209
Ref: serialization to-simple247322
Ref: 1f5247322
Node: to_etree247621
Ref: serialization to-etree247730
Ref: 1f6247730
Node: from_etree247958
Ref: serialization from-etree248065
Ref: 1f7248065
Node: to_json248401
Ref: serialization to-json248509
Ref: 1f8248509
Node: from_json248658
Ref: serialization from-json248764
Ref: 1f9248764
Node: to_jsonp248933
Ref: serialization to-jsonp249038
Ref: 1fa249038
Node: to_xml249223
Ref: serialization to-xml249327
Ref: 1fb249327
Node: from_xml249472
Ref: serialization from-xml249575
Ref: 1fc249575
Node: to_yaml249740
Ref: serialization to-yaml249846
Ref: 1fd249846
Node: from_yaml249995
Ref: serialization from-yaml250101
Ref: 1fe250101
Node: to_plist250270
Ref: serialization to-plist250379
Ref: 1ff250379
Node: from_plist250539
Ref: serialization from-plist250646
Ref: 200250646
Node: to_html250826
Ref: serialization to-html250934
Ref: 201250934
Node: from_html251213
Ref: serialization from-html251302
Ref: 202251302
Node: Throttling251586
Ref: throttling ref-throttling251702
Ref: 203251702
Ref: throttling doc251702
Ref: 14251702
Ref: throttling throttling251702
Ref: 204251702
Node: Usage<5>252113
Ref: throttling usage252202
Ref: 205252202
Node: Throttle Options252747
Ref: throttling throttle-options252875
Ref: 206252875
Node: BaseThrottle253531
Ref: throttling basethrottle253627
Ref: 207253627
Node: CacheThrottle253835
Ref: throttling cachethrottle253955
Ref: 208253955
Node: CacheDBThrottle254108
Ref: throttling cachedbthrottle254207
Ref: 209254207
Node: Implementing Your Own Throttle254448
Ref: throttling implementing-your-own-throttle254559
Ref: 20a254559
Node: Paginator255486
Ref: paginator paginator255598
Ref: 20b255598
Ref: paginator ref-paginator255598
Ref: 20c255598
Ref: paginator doc255598
Ref: 20d255598
Node: Usage<6>256217
Ref: paginator usage256320
Ref: 20e256320
Node: Implementing Your Own Paginator257049
Ref: paginator implementing-your-own-paginator257152
Ref: 20f257152
Node: GeoDjango258227
Ref: geodjango geodjango258364
Ref: 210258364
Ref: geodjango doc258364
Ref: 211258364
Ref: geodjango ref-geodjango258364
Ref: 212258364
Ref: GeoDjango-Footnote-1258704
Ref: GeoDjango-Footnote-2258748
Node: Usage<7>258839
Ref: geodjango usage258902
Ref: 213258902
Node: Filtering260403
Ref: geodjango filtering260466
Ref: 214260466
Ref: Filtering-Footnote-1261769
Ref: Filtering-Footnote-2261860
Node: ContentTypes and GenericForeignKeys261909
Ref: content_types ref-content-types262054
Ref: 215262054
Ref: content_types doc262054
Ref: 216262054
Ref: content_types contenttypes-and-genericforeignkeys262054
Ref: 217262054
Ref: ContentTypes and GenericForeignKeys-Footnote-1262428
Node: Usage<8>262499
Ref: content_types usage262588
Ref: 218262588
Node: Tastypie Cookbook264395
Ref: cookbook tastypie-cookbook264549
Ref: 219264549
Ref: cookbook doc264549
Ref: 17264549
Ref: cookbook ref-cookbook264549
Ref: 21a264549
Node: Adding Custom Values265002
Ref: cookbook adding-custom-values265133
Ref: 21b265133
Node: Per-Request Alterations To The Queryset265634
Ref: cookbook per-request-alterations-to-the-queryset265810
Ref: 21c265810
Node: Using Your Resource In Regular Views266367
Ref: cookbook using-your-resource-in-regular-views266554
Ref: 21d266554
Node: Using Non-PK Data For Your URLs267480
Ref: cookbook using-non-pk-data-for-your-urls267644
Ref: 21e267644
Node: Nested Resources268569
Ref: cookbook nested-resources268724
Ref: 21f268724
Node: Adding Search Functionality270648
Ref: cookbook adding-search-functionality270799
Ref: 220270799
Ref: Adding Search Functionality-Footnote-1272831
Node: Creating per-user resources272865
Ref: cookbook haystack273028
Ref: 221273028
Ref: cookbook creating-per-user-resources273028
Ref: 222273028
Node: camelCase JSON Serialization274279
Ref: cookbook camelcase-json-serialization274448
Ref: 223274448
Node: Pretty-printed JSON Serialization276919
Ref: cookbook pretty-printed-json-serialization277087
Ref: 224277087
Node: Determining format via URL277848
Ref: cookbook determining-format-via-url278014
Ref: 225278014
Node: Adding to the Django Admin280133
Ref: cookbook adding-to-the-django-admin280293
Ref: 226280293
Node: Using SessionAuthentication281124
Ref: cookbook using-sessionauthentication281249
Ref: 227281249
Node: Debugging Tastypie283546
Ref: debugging debugging-tastypie283685
Ref: 228283685
Ref: debugging doc283685
Ref: 229283685
Node: "I'm getting XML output in my browser but I want JSON output!"284070
Ref: debugging i-m-getting-xml-output-in-my-browser-but-i-want-json-output284243
Ref: 22a284243
Node: "What's the format for a POST or PUT?"285087
Ref: debugging what-s-the-format-for-a-post-or-put285332
Ref: 22b285332
Ref: "What's the format for a POST or PUT?"-Footnote-1286992
Node: "Why is my syncdb with superuser failing with a DatabaseError?"287026
Ref: debugging why-is-my-syncdb-with-superuser-failing-with-a-databaseerror287200
Ref: 22c287200
Ref: debugging requests287200
Ref: 22d287200
Node: Sites Using Tastypie287812
Ref: who_uses ref-who-uses287946
Ref: 22e287946
Ref: who_uses doc287946
Ref: 22f287946
Ref: who_uses sites-using-tastypie287946
Ref: 230287946
Node: LJWorld Marketplace288328
Ref: who_uses ljworld-marketplace288430
Ref: 231288430
Node: Forkinit288549
Ref: who_uses forkinit288673
Ref: 232288673
Node: Read The Docs288817
Ref: who_uses read-the-docs288927
Ref: 233288927
Node: Luzme289145
Ref: who_uses luzme289257
Ref: 234289257
Node: Politifact289422
Ref: who_uses politifact289526
Ref: 235289526
Node: Crate289668
Ref: who_uses crate289776
Ref: 236289776
Node: LocalWiki289927
Ref: who_uses localwiki290036
Ref: 237290036
Ref: LocalWiki-Footnote-1290375
Node: I-Am-CC org290403
Ref: who_uses i-am-cc-org290498
Ref: 238290498
Ref: I-Am-CC org-Footnote-1290707
Node: Contributing290733
Ref: contributing contributing290840
Ref: 239290840
Ref: contributing doc290840
Ref: 23a290840
Node: Philosophy291180
Ref: contributing philosophy291298
Ref: 23b291298
Node: Guidelines For Reporting An Issue/Feature292209
Ref: contributing guidelines-for-reporting-an-issue-feature292368
Ref: 23c292368
Node: Guidelines For Contributing Code293659
Ref: contributing guidelines-for-contributing-code293840
Ref: 23d293840
Node: Guidelines For Core Contributors295413
Ref: contributing guidelines-for-core-contributors295544
Ref: 23e295544
Node: Getting Help297243
Ref: index getting-help297356
Ref: 23f297356
Ref: Getting Help-Footnote-1297680
Ref: Getting Help-Footnote-2297735
Node: Quick Start<4>297774
Ref: index quick-start297879
Ref: 240297879
Ref: index tastypie-on-irc-freenode-net297879
Ref: 241297879
Node: Requirements298877
Ref: index requirements298983
Ref: 242298983
Ref: Requirements-Footnote-1299218
Node: Required299251
Ref: index required299334
Ref: 243299334
Node: Optional299624
Ref: index optional299707
Ref: 244299707
Node: Why Tastypie?300015
Ref: index pip300125
Ref: 245300125
Ref: index why-tastypie300125
Ref: 246300125
Node: Reference Material300881
Ref: index reference-material300996
Ref: 247300996
Node: Running The Tests301364
Ref: index running-the-tests301484
Ref: 248301484
Ref: Running The Tests-Footnote-1302149
Node: Commercial Support302210
Ref: index report-it302344
Ref: 249302344
Ref: index commercial-support302344
Ref: 24a302344
Ref: Commercial Support-Footnote-1302769
Node: Getting Started with Tastypie<2>302800
Ref: tutorial toast-driven302944
Ref: 24b302944
Ref: Getting Started with Tastypie<2>-Footnote-1305001
Node: Installation<2>305040
Ref: Installation<2>-Footnote-1306681
Ref: Installation<2>-Footnote-2306734
Ref: Installation<2>-Footnote-3306765
Node: Configuration<2>306796
Node: Creating Resources<2>307341
Node: Hooking Up The Resource s<2>308775
Node: Creating More Resources<2>312213
Node: Adding To The Api<2>313544
Node: Limiting Data And Access<2>315769
Node: Beyond The Basics<2>317326
Node: Interacting With The API<2>317975
Ref: Interacting With The API<2>-Footnote-1320230
Node: Front Matter<2>320258
Node: Fetching Data<2>321182
Node: Api-Wide<2>321888
Node: Inspecting The Resource's Schema<2>323435
Node: Getting A Collection Of Resources<2>325937
Node: Getting A Detail Resource<2>329494
Node: Selecting A Subset Of Resources<2>331019
Node: Sending Data<2>332745
Node: Creating A New Resource POST<2>333914
Node: Updating An Existing Resource PUT<2>337073
Node: Partially Updating An Existing Resource PATCH<2>338370
Node: Updating A Whole Collection Of Resources PUT<2>339223
Node: Deleting Data<2>340682
Node: Deleting A Single Resource<2>341186
Node: Deleting A Whole Collection Of Resources<2>342410
Node: Bulk Operations<2>343458
Node: You Did It!<2>344597
Node: Tastypie Settings<2>345141
Node: API_LIMIT_PER_PAGE<2>345691
Node: TASTYPIE_FULL_DEBUG<2>346291
Node: TASTYPIE_CANNED_ERROR<2>347097
Node: TASTYPIE_ALLOW_MISSING_SLASH<2>347616
Node: TASTYPIE_DATETIME_FORMATTING<2>348159
Node: Using Tastypie With Non-ORM Data Sources<2>348620
Node: Approach<2>349567
Node: Using Riak for MessageResource<2>350490
Ref: Using Riak for MessageResource<2>-Footnote-1354849
Node: Tools<2>354904
Node: Browser<2>355522
Node: JSONView<2>355670
Node: Extensions<2>356068
Node: Tastypie-msgpack<2>356256
Ref: Tastypie-msgpack<2>-Footnote-1356521
Node: Python<2>356548
Node: Slumber<2>356759
Node: drest<2>357045
Node: json tool<2>357342
Node: Javascript<2>357865
Node: backbone-tastypie<2>358083
Node: backbone-relational<2>358365
Node: Testing<2>358674
Ref: Testing<2>-Footnote-1361426
Node: Example Usage<2>361487
Node: ResourceTestCase API Reference<2>369705
Node: get_credentials<2>371485
Node: create_basic<2>372066
Node: create_apikey<2>372409
Node: create_digest<2>372764
Node: create_oauth<2>373131
Node: assertHttpOK<2>373452
Node: assertHttpCreated<2>373753
Node: assertHttpAccepted<2>374075
Node: assertHttpMultipleChoices<2>374434
Node: assertHttpSeeOther<2>374794
Node: assertHttpNotModified<2>375138
Node: assertHttpBadRequest<2>375486
Node: assertHttpUnauthorized<2>375835
Node: assertHttpForbidden<2>376188
Node: assertHttpNotFound<2>376530
Node: assertHttpMethodNotAllowed<2>376873
Node: assertHttpConflict<2>377239
Node: assertHttpGone<2>377577
Node: assertHttpTooManyRequests<2>377902
Node: assertHttpApplicationError<2>378268
Node: assertHttpNotImplemented<2>378647
Node: assertValidJSON<2>379010
Node: assertValidXML<2>379383
Node: assertValidYAML<2>379743
Node: assertValidPlist<2>380108
Node: assertValidJSONResponse<2>380493
Node: assertValidXMLResponse<2>380991
Node: assertValidYAMLResponse<2>381491
Node: assertValidPlistResponse<2>381990
Node: deserialize<4>382504
Node: serialize<4>382998
Node: assertKeys<2>383406
Node: TestApiClient API Reference<2>383939
Node: __init__<2>384503
Node: get_content_type<2>384860
Node: get<2>385254
Node: post<2>386288
Node: put<2>387348
Node: patch<2>388406
Node: delete<2>389478
Node: Compatibility Notes<2>390459
Node: ApiKey Database Index<2>390912
Node: Resources<2>391680
Node: Quick Start<5>392968
Node: Why Class-Based?<2>394174
Node: Why Resource vs ModelResource?<2>394968
Node: Flow Through The Request/Response Cycle<2>395616
Node: Why Resource URIs?<2>399186
Node: Advanced Data Preparation<2>400286
Node: The Dehydrate Cycle<2>401092
Node: Per-field dehydrate<2>402691
Node: dehydrate_FOO<2>403169
Node: dehydrate<3>405096
Node: The Hydrate Cycle<2>406743
Node: hydrate<3>408495
Node: hydrate_FOO<2>409641
Node: Per-field hydrate<2>410534
Node: Reverse "Relationships"<2>411007
Node: Resource Options AKA Meta<2>413006
Node: serializer<2>414244
Node: authentication<2>414516
Node: authorization<2>414832
Node: validation<2>415151
Node: paginator_class<2>415448
Node: cache<2>415937
Node: throttle<2>416201
Node: allowed_methods<2>416482
Node: list_allowed_methods<2>417039
Node: detail_allowed_methods<2>417391
Node: limit<2>417741
Node: max_limit<2>418080
Node: api_name<2>418474
Node: resource_name<2>418744
Node: default_format<2>419280
Node: filtering<2>419668
Node: ordering<2>420056
Node: object_class<2>420551
Node: queryset<2>420954
Node: fields<2>421527
Node: excludes<2>421801
Node: include_resource_uri<2>422098
Node: include_absolute_url<2>422468
Node: always_return_data<2>422859
Node: collection_name<2>423476
Node: detail_uri_name<2>423789
Node: Basic Filtering<2>424059
Node: Advanced Filtering<2>425062
Node: Using PUT/DELETE/PATCH In Unsupported Places<2>426062
Node: Resource Methods<2>426803
Node: wrap_view<2>429869
Node: base_urls<2>430358
Node: override_urls<3>430772
Node: prepend_urls<3>431076
Node: urls<3>431528
Node: determine_format<2>431994
Node: serialize<5>432360
Node: deserialize<5>432797
Node: alter_list_data_to_serialize<2>433333
Node: alter_detail_data_to_serialize<2>433884
Node: alter_deserialized_list_data<2>434452
Node: alter_deserialized_detail_data<2>434952
Node: dispatch_list<2>435453
Node: dispatch_detail<2>435877
Node: dispatch<2>436272
Node: remove_api_resource_names<2>436658
Node: method_check<2>437215
Node: is_authorized<2>438029
Node: is_authenticated<2>438499
Node: throttle_check<2>438921
Node: log_throttled_access<2>439302
Node: build_bundle<2>439715
Node: build_filters<3>440254
Node: apply_sorting<3>440678
Node: get_bundle_detail_data<2>441124
Node: get_resource_uri<3>441531
Node: resource_uri_kwargs<2>442186
Node: detail_uri_kwargs<2>442796
Node: get_via_uri<2>443284
Node: full_dehydrate<2>443748
Node: dehydrate<4>444080
Node: full_hydrate<2>444544
Node: hydrate<4>444857
Node: hydrate_m2m<2>445306
Node: build_schema<2>445573
Node: dehydrate_resource_uri<2>445969
Node: generate_cache_key<2>446390
Node: get_object_list<3>446770
Node: apply_authorization_limits<2>447232
Node: can_create<2>447703
Node: can_update<2>447982
Node: can_delete<2>448281
Node: apply_filters<3>448549
Node: obj_get_list<3>448999
Node: cached_obj_get_list<2>449443
Node: obj_get<3>449809
Node: cached_obj_get<2>450299
Node: obj_create<3>450638
Node: lookup_kwargs_with_identifiers<2>451088
Node: obj_update<3>451594
Node: obj_delete_list<3>452077
Node: obj_delete<3>452501
Node: create_response<2>452905
Node: is_valid<2>453308
Node: rollback<3>453766
Node: get_list<2>454225
Node: get_detail<2>454619
Node: put_list<2>455027
Node: put_detail<2>455602
Node: post_list<2>456430
Node: post_detail<2>456970
Node: delete_list<2>457431
Node: delete_detail<2>457814
Node: patch_list<2>458256
Node: patch_detail<2>460409
Node: get_schema<2>460838
Node: get_multiple<2>461255
Node: ModelResource Methods<2>461685
Node: should_skip_field<2>462797
Node: api_field_from_django_field<2>463152
Node: get_fields<2>463572
Node: check_filtering<2>463970
Node: build_filters<4>464596
Node: apply_sorting<4>465516
Node: apply_filters<4>466066
Node: get_object_list<4>466520
Node: obj_get_list<4>466895
Node: obj_get<4>467278
Node: obj_create<4>467627
Node: obj_update<4>467909
Node: obj_delete_list<4>468199
Node: obj_delete<4>468568
Node: rollback<4>468933
Node: save_related<2>469278
Node: save_m2m<2>469860
Node: get_resource_uri<4>470390
Node: Bundles<2>470735
Node: What Are Bundles?<2>470935
Node: Attributes<2>471587
Node: obj<2>472019
Node: data<2>472236
Node: request<2>472443
Node: related_obj<2>472698
Node: related_name<3>472995
Node: Api<2>473280
Node: Quick Start<6>473805
Node: Api Methods<2>474320
Node: register<2>474946
Node: unregister<2>475341
Node: canonical_resource_for<2>475611
Node: override_urls<4>476002
Node: prepend_urls<4>476283
Node: urls<4>476703
Node: top_level<2>476982
Node: Resource Fields<2>477271
Node: Quick Start<7>477799
Node: Standard Data Fields<2>478572
Node: Common Field Options<3>479609
Node: attribute<2>480004
Node: default<2>480415
Node: null<2>480747
Node: blank<2>481012
Node: readonly<2>481428
Node: unique<2>481707
Node: help_text<2>481965
Node: Field Types<3>482254
Node: BooleanField<2>482432
Node: CharField<2>482691
Node: DateField<2>482949
Node: DateTimeField<2>483130
Node: DecimalField<2>483326
Node: DictField<2>483519
Node: FileField<2>483705
Node: FloatField<2>483950
Node: IntegerField<2>484145
Node: ListField<2>484469
Node: TimeField<2>484651
Node: Relationship Fields<2>484809
Node: Common Field Options<4>486003
Node: to<2>486347
Node: full<2>486584
Node: related_name<4>487007
Node: Field Types<4>487973
Node: ToOneField<2>488336
Node: OneToOneField<2>488592
Node: ForeignKey<2>488840
Node: ToManyField<2>489083
Node: ManyToManyField<2>489907
Node: OneToManyField<2>490167
Node: Caching<2>490402
Ref: Caching<2>-Footnote-1491946
Ref: Caching<2>-Footnote-2491983
Node: Usage<9>492020
Node: Caching Options<2>492686
Node: NoCache<2>492975
Node: SimpleCache<2>493220
Node: Implementing Your Own Cache<2>493646
Node: HTTP Cache-Control<2>494798
Ref: HTTP Cache-Control<2>-Footnote-1496569
Ref: HTTP Cache-Control<2>-Footnote-2496608
Ref: HTTP Cache-Control<2>-Footnote-3496705
Node: HTTP Vary<2>496815
Node: Validation<3>497642
Node: Usage<10>498460
Node: Validation Options<2>499131
Node: Validation<4>499514
Node: FormValidation<2>499812
Node: CleanedDataFormValidation<2>500912
Node: Implementing Your Own Validation<2>501322
Node: Authentication / Authorization<2>502384
Node: Usage<11>503386
Node: Authentication Options<2>504216
Node: Authentication<2>504826
Node: BasicAuthentication<2>505114
Ref: BasicAuthentication<2>-Footnote-1505726
Node: ApiKeyAuthentication<2>505796
Ref: ApiKeyAuthentication<2>-Footnote-1507331
Node: SessionAuthentication<2>507401
Node: DigestAuthentication<2>507914
Ref: DigestAuthentication<2>-Footnote-1508668
Node: OAuthAuthentication<2>508738
Ref: OAuthAuthentication<2>-Footnote-1509831
Node: MultiAuthentication<2>509877
Node: Authorization Options<2>511100
Node: Authorization<2>511557
Node: ReadOnlyAuthorization<2>511967
Node: DjangoAuthorization<2>512354
Node: Implementing Your Own Authentication/Authorization<2>512755
Node: Serialization<2>514558
Node: Usage<12>515388
Node: Implementing Your Own Serializer<2>516764
Node: Serializer Methods<2>519322
Node: get_mime_for_format<2>520459
Node: format_datetime<2>520845
Node: format_date<2>521328
Node: format_time<2>521778
Node: serialize<6>522220
Node: deserialize<6>522586
Node: to_simple<2>522947
Node: to_etree<2>523364
Node: from_etree<2>523709
Node: to_json<2>524160
Node: from_json<2>524425
Node: to_jsonp<2>524708
Node: to_xml<2>525006
Node: from_xml<2>525263
Node: to_yaml<2>525539
Node: from_yaml<2>525802
Node: to_plist<2>526085
Node: from_plist<2>526362
Node: to_html<2>526657
Node: from_html<2>527052
Node: Throttling<2>527430
Node: Usage<13>528000
Node: Throttle Options<2>528637
Node: BaseThrottle<2>529479
Node: CacheThrottle<2>529788
Node: CacheDBThrottle<2>530069
Node: Implementing Your Own Throttle<2>530414
Node: Paginator<2>531457
Node: Usage<14>532212
Node: Implementing Your Own Paginator<2>533047
Node: GeoDjango<2>534228
Ref: GeoDjango<2>-Footnote-1534707
Ref: GeoDjango<2>-Footnote-2534751
Node: Usage<15>534842
Node: Filtering<2>536419
Ref: Filtering<2>-Footnote-1537785
Ref: Filtering<2>-Footnote-2537876
Node: ContentTypes and GenericForeignKeys<2>537925
Ref: ContentTypes and GenericForeignKeys<2>-Footnote-1538433
Node: Usage<16>538504
Node: Tastypie Cookbook<2>540400
Node: Adding Custom Values<2>541379
Node: Per-Request Alterations To The Queryset<2>542016
Node: Using Your Resource In Regular Views<2>542757
Node: Using Non-PK Data For Your URLs<2>543878
Node: Nested Resources<2>544975
Node: Adding Search Functionality<2>547062
Ref: Adding Search Functionality<2>-Footnote-1549253
Node: Creating per-user resources<2>549287
Node: camelCase JSON Serialization<2>550709
Node: Pretty-printed JSON Serialization<2>553357
Node: Determining format via URL<2>554294
Node: Adding to the Django Admin<2>556587
Node: Using SessionAuthentication<2>557586
Node: Debugging Tastypie<2>560013
Node: "I'm getting XML output in my browser but I want JSON output!"<2>560700
Node: "What's the format for a POST or PUT?"<2>561722
Ref: "What's the format for a POST or PUT?"<2>-Footnote-1563635
Node: "Why is my syncdb with superuser failing with a DatabaseError?"<2>563669
Node: Sites Using Tastypie<2>564460
Node: LJWorld Marketplace<2>565064
Node: Forkinit<2>565290
Node: Read The Docs<2>565566
Node: Luzme<2>565902
Node: Politifact<2>566187
Node: Crate<2>566441
Node: LocalWiki<2>566708
Ref: LocalWiki<2>-Footnote-1567164
Node: I-Am-CC org<2>567192
Ref: I-Am-CC org<2>-Footnote-1567501
Node: Contributing<2>567527
Node: Philosophy<2>568117
Node: Guidelines For Reporting An Issue/Feature<2>569151
Node: Guidelines For Contributing Code<2>570609
Node: Guidelines For Core Contributors<2>572371
Node: Indices and tables574206
Ref: toc indices-and-tables574325
Ref: 24c574325
Node: Python Module Index574379
Node: Index574561

End Tag Table


Local Variables:
coding: utf-8
End:
